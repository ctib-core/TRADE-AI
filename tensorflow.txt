
Tensors

Tensors are the core datastructure of TensorFlow.js They are a generalization of vectors and matrices to potentially higher dimensions.
Tensors / Creation

We have utility functions for common cases like Scalar, 1D, 2D, 3D and 4D tensors, as well a number of functions to initialize tensors in ways useful for machine learning.
tf.tensor (values, shape?, dtype?) function Source

Creates a tf.Tensor with the provided values, shape and dtype.

// Pass an array of values to create a vector.
tf.tensor([1, 2, 3, 4]).print();

// Pass a nested array of values to make a matrix or a higher
// dimensional tensor.
tf.tensor([[1, 2], [3, 4]]).print();

// Pass a flat array and specify a shape yourself.
tf.tensor([1, 2, 3, 4], [2, 2]).print();

// Pass a `WebGLData` object and specify a shape yourself.

// This makes it possible for TF.js applications to avoid GPU / CPU sync.
// For example, if your application includes a preprocessing step on the GPU,
// you could upload the GPU output directly to TF.js, rather than first
// downloading the values.

// Example for WebGL2:
if (tf.findBackend('custom-webgl') == null) {
   const customCanvas = document.createElement('canvas');
   const customBackend = new tf.MathBackendWebGL(customCanvas);
   tf.registerBackend('custom-webgl', () => customBackend);
}
const savedBackend = tf.getBackend();
await tf.setBackend('custom-webgl');
const gl = tf.backend().gpgpu.gl;
const texture = gl.createTexture();
const tex2d = gl.TEXTURE_2D;
const width = 2;
const height = 2;

gl.bindTexture(tex2d, texture);
gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.texImage2D(
   tex2d, 0, gl.RGBA32F, // internalFormat
   width, height, 0,
   gl.RGBA, // textureFormat
   gl.FLOAT, // textureType
   new Float32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])
);

// Currently, the `texture` has 4 pixels:
// Pixel0 is {R:0, G:1, B:2, A:3}
// Pixel1 is {R:4, G:5, B:6, A:7}
// Pixel2 is {R:8, G:9, B:10, A:11}
// Pixel3 is {R:12, G:13, B:14, A:15}

const logicalShape = [height * width * 2];
const a = tf.tensor({texture, height, width, channels: 'BR'}, logicalShape);
a.print();
// Tensor value will be [2, 0, 6, 4, 10, 8, 14, 12], since [2, 0] is the
// values of 'B' and 'R' channels of Pixel0, [6, 4] is the values of 'B' and
'R'
// channels of Pixel1...

// For postprocessing on the GPU, it's possible to retrieve the texture
// backing any tensor by calling the tensor's `dataToGPU` method like
// so:

const tex = a.dataToGPU();
await tf.setBackend(savedBackend);

// Pass a `WebGPUData` object and specify a shape yourself.

// This makes it possible for TF.js applications to avoid GPU / CPU sync.
// For example, if your application includes a preprocessing step on the GPU,
// you could upload the GPU output directly to TF.js, rather than first
// downloading the values. Unlike WebGL, this optionally supports zero copy
// by WebGPUData.zeroCopy. When zeroCopy is false or undefined(default), this
// passing GPUBuffer can be destroyed after tensor is created. When zeroCopy
// is true, this GPUBuffer is bound directly by the tensor, so do not destroy
// this GPUBuffer until all access is done.

// Example for WebGPU:
function createGPUBufferFromData(device, data, dtype) {
   const bytesPerElement = 4;
   const sizeInBytes = data.length * bytesPerElement;

   const gpuWriteBuffer = device.createBuffer({
     mappedAtCreation: true,
     size: sizeInBytes,
     usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC
   });
   const arrayBuffer = gpuWriteBuffer.getMappedRange();
   if (dtype === 'float32') {
     new Float32Array(arrayBuffer).set(data);
   } else if (dtype === 'int32') {
     new Int32Array(arrayBuffer).set(data);
   } else {
     throw new Error(
         `Creating tensor from GPUBuffer only supports` +
         `'float32'|'int32' dtype, while the dtype is ${dtype}.`);
   }
   gpuWriteBuffer.unmap();

   const gpuReadBuffer = device.createBuffer({
     mappedAtCreation: false,
     size: sizeInBytes,
     usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE |
         GPUBufferUsage.COPY_SRC
   });

   const copyEncoder = device.createCommandEncoder();
   copyEncoder.copyBufferToBuffer(
       gpuWriteBuffer, 0, gpuReadBuffer, 0, sizeInBytes);
   const copyCommands = copyEncoder.finish();
   device.queue.submit([copyCommands]);
   gpuWriteBuffer.destroy();
   return gpuReadBuffer;
}

const savedBackend = tf.getBackend();
await tf.setBackend('webgpu').catch(
     () => {throw new Error(
         'Failed to use WebGPU backend. Please use Chrome Canary to run.')});
const dtype = 'float32';
const device = tf.backend().device;
const aData = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
const bData = [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4];
const expected = [2, 4, 6, 8, 6, 8, 10, 12, 10, 12, 14, 16, 14, 16, 18, 20];
const aBuffer = createGPUBufferFromData(device, aData, dtype);
const shape = [aData.length];
// To use zeroCopy, use {buffer: aBuffer, zeroCopy: true} instead and destroy
// aBuffer untill all access is done.
const a = tf.tensor({buffer: aBuffer}, shape, dtype);
const b = tf.tensor(bData, shape, dtype);
const result = tf.add(a, b);
result.print();
a.dispose();
b.dispose();
result.dispose();
aBuffer.destroy();
await tf.setBackend(savedBackend);

Parameters:

    values (TypedArray|Array|WebGLData|WebGPUData) The values of the tensor. Can be nested array of numbers, or a flat array, or a TypedArray(At the moment it supports Uint8Array, Uint8ClampedArray, Int32Array, Float32Array) data types, or a WebGLData object, or a WebGPUData object. If the values are strings, they will be encoded as utf-8 and kept as Uint8Array[]. If the values is a WebGLData object, the dtype could only be 'float32' or 'int32' and the object has to have: 1. texture, a WebGLTexture, the texture must share the same WebGLRenderingContext with TFJS's WebGL backend (you could create a custom WebGL backend from your texture's canvas) and the internal texture format for the input texture must be floating point or normalized integer; 2. height, the height of the texture; 3. width, the width of the texture; 4. channels, a non-empty subset of 'RGBA', indicating the values of which channels will be passed to the tensor, such as 'R' or 'BR' (The order of the channels affect the order of tensor values. ). (If the values passed from texture is less than the tensor size, zeros will be padded at the rear.). If the values is a WebGPUData object, the dtype could only be 'float32' or 'int32 and the object has to have: buffer, a GPUBuffer. The buffer must:

        share the same GPUDevice with TFJS's WebGPU backend; 2. buffer.usage should at least support GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC; 3. buffer.size should not be smaller than the byte size of tensor shape. WebGPUData optionally supports zero copy by flag zeroCopy. When zeroCopy is false or undefined(default),this passing GPUBuffer can be destroyed after tensor is created. When zeroCopy is true, this GPUBuffer is bound directly by the tensor, so do not destroy this GPUBuffer until all access is done.
    shape (number[]) The shape of the tensor. Optional. If not provided, it is inferred from values. Optional
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data type. Optional

Returns: tf.Tensor
tf.scalar (value, dtype?) function Source

Creates rank-0 tf.Tensor (scalar) with the provided value and dtype.

The same functionality can be achieved with tf.tensor(), but in general we recommend using tf.scalar() as it makes the code more readable.

tf.scalar(3.14).print();

Parameters:

    value (number|boolean|string|Uint8Array) The value of the scalar.
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data type. Optional

Returns: tf.Scalar
tf.tensor1d (values, dtype?) function Source

Creates rank-1 tf.Tensor with the provided values, shape and dtype.

The same functionality can be achieved with tf.tensor(), but in general we recommend using tf.tensor1d() as it makes the code more readable.

tf.tensor1d([1, 2, 3]).print();

Parameters:

    values (TypedArray|Array) The values of the tensor. Can be array of numbers, or a TypedArray.
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data type. Optional

Returns: tf.Tensor1D
tf.tensor2d (values, shape?, dtype?) function Source

Creates rank-2 tf.Tensor with the provided values, shape and dtype.

The same functionality can be achieved with tf.tensor(), but in general we recommend using tf.tensor2d() as it makes the code more readable.

// Pass a nested array.
tf.tensor2d([[1, 2], [3, 4]]).print();

// Pass a flat array and specify a shape.
tf.tensor2d([1, 2, 3, 4], [2, 2]).print();

Parameters:

    values (TypedArray|Array) The values of the tensor. Can be nested array of numbers, or a flat array, or a TypedArray.
    shape ([number, number]) The shape of the tensor. If not provided, it is inferred from values. Optional
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data type. Optional

Returns: tf.Tensor2D
tf.tensor3d (values, shape?, dtype?) function Source

Creates rank-3 tf.Tensor with the provided values, shape and dtype.

The same functionality can be achieved with tf.tensor(), but in general we recommend using tf.tensor3d() as it makes the code more readable.

// Pass a nested array.
tf.tensor3d([[[1], [2]], [[3], [4]]]).print();

// Pass a flat array and specify a shape.
tf.tensor3d([1, 2, 3, 4], [2, 2, 1]).print();

Parameters:

    values (TypedArray|Array) The values of the tensor. Can be nested array of numbers, or a flat array, or a TypedArray.
    shape ([number, number, number]) The shape of the tensor. If not provided, it is inferred from values. Optional
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data type. Optional

Returns: tf.Tensor3D
tf.tensor4d (values, shape?, dtype?) function Source

Creates rank-4 tf.Tensor with the provided values, shape and dtype.

The same functionality can be achieved with tf.tensor(), but in general we recommend using tf.tensor4d() as it makes the code more readable.

// Pass a nested array.
tf.tensor4d([[[[1], [2]], [[3], [4]]]]).print();

// Pass a flat array and specify a shape.
tf.tensor4d([1, 2, 3, 4], [1, 2, 2, 1]).print();

Parameters:

    values (TypedArray|Array) The values of the tensor. Can be nested array of numbers, or a flat array, or a TypedArray.
    shape ([number, number, number, number]) The shape of the tensor. Optional. If not provided, it is inferred from values. Optional
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data type. Optional

Returns: tf.Tensor4D
tf.tensor5d (values, shape?, dtype?) function Source

Creates rank-5 tf.Tensor with the provided values, shape and dtype.

The same functionality can be achieved with tf.tensor(), but in general we recommend using tf.tensor5d() as it makes the code more readable.

// Pass a nested array.
tf.tensor5d([[[[[1],[2]],[[3],[4]]],[[[5],[6]],[[7],[8]]]]]).print();

// Pass a flat array and specify a shape.
tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]).print();

Parameters:

    values (TypedArray|Array) The values of the tensor. Can be nested array of numbers, or a flat array, or a TypedArray.
    shape ([number, number, number, number, number]) The shape of the tensor. Optional. If not provided, it is inferred from values. Optional
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data type. Optional

Returns: tf.Tensor5D
tf.tensor6d (values, shape?, dtype?) function Source

Creates rank-6 tf.Tensor with the provided values, shape and dtype.

The same functionality can be achieved with tf.tensor(), but in general we recommend using tf.tensor6d() as it makes the code more readable.

// Pass a nested array.
tf.tensor6d([[[[[[1],[2]],[[3],[4]]],[[[5],[6]],[[7],[8]]]]]]).print();

// Pass a flat array and specify a shape.
tf.tensor6d([1, 2, 3, 4, 5, 6, 7, 8], [1, 1, 2, 2, 2, 1]).print();

Parameters:

    values (TypedArray|Array) The values of the tensor. Can be nested array of numbers, or a flat array, or a TypedArray.
    shape ([number, number, number, number, number, number]) The shape of the tensor. Optional. If not provided, it is inferred from values. Optional
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data type. Optional

Returns: tf.Tensor6D
tf.buffer (shape, dtype?, values?) function Source

Creates an empty tf.TensorBuffer with the specified shape and dtype.

The values are stored in CPU as TypedArray. Fill the buffer using buffer.set(), or by modifying directly buffer.values.

When done, call buffer.toTensor() to get an immutable tf.Tensor with those values.

// Create a buffer and set values at particular indices.
const buffer = tf.buffer([2, 2]);
buffer.set(3, 0, 0);
buffer.set(5, 1, 0);

// Convert the buffer back to a tensor.
buffer.toTensor().print();

Parameters:

    shape (number[]) An array of integers defining the output tensor shape.
    dtype ('float32') The dtype of the buffer. Defaults to 'float32'. Optional
    values (DataTypeMap['float32']) The values of the buffer as TypedArray. Defaults to zeros. Optional

Returns: tf.TensorBuffer
tf.clone (x) function Source

Creates a new tensor with the same values and shape as the specified tensor.

const x = tf.tensor([1, 2]);

x.clone().print();

Parameters:

    x (tf.Tensor|TypedArray|Array) The tensor to clone.

Returns: tf.Tensor
tf.complex (real, imag) function Source

Converts two real numbers to a complex number.

Given a tensor real representing the real part of a complex number, and a tensor imag representing the imaginary part of a complex number, this operation returns complex numbers elementwise of the form [r0, i0, r1, i1], where r represents the real part and i represents the imag part.

The input tensors real and imag must have the same shape.

const real = tf.tensor1d([2.25, 3.25]);
const imag = tf.tensor1d([4.75, 5.75]);
const complex = tf.complex(real, imag);

complex.print();

Parameters:

    real (tf.Tensor|TypedArray|Array)
    imag (tf.Tensor|TypedArray|Array)

Returns: tf.Tensor
tf.diag (x) function Source

Returns a diagonal tensor with given diagonal values.

Given a diagonal, this operation returns a tensor with the diagonal and everything else padded with zeros.

Assume the input has dimensions [D1,..., Dk], then the output is a tensor of rank 2k with dimensions [D1,..., Dk, D1,..., Dk]

const x = tf.tensor1d([1, 2, 3, 4]);

tf.diag(x).print()

const x = tf.tensor2d([1, 2, 3, 4, 5, 6, 7, 8], [4, 2])

tf.diag(x).print()

Parameters:

    x (tf.Tensor) The input tensor.

Returns: tf.Tensor
tf.eye (numRows, numColumns?, batchShape?, dtype?) function Source

Create an identity matrix.
Parameters:

    numRows (number) Number of rows.
    numColumns (number) Number of columns. Defaults to numRows. Optional
    batchShape ([ number ]|[number, number]|[number, number, number]|[number, number, number, number]) If provided, will add the batch shape to the beginning of the shape of the returned tf.Tensor by repeating the identity matrix. Optional
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') Data type. Optional

Returns: tf.Tensor2D
tf.fill (shape, value, dtype?) function Source

Creates a tf.Tensor filled with a scalar value.

tf.fill([2, 2], 4).print();

Parameters:

    shape (number[]) An array of integers defining the output tensor shape.
    value (number|string) The scalar value to fill the tensor with.
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The type of an element in the resulting tensor. Defaults to 'float32' if the given param value is a number, otherwise 'string'. Optional

Returns: tf.Tensor
tf.imag (input) function Source

Returns the imaginary part of a complex (or real) tensor.

Given a tensor input, this operation returns a tensor of type float that is the imaginary part of each element in input considered as a complex number. If input is real, a tensor of all zeros is returned.

const x = tf.complex([-2.25, 3.25], [4.75, 5.75]);
tf.imag(x).print();

Parameters:

    input (tf.Tensor|TypedArray|Array)

Returns: tf.Tensor
tf.linspace (start, stop, num) function Source

Return an evenly spaced sequence of numbers over the given interval.

tf.linspace(0, 9, 10).print();

Parameters:

    start (number) The start value of the sequence.
    stop (number) The end value of the sequence.
    num (number) The number of values to generate.

Returns: tf.Tensor1D
tf.oneHot (indices, depth, onValue?, offValue?, dtype?) function Source

Creates a one-hot tf.Tensor. The locations represented by indices take value onValue (defaults to 1), while all other locations take value offValue (defaults to 0). If indices is rank R, the output has rank R+1 with the last axis of size depth. indices used to encode prediction class must start from 0. For example, if you have 3 classes of data, class 1 should be encoded as 0, class 2 should be 1, and class 3 should be 2.

tf.oneHot(tf.tensor1d([0, 1], 'int32'), 3).print();

Parameters:

    indices (tf.Tensor|TypedArray|Array) tf.Tensor of indices with dtype int32. Indices must start from 0.
    depth (number) The depth of the one hot dimension.
    onValue (number) A number used to fill in the output when the index matches the location. Optional
    offValue (number) A number used to fill in the output when the index does not match the location. Optional
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The dtype of the output tensor, default to 'int32'. Optional

Returns: tf.Tensor
tf.ones (shape, dtype?) function Source

Creates a tf.Tensor with all elements set to 1.

tf.ones([2, 2]).print();

Parameters:

    shape (number[]) An array of integers defining the output tensor shape.
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The type of an element in the resulting tensor. Defaults to 'float'. Optional

Returns: tf.Tensor
tf.onesLike (x) function Source

Creates a tf.Tensor with all elements set to 1 with the same shape as the given tensor.

const x = tf.tensor([1, 2]);
tf.onesLike(x).print();

Parameters:

    x (tf.Tensor|TypedArray|Array) A tensor.

Returns: tf.Tensor
tf.print (x, verbose?) function Source

Prints information about the tf.Tensor including its data.

const verbose = true;
tf.tensor2d([1, 2, 3, 4], [2, 2]).print(verbose);

Parameters:

    x (tf.Tensor) The tensor to be printed.
    verbose (boolean) Whether to print verbose information about the Tensor, including dtype and size. Optional

Returns: void
tf.range (start, stop, step?, dtype?) function Source

Creates a new tf.Tensor1D filled with the numbers in the range provided.

The tensor is a half-open interval meaning it includes start, but excludes stop. Decrementing ranges and negative step values are also supported.

tf.range(0, 9, 2).print();

Parameters:

    start (number) An integer start value
    stop (number) An integer stop value
    step (number) An integer increment (will default to 1 or -1) Optional
    dtype ('float32'|'int32') The data type of the output tensor. Defaults to 'float32'. Optional

Returns: tf.Tensor1D
tf.real (input) function Source

Returns the real part of a complex (or real) tensor.

Given a tensor input, this operation returns a tensor of type float that is the real part of each element in input considered as a complex number.

If the input is real, it simply makes a clone.

const x = tf.complex([-2.25, 3.25], [4.75, 5.75]);
tf.real(x).print();

Parameters:

    input (tf.Tensor|TypedArray|Array)

Returns: tf.Tensor
tf.truncatedNormal (shape, mean?, stdDev?, dtype?, seed?) function Source

Creates a tf.Tensor with values sampled from a truncated normal distribution.

tf.truncatedNormal([2, 2]).print();

The generated values follow a normal distribution with specified mean and standard deviation, except that values whose magnitude is more than 2 standard deviations from the mean are dropped and re-picked.
Parameters:

    shape (number[]) An array of integers defining the output tensor shape.
    mean (number) The mean of the normal distribution. Optional
    stdDev (number) The standard deviation of the normal distribution. Optional
    dtype ('float32'|'int32') The data type of the output tensor. Optional
    seed (number) The seed for the random number generator. Optional

Returns: tf.Tensor
tf.variable (initialValue, trainable?, name?, dtype?) function Source

Creates a new variable with the provided initial value.

const x = tf.variable(tf.tensor([1, 2, 3]));
x.assign(tf.tensor([4, 5, 6]));

x.print();

Parameters:

    initialValue (tf.Tensor) Initial value for the tensor.
    trainable (boolean) If true, optimizers are allowed to update it. Optional
    name (string) Name of the variable. Defaults to a unique id. Optional
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') If set, initialValue will be converted to the given type. Optional

Returns: tf.Variable
tf.zeros (shape, dtype?) function Source

Creates a tf.Tensor with all elements set to 0.

tf.zeros([2, 2]).print();

Parameters:

    shape (number[]) An array of integers defining the output tensor shape.
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The type of an element in the resulting tensor. Can be 'float32', 'int32' or 'bool'. Defaults to 'float'. Optional

Returns: tf.Tensor
tf.zerosLike (x) function Source

Creates a tf.Tensor with all elements set to 0 with the same shape as the given tensor.

const x = tf.tensor([1, 2]);
tf.zerosLike(x).print();

Parameters:

    x (tf.Tensor|TypedArray|Array) The tensor of required shape.

Returns: tf.Tensor
Tensors / Classes

This section shows the main Tensor related classes in TensorFlow.js and the methods we expose on them.
tf.Tensor extends TensorInfo class Source

A tf.Tensor object represents an immutable, multidimensional array of numbers that has a shape and a data type.

For performance reasons, functions that create tensors do not necessarily perform a copy of the data passed to them (e.g. if the data is passed as a Float32Array), and changes to the data will change the tensor. This is not a feature and is not supported. To avoid this behavior, use the tensor before changing the input data or create a copy with copy = tf.add(yourTensor, 0).

See tf.tensor() for details on how to create a tf.Tensor.
buffer () method Source

Returns a promise of tf.TensorBuffer that holds the underlying data.
Returns: Promise<tf.TensorBuffer>
bufferSync () method Source

Returns a tf.TensorBuffer that holds the underlying data.
Returns: tf.TensorBuffer
array () method Source

Returns the tensor data as a nested array. The transfer of data is done asynchronously.
Returns: Promise<number[]>
arraySync () method Source

Returns the tensor data as a nested array. The transfer of data is done synchronously.
Returns: number[]
data () method Source

Asynchronously downloads the values from the tf.Tensor. Returns a promise of TypedArray that resolves when the computation has finished.
Returns: Promise<DataTypeMap[NumericDataType]>
dataToGPU (options?) method Source

Copy the tensor's data to a new GPU resource. Comparing to the dataSync() and data(), this method prevents data from being downloaded to CPU.

For WebGL backend, the data will be stored on a densely packed texture. This means that the texture will use the RGBA channels to store value.

For WebGPU backend, the data will be stored on a buffer. There is no parameter, so can not use a user-defined size to create the buffer.
Parameters:

    options (DataToGPUOptions) : For WebGL,

        customTexShape: Optional. If set, will use the user defined texture shape to create the texture.
    Optional

Returns: GPUData
dataSync () method Source

Synchronously downloads the values from the tf.Tensor. This blocks the UI thread until the values are ready, which can cause performance issues.
Returns: DataTypeMap[NumericDataType]
dispose () method Source

Disposes tf.Tensor from memory.
Returns: void
print (verbose?) method Source

Prints the tf.Tensor. See tf.print() for details.
Parameters:

    verbose (boolean) Whether to print verbose information about the tensor, including dtype and size. Optional

Returns: void
clone () method Source

Returns a copy of the tensor. See tf.clone() for details.
Returns: tf.Tensor
toString (verbose?) method Source

Returns a human-readable description of the tensor. Useful for logging.
Parameters:

    verbose (boolean) Optional

Returns: string
tf.Variable extends tf.Tensor class Source

A mutable tf.Tensor, useful for persisting state, e.g. for training.
assign (newValue) method Source

Assign a new tf.Tensor to this variable. The new tf.Tensor must have the same shape and dtype as the old tf.Tensor.
Parameters:

    newValue (tf.Tensor) New tensor to be assigned to this variable.

Returns: void
tf.TensorBuffer class Source

A mutable object, similar to tf.Tensor, that allows users to set values at locations before converting to an immutable tf.Tensor.

See tf.buffer() for creating a tensor buffer.
set (value, ...locs) method Source

Sets a value in the buffer at a given location.
Parameters:

    value (SingleValueMap[D]) The value to set.
    ...locs (number[]) The location indices.

Returns: void
get (...locs) method Source

Returns the value in the buffer at the provided location.
Parameters:

    ...locs (number[]) The location indices.

Returns: SingleValueMap[D]
toTensor () method Source

Creates an immutable tf.Tensor object from the buffer.
Returns: tf.Tensor
Tensors / Transformations

This section describes some common Tensor transformations for reshaping and type-casting.
tf.batchToSpaceND (x, blockShape, crops) function Source

This operation reshapes the "batch" dimension 0 into M + 1 dimensions of shape blockShape + [batch], interleaves these blocks back into the grid defined by the spatial dimensions [1, ..., M], to obtain a result with the same rank as the input. The spatial dimensions of this intermediate result are then optionally cropped according to crops to produce the output. This is the reverse of tf.spaceToBatchND(). See below for a precise description.

const x = tf.tensor4d([1, 2, 3, 4], [4, 1, 1, 1]);
const blockShape = [2, 2];
const crops = [[0, 0], [0, 0]];

x.batchToSpaceND(blockShape, crops).print();

Parameters:

    x (tf.Tensor|TypedArray|Array) A tf.Tensor. N-D with x.shape = [batch] + spatialShape + remainingShape, where spatialShape has M dimensions.
    blockShape (number[]) A 1-D array. Must have shape [M], all values must be >= 1.
    crops (number[][]) A 2-D array. Must have shape [M, 2], all values must be >= 0. crops[i] = [cropStart, cropEnd] specifies the amount to crop from input dimension i + 1, which corresponds to spatial dimension i. It is required that cropStart[i] + cropEnd[i] <= blockShape[i] * inputShape[i + 1]

    This operation is equivalent to the following steps:

        Reshape x to reshaped of shape: [blockShape[0], ..., blockShape[M-1], batch / prod(blockShape), x.shape[1], ..., x.shape[N-1]]

        Permute dimensions of reshaped to produce permuted of shape [batch / prod(blockShape),x.shape[1], blockShape[0], ..., x.shape[M], blockShape[M-1],x.shape[M+1], ..., x.shape[N-1]]

        Reshape permuted to produce reshapedPermuted of shape [batch / prod(blockShape),x.shape[1] * blockShape[0], ..., x.shape[M] * blockShape[M-1],x.shape[M+1], ..., x.shape[N-1]]

        Crop the start and end of dimensions [1, ..., M] of reshapedPermuted according to crops to produce the output of shape: [batch / prod(blockShape),x.shape[1] * blockShape[0] - crops[0,0] - crops[0,1], ..., x.shape[M] * blockShape[M-1] - crops[M-1,0] - crops[M-1,1],x.shape[M+1], ..., x.shape[N-1]]

Returns: tf.Tensor
tf.broadcastArgs (s0, s1) function Source

Return the shape of s0 op s1 with broadcast.

compute r0, the broadcasted shape as a tensor. s0, s1 and r0 are all integer vectors.

This function returns the shape of the result of an operation between two tensors of size s0 and s1 performed with broadcast.
Parameters:

    s0 (tf.Tensor | TypedArray|Array) A tensor representing a shape
    s1 (tf.Tensor | TypedArray|Array) A tensor representing a shape

Returns: tf.Tensor
tf.broadcastTo (x, shape) function Source

Broadcast an array to a compatible shape NumPy-style.

The tensor's shape is compared to the broadcast shape from end to beginning. Ones are prepended to the tensor's shape until it has the same length as the broadcast shape. If input.shape[i]==shape[i], the (i+1)-th axis is already broadcast-compatible. If input.shape[i]==1 and shape[i]==N, then the input tensor is tiled N times along that axis (using tf.tile).
Parameters:

    x (tf.Tensor|TypedArray|Array)
    shape (number[]) The input is to be broadcast to this shape.

Returns: tf.Tensor
tf.cast (x, dtype) function Source

Casts a tf.Tensor to a new dtype.

const x = tf.tensor1d([1.5, 2.5, 3]);
tf.cast(x, 'int32').print();

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor to be casted.
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The dtype to cast the input tensor to.

Returns: tf.Tensor
tf.depthToSpace (x, blockSize, dataFormat?) function Source

Rearranges data from depth into blocks of spatial data. More specifically, this op outputs a copy of the input tensor where values from the depth dimension are moved in spatial blocks to the height and width dimensions. The attr blockSize indicates the input block size and how the data is moved.

    Chunks of data of size blockSize * blockSize from depth are rearranged into non-overlapping blocks of size blockSize x blockSize

    The width the output tensor is inputWidth * blockSize, whereas the height is inputHeight * blockSize

    The Y, X coordinates within each block of the output image are determined by the high order component of the input channel index

    The depth of the input tensor must be divisible by blockSize * blockSize

The dataFormat attr specifies the layout of the input and output tensors with the following options: "NHWC": [ batch, height, width, channels ] "NCHW": [ batch, channels, height, width ]

const x = tf.tensor4d([1, 2, 3, 4], [1, 1, 1, 4]);
const blockSize = 2;
const dataFormat = "NHWC";

tf.depthToSpace(x, blockSize, dataFormat).print();

Parameters:

    x (tf.Tensor4D|TypedArray|Array) The input tensor of rank 4
    blockSize (number)
    dataFormat ('NHWC'|'NCHW') An optional string from: "NHWC", "NCHW". Defaults to "NHWC" Optional

Returns: tf.Tensor4D
tf.ensureShape (x, shape) function Source

Checks the input tensor mathes the given shape.

Given an input tensor, returns a new tensor with the same values as the input tensor with shape shape.

The method supports the null value in tensor. It will still check the shapes, and null is a placeholder.

const x = tf.tensor1d([1, 2, 3, 4]);
const y = tf.tensor1d([1, null, 3, 4]);
const z = tf.tensor2d([1, 2, 3, 4], [2,2]);
tf.ensureShape(x, [4]).print();
tf.ensureShape(y, [4]).print();
tf.ensureShape(z, [null, 2]).print();

Parameters:

    x (tf.Tensor) The input tensor to be ensured.
    shape (number[]) A TensorShape representing the shape of this tensor, an array or null.

Returns: tf.Tensor
tf.expandDims (x, axis?) function Source

Returns a tf.Tensor that has expanded rank, by inserting a dimension into the tensor's shape.

const x = tf.tensor1d([1, 2, 3, 4]);
const axis = 1;
x.expandDims(axis).print();

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor whose dimensions are to be expanded.
    axis (number) The dimension index at which to insert shape of 1. Defaults to 0 (the first dimension). Optional

Returns: tf.Tensor
tf.mirrorPad (x, paddings, mode) function Source

Pads a tf.Tensor using mirror padding.

This operation implements the REFLECT and SYMMETRIC modes of pad.

const x = tf.range(0, 9).reshape([1, 1, 3, 3]);
x.mirrorPad([[0, 0], [0, 0], [2, 2], [2, 2]], 'reflect').print();

Parameters:

    x (tf.Tensor|TypedArray|Array) The tensor to pad.
    paddings (Array) An array of length R (the rank of the tensor), where each element is a length-2 tuple of ints [padBefore, padAfter], specifying how much to pad along each dimension of the tensor. In "reflect" mode, the padded regions do not include the borders, while in "symmetric" mode the padded regions do include the borders. For example, if the input is [1, 2, 3] and paddings is [0, 2], then the output is [1, 2, 3, 2, 1] in "reflect" mode, and [1, 2, 3, 3, 2] in "symmetric" mode. If mode is "reflect" then both paddings[D, 0] and paddings[D, 1] must be no greater than x.shape[D] - 1. If mode is "symmetric" then both paddings[D, 0] and paddings[D, 1] must be no greater than x.shape[D]
    mode ('reflect'|'symmetric') String to specify padding mode. Can be 'reflect' | 'symmetric'

Returns: tf.Tensor
tf.pad (x, paddings, constantValue?) function Source

Pads a tf.Tensor with a given value and paddings.

This operation implements CONSTANT mode. For REFLECT and SYMMETRIC, refer to tf.mirrorPad().

Also available are stricter rank-specific methods with the same signature as this method that assert that paddings is of given length.

    tf.pad1d
    tf.pad2d
    tf.pad3d
    tf.pad4d

const x = tf.tensor1d([1, 2, 3, 4]);
x.pad([[1, 2]]).print();

Parameters:

    x (tf.Tensor|TypedArray|Array) The tensor to pad.
    paddings (Array) An array of length R (the rank of the tensor), where each element is a length-2 tuple of ints [padBefore, padAfter], specifying how much to pad along each dimension of the tensor.
    constantValue (number) The pad value to use. Defaults to 0. Optional

Returns: tf.Tensor
tf.reshape (x, shape) function Source

Reshapes a tf.Tensor to a given shape.

Given an input tensor, returns a new tensor with the same values as the input tensor with shape shape.

If one component of shape is the special value -1, the size of that dimension is computed so that the total size remains constant. In particular, a shape of [-1] flattens into 1-D. At most one component of shape can be -1.

If shape is 1-D or higher, then the operation returns a tensor with shape shape filled with the values of tensor. In this case, the number of elements implied by shape must be the same as the number of elements in tensor.

const x = tf.tensor1d([1, 2, 3, 4]);
x.reshape([2, 2]).print();

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor to be reshaped.
    shape (number[]) An array of integers defining the output tensor shape.

Returns: tf.Tensor
tf.setdiff1dAsync (x, y) function Source

Computes the difference between two lists of numbers.

Given a Tensor x and a Tensor y, this operation returns a Tensor out that represents all values that are in x but not in y. The returned Tensor out is sorted in the same order that the numbers appear in x (duplicates are preserved). This operation also returns a Tensor indices that represents the position of each out element in x. In other words:

out[i] = x[idx[i]] for i in [0, 1, ..., out.length - 1]

const x = [1, 2, 3, 4, 5, 6];
const y = [1, 3, 5];

const [out, indices] = await tf.setdiff1dAsync(x, y);
out.print(); // [2, 4, 6]
indices.print(); // [1, 3, 5]

Parameters:

    x (tf.Tensor|TypedArray|Array) 1-D Tensor. Values to keep.
    y (tf.Tensor|TypedArray|Array) 1-D Tensor. Must have the same type as x. Values to exclude in the output.

Returns: Promise<[tf.Tensor, tf.Tensor]>
tf.spaceToBatchND (x, blockShape, paddings) function Source

This operation divides "spatial" dimensions [1, ..., M] of the input into a grid of blocks of shape blockShape, and interleaves these blocks with the "batch" dimension (0) such that in the output, the spatial dimensions [1, ..., M] correspond to the position within the grid, and the batch dimension combines both the position within a spatial block and the original batch position. Prior to division into blocks, the spatial dimensions of the input are optionally zero padded according to paddings. See below for a precise description.

const x = tf.tensor4d([1, 2, 3, 4], [1, 2, 2, 1]);
const blockShape = [2, 2];
const paddings = [[0, 0], [0, 0]];

x.spaceToBatchND(blockShape, paddings).print();

Parameters:

    x (tf.Tensor|TypedArray|Array) A tf.Tensor. N-D with x.shape = [batch] + spatialShape + remainingShape, where spatialShape has M dimensions.
    blockShape (number[]) A 1-D array. Must have shape [M], all values must be >= 1.
    paddings (number[][]) A 2-D array. Must have shape [M, 2], all values must be >= 0. paddings[i] = [padStart, padEnd] specifies the amount to zero-pad from input dimension i + 1, which corresponds to spatial dimension i. It is required that (inputShape[i + 1] + padStart + padEnd) % blockShape[i] === 0

    This operation is equivalent to the following steps:

        Zero-pad the start and end of dimensions [1, ..., M] of the input according to paddings to produce padded of shape paddedShape.

        Reshape padded to reshapedPadded of shape: [batch] + [paddedShape[1] / blockShape[0], blockShape[0], ..., paddedShape[M] / blockShape[M-1], blockShape[M-1]] + remainingShape

        Permute dimensions of reshapedPadded to produce permutedReshapedPadded of shape: blockShape + [batch] + [paddedShape[1] / blockShape[0], ..., paddedShape[M] / blockShape[M-1]] + remainingShape

        Reshape permutedReshapedPadded to flatten blockShape into the batch dimension, producing an output tensor of shape: [batch * prod(blockShape)] + [paddedShape[1] / blockShape[0], ..., paddedShape[M] / blockShape[M-1]] + remainingShape

Returns: tf.Tensor
tf.squeeze (x, axis?) function Source

Removes dimensions of size 1 from the shape of a tf.Tensor.

const x = tf.tensor([1, 2, 3, 4], [1, 1, 4]);
x.squeeze().print();

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor to be squeezed.
    axis (number[]) An optional list of numbers. If specified, only squeezes the dimensions listed. The dimension index starts at 0. It is an error to squeeze a dimension that is not 1. Optional

Returns: tf.Tensor
Tensors / Slicing and Joining

TensorFlow.js provides several operations to slice or extract parts of a tensor, or join multiple tensors together.
tf.booleanMaskAsync (tensor, mask, axis?) function Source

Apply boolean mask to tensor.

const tensor = tf.tensor2d([1, 2, 3, 4, 5, 6], [3, 2]);
const mask = tf.tensor1d([1, 0, 1], 'bool');
const result = await tf.booleanMaskAsync(tensor, mask);
result.print();

Parameters:

    tensor (tf.Tensor|TypedArray|Array) N-D tensor.
    mask (tf.Tensor|TypedArray|Array) K-D boolean tensor, K <= N and K must be known statically.
    axis (number) A 0-D int Tensor representing the axis in tensor to mask from. By default, axis is 0 which will mask from the first dimension. Otherwise K + axis <= N. Optional

Returns: Promise<tf.Tensor>
tf.concat (tensors, axis?) function Source

Concatenates a list of tf.Tensors along a given axis.

The tensors ranks and types must match, and their sizes must match in all dimensions except axis.

Also available are stricter rank-specific methods that assert that tensors are of the given rank:

    tf.concat1d
    tf.concat2d
    tf.concat3d
    tf.concat4d

Except tf.concat1d (which does not have axis param), all methods have same signature as this method.

const a = tf.tensor1d([1, 2]);
const b = tf.tensor1d([3, 4]);
a.concat(b).print();  // or a.concat(b)

const a = tf.tensor1d([1, 2]);
const b = tf.tensor1d([3, 4]);
const c = tf.tensor1d([5, 6]);
tf.concat([a, b, c]).print();

const a = tf.tensor2d([[1, 2], [10, 20]]);
const b = tf.tensor2d([[3, 4], [30, 40]]);
const axis = 1;
tf.concat([a, b], axis).print();

Parameters:

    tensors (Array) A list of tensors to concatenate.
    axis (number) The axis to concatenate along. Defaults to 0 (the first dim). Optional

Returns: tf.Tensor
tf.gather (x, indices, axis?, batchDims?) function Source

Gather slices from tensor x's axis axis according to indices.

const x = tf.tensor1d([1, 2, 3, 4]);
const indices = tf.tensor1d([1, 3, 3], 'int32');

x.gather(indices).print();

const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
const indices = tf.tensor1d([1, 1, 0], 'int32');

x.gather(indices).print();

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor whose slices are to be gathered.
    indices (tf.Tensor|TypedArray|Array) The indices of the values to extract.
    axis (number) The axis over which to select values. Defaults to 0. Optional
    batchDims (number) Optional. The number of batch dimensions. It must be less than or equal to rank(indices). Defaults to 0. The output tensor will have shape of x.shape[:axis] + indices.shape[batchDims:] + x.shape[axis + 1:] Optional

Returns: tf.Tensor
tf.reverse (x, axis?) function Source

Reverses a tf.Tensor along a specified axis.

Also available are stricter rank-specific methods that assert that x is of the given rank:

    tf.reverse1d
    tf.reverse2d
    tf.reverse3d
    tf.reverse4d

Except tf.reverse1d (which does not have axis param), all methods have same signature as this method.

const x = tf.tensor1d([1, 2, 3, 4]);

x.reverse().print();

const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);

const axis = 1;
x.reverse(axis).print();

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor to be reversed.
    axis (number|number[]) The set of dimensions to reverse. Must be in the range [-rank(x), rank(x)). Defaults to all axes. Optional

Returns: tf.Tensor
tf.slice (x, begin, size?) function Source

Extracts a slice from a tf.Tensor starting at coordinates begin and is of size size.

Also available are stricter rank-specific methods with the same signature as this method that assert that x is of the given rank:

    tf.slice1d
    tf.slice2d
    tf.slice3d
    tf.slice4d

const x = tf.tensor1d([1, 2, 3, 4]);

x.slice([1], [2]).print();

const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);

x.slice([1, 0], [1, 2]).print();

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tf.Tensor to slice from.
    begin (number|number[]) The coordinates to start the slice from. The length can be less than the rank of x - the rest of the axes will have implicit 0 as start. Can also be a single number, in which case it specifies the first axis.
    size (number|number[]) The size of the slice. The length can be less than the rank of x - the rest of the axes will have implicit -1. A value of -1 requests the rest of the dimensions in the axis. Can also be a single number, in which case it specifies the size of the first axis. Optional

Returns: tf.Tensor
tf.split (x, numOrSizeSplits, axis?) function Source

Splits a tf.Tensor into sub tensors.

If numOrSizeSplits is a number, splits x along dimension axis into numOrSizeSplits smaller tensors. Requires that numOrSizeSplits evenly divides x.shape[axis].

If numOrSizeSplits is a number array, splits x into numOrSizeSplits.length pieces. The shape of the i-th piece has the same size as x except along dimension axis where the size is numOrSizeSplits[i].

const x = tf.tensor2d([1, 2, 3, 4, 5, 6, 7, 8], [2, 4]);
const [a, b] = tf.split(x, 2, 1);
a.print();
b.print();

const [c, d, e] = tf.split(x, [1, 2, 1], 1);
c.print();
d.print();
e.print();

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor to split.
    numOrSizeSplits (number[]|number) Either an integer indicating the number of splits along the axis or an array of integers containing the sizes of each output tensor along the axis. If a number then it must evenly divide x.shape[axis]; otherwise the sum of sizes must match x.shape[axis]. Can contain one -1 indicating that dimension is to be inferred.
    axis (number) The dimension along which to split. Defaults to 0 (the first dim). Optional

Returns: tf.Tensor[]
tf.stack (tensors, axis?) function Source

Stacks a list of rank-R tf.Tensors into one rank-(R+1) tf.Tensor.

const a = tf.tensor1d([1, 2]);
const b = tf.tensor1d([3, 4]);
const c = tf.tensor1d([5, 6]);
tf.stack([a, b, c]).print();

Parameters:

    tensors (Array) A list of tensor objects with the same shape and dtype.
    axis (number) The axis to stack along. Defaults to 0 (the first dim). Optional

Returns: tf.Tensor
tf.tile (x, reps) function Source

Construct a tensor by repeating it the number of times given by reps.

This operation creates a new tensor by replicating input reps times. The output tensor's ith dimension has input.shape[i] * reps[i] elements, and the values of input are replicated reps[i] times along the ith dimension. For example, tiling [a, b, c, d] by [2] produces [a, b, c, d, a, b, c, d].

const a = tf.tensor1d([1, 2]);

a.tile([2]).print();    // or tf.tile(a, [2])

const a = tf.tensor2d([1, 2, 3, 4], [2, 2]);

a.tile([1, 2]).print();  // or tf.tile(a, [1,2])

Parameters:

    x (tf.Tensor|TypedArray|Array) The tensor to tile.
    reps (number[]) Determines the number of replications per dimension.

Returns: tf.Tensor
tf.unstack (x, axis?) function Source

Unstacks a tf.Tensor of rank-R into a list of rank-(R-1) tf.Tensors.

const a = tf.tensor2d([1, 2, 3, 4], [2, 2]);

tf.unstack(a).forEach(tensor => tensor.print());

Parameters:

    x (tf.Tensor|TypedArray|Array) A tensor object.
    axis (number) The axis to unstack along. Defaults to 0 (the first dim). Optional

Returns: tf.Tensor[]
Tensors / Matrices
tf.einsum (equation, ...tensors) function Source

Tensor contraction over specified indices and outer product.

einsum allows defining Tensors by defining their element-wise computation. This computation is based on Einstein summation.

Some special cases include:

Matrix multiplication:

const x = tf.tensor2d([[1, 2, 3], [4, 5, 6]]);
const y = tf.tensor2d([[0, 1], [2, 3], [4, 5]]);
x.print();
y.print();
tf.einsum('ij,jk->ik', x, y).print();

Dot product:

const x = tf.tensor1d([1, 2, 3]);
const y = tf.tensor1d([0, 1, 2]);
x.print();
y.print();
tf.einsum('i,i->', x, y).print();

Batch dot product:

const x = tf.tensor2d([[1, 2, 3], [4, 5, 6]]);
const y = tf.tensor2d([[0, 1, 2], [3, 4, 5]]);
x.print();
y.print();
tf.einsum('bi,bi->b', x, y).print();

Outer prouduct:

const x = tf.tensor1d([1, 3, 5]);
const y = tf.tensor1d([2, 4, 6]);
x.print();
y.print();
tf.einsum('i,j->ij', x, y).print();

Matrix transpose:

const x = tf.tensor2d([[1, 2], [3, 4]]);
x.print();
tf.einsum('ij->ji', x).print();

Batch matrix transpose:

const x = tf.tensor3d([[[1, 2], [3, 4]], [[-1, -2], [-3, -4]]]);
x.print();
tf.einsum('bij->bji', x).print();

Limitations:

This implementation of einsum has the following limitations:

    Does not support >2 input tensors.
    Does not support duplicate axes for any given input tensor. E.g., equation 'ii->' is not supported.
    The ... notation is not supported.

Parameters:

    equation (string) a string describing the contraction, in the same format as numpy.einsum.
    ...tensors (tf.Tensor[]) the input(s) to contract (each one a Tensor), whose shapes should be consistent with equation.

Returns: tf.Tensor
Tensors / Random
tf.multinomial (logits, numSamples, seed?, normalized?) function Source

Creates a tf.Tensor with values drawn from a multinomial distribution.

const probs = tf.tensor([.75, .25]);
tf.multinomial(probs, 3).print();

Parameters:

    logits (tf.Tensor1D|tf.Tensor2D|TypedArray|Array) 1D array with unnormalized log-probabilities, or 2D array of shape [batchSize, numOutcomes]. See the normalized parameter.
    numSamples (number) Number of samples to draw for each row slice.
    seed (number) The seed number. Optional
    normalized (boolean) Whether the provided logits are normalized true probabilities (sum to 1). Defaults to false. Optional

Returns: tf.Tensor1D|tf.Tensor2D
tf.rand (shape, randFunction, dtype?) function Source

Creates a tf.Tensor with values sampled from a random number generator function defined by the user.
Parameters:

    shape (number[]) An array of integers defining the output tensor shape.
    randFunction (() => number) A random number generator function which is called for each element in the output tensor.
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data type of the output tensor. Defaults to 'float32'. Optional

Returns: tf.Tensor
tf.randomGamma (shape, alpha, beta?, dtype?, seed?) function Source

Creates a tf.Tensor with values sampled from a gamma distribution.

tf.randomGamma([2, 2], 1).print();

Parameters:

    shape (number[]) An array of integers defining the output tensor shape.
    alpha (number) The shape parameter of the gamma distribution.
    beta (number) The inverse scale parameter of the gamma distribution. Defaults to 1. Optional
    dtype ('float32'|'int32') The data type of the output. Defaults to float32. Optional
    seed (number) The seed for the random number generator. Optional

Returns: tf.Tensor
tf.randomNormal (shape, mean?, stdDev?, dtype?, seed?) function Source

Creates a tf.Tensor with values sampled from a normal distribution.

tf.randomNormal([2, 2]).print();

Parameters:

    shape (number[]) An array of integers defining the output tensor shape.
    mean (number) The mean of the normal distribution. Optional
    stdDev (number) The standard deviation of the normal distribution. Optional
    dtype ('float32'|'int32') The data type of the output. Optional
    seed (number) The seed for the random number generator. Optional

Returns: tf.Tensor
tf.randomStandardNormal (shape, dtype?, seed?) function Source

Creates a tf.Tensor with values sampled from a normal distribution.

The generated values will have mean 0 and standard deviation 1.

tf.randomStandardNormal([2, 2]).print();

Parameters:

    shape (number[]) An array of integers defining the output tensor shape.
    dtype ('float32'|'int32') The data type of the output. Optional
    seed (number) The seed for the random number generator. Optional

Returns: tf.Tensor
tf.randomUniform (shape, minval?, maxval?, dtype?, seed?) function Source

Creates a tf.Tensor with values sampled from a uniform distribution.

The generated values follow a uniform distribution in the range [minval, maxval). The lower bound minval is included in the range, while the upper bound maxval is excluded.

tf.randomUniform([2, 2]).print();

Parameters:

    shape (number[]) An array of integers defining the output tensor shape.
    minval (number) The lower bound on the range of random values to generate. Defaults to 0. Optional
    maxval (number) The upper bound on the range of random values to generate. Defaults to 1. Optional
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data type of the output tensor. Defaults to 'float32'. Optional
    seed (number|string) An optional int. Defaults to 0. If seed is set to be non-zero, the random number generator is seeded by the given seed. Otherwise, it is seeded by a random seed. Optional

Returns: tf.Tensor
tf.randomUniformInt (shape, minval, maxval, seed?) function Source

Creates a tf.Tensor with integers sampled from a uniform distribution.

The generated values are uniform integers in the range [minval, maxval). The lower bound minval is included in the range, while the upper bound maxval is excluded.

tf.randomUniformInt([2, 2], 0, 10).print();

Parameters:

    shape (number[]) An array of integers defining the output tensor shape.
    minval (number) Inclusive lower bound on the generated integers.
    maxval (number) Exclusive upper bound on the generated integers.
    seed (number|string) An optional int. Defaults to 0. If seed is set to be non-zero, the random number generator is seeded by the given seed. Otherwise, it is seeded by a random seed. Optional

Returns: tf.Tensor
Models

Models are one of the primary abstractions used in TensorFlow.js Layers. Models can be trained, evaluated, and used for prediction. A model's state (topology, and optionally, trained weights) can be restored from various formats.

Models are a collection of Layers, see Model Creation for details about how Layers can be connected.
Models / Creation

There are two primary ways of creating models.

    Sequential — Easiest, works if the models is a simple stack of each layer's input resting on the top of the previous layer's output.
    Model — Offers more control if the layers need to be wired together in graph-like ways — multiple 'towers', layers that skip a layer, etc.

tf.sequential (config?) function Source

Creates a tf.Sequential model. A sequential model is any model where the outputs of one layer are the inputs to the next layer, i.e. the model topology is a simple 'stack' of layers, with no branching or skipping.

This means that the first layer passed to a tf.Sequential model should have a defined input shape. What that means is that it should have received an inputShape or batchInputShape argument, or for some type of layers (recurrent, Dense...) an inputDim argument.

The key difference between tf.model() and tf.sequential() is that tf.sequential() is less generic, supporting only a linear stack of layers. tf.model() is more generic and supports an arbitrary graph (without cycles) of layers.

Examples:

const model = tf.sequential();

// First layer must have an input shape defined.
model.add(tf.layers.dense({units: 32, inputShape: [50]}));
// Afterwards, TF.js does automatic shape inference.
model.add(tf.layers.dense({units: 4}));

// Inspect the inferred shape of the model's output, which equals
// `[null, 4]`. The 1st dimension is the undetermined batch dimension; the
// 2nd is the output size of the model's last layer.
console.log(JSON.stringify(model.outputs[0].shape));

It is also possible to specify a batch size (with potentially undetermined batch dimension, denoted by "null") for the first layer using the batchInputShape key. The following example is equivalent to the above:

const model = tf.sequential();

// First layer must have a defined input shape
model.add(tf.layers.dense({units: 32, batchInputShape: [null, 50]}));
// Afterwards, TF.js does automatic shape inference.
model.add(tf.layers.dense({units: 4}));

// Inspect the inferred shape of the model's output.
console.log(JSON.stringify(model.outputs[0].shape));

You can also use an Array of already-constructed Layers to create a tf.Sequential model:

const model = tf.sequential({
   layers: [tf.layers.dense({units: 32, inputShape: [50]}),
            tf.layers.dense({units: 4})]
});
console.log(JSON.stringify(model.outputs[0].shape));

Parameters:

    config (Object) Optional
    layers (tf.layers.Layer[]) Stack of layers for the model.
    name (string) The name of this model.

Returns: tf.Sequential
tf.model (args) function Source

A model is a data structure that consists of Layers and defines inputs and outputs.

The key difference between tf.model() and tf.sequential() is that tf.model() is more generic, supporting an arbitrary graph (without cycles) of layers. tf.sequential() is less generic and supports only a linear stack of layers.

When creating a tf.LayersModel, specify its input(s) and output(s). Layers are used to wire input(s) to output(s).

For example, the following code snippet defines a model consisting of two dense layers, with 10 and 4 units, respectively.

// Define input, which has a size of 5 (not including batch dimension).
const input = tf.input({shape: [5]});

// First dense layer uses relu activation.
const denseLayer1 = tf.layers.dense({units: 10, activation: 'relu'});
// Second dense layer uses softmax activation.
const denseLayer2 = tf.layers.dense({units: 4, activation: 'softmax'});

// Obtain the output symbolic tensor by applying the layers on the input.
const output = denseLayer2.apply(denseLayer1.apply(input));

// Create the model based on the inputs.
const model = tf.model({inputs: input, outputs: output});

// The model can be used for training, evaluation and prediction.
// For example, the following line runs prediction with the model on
// some fake data.
model.predict(tf.ones([2, 5])).print();

See also: tf.sequential(), tf.loadLayersModel().
Parameters:

    args (Object)
    inputs (tf.SymbolicTensor|tf.SymbolicTensor[])
    outputs (tf.SymbolicTensor|tf.SymbolicTensor[])
    name (string)

Returns: tf.LayersModel
Models / Inputs
tf.input (config) function Source

Used to instantiate an input to a model as a tf.SymbolicTensor.

Users should call the input factory function for consistency with other generator functions.

Example:

// Defines a simple logistic regression model with 32 dimensional input
// and 3 dimensional output.
const x = tf.input({shape: [32]});
const y = tf.layers.dense({units: 3, activation: 'softmax'}).apply(x);
const model = tf.model({inputs: x, outputs: y});
model.predict(tf.ones([2, 32])).print();

Note: input is only necessary when using model. When using sequential, specify inputShape for the first layer or use inputLayer as the first layer.
Parameters:

    config (Object)
    shape ((null | number)[]) A shape, not including the batch size. For instance, shape=[32] indicates that the expected input will be batches of 32-dimensional vectors.
    batchShape ((null | number)[]) A shape tuple (integer), including the batch size. For instance, batchShape=[10, 32] indicates that the expected input will be batches of 10 32-dimensional vectors. batchShape=[null, 32] indicates batches of an arbitrary number of 32-dimensional vectors.
    name (string) An optional name string for the layer. Should be unique in a model (do not reuse the same name twice). It will be autogenerated if it isn't provided.
    dtype ('float32'|'int32'|'bool'|'complex64'|'string')
    sparse (boolean) A boolean specifying whether the placeholder to be created is sparse.

Returns: tf.SymbolicTensor
Models / Loading
tf.loadGraphModel (modelUrl, options?, tfio?) function Source

Load a graph model given a URL to the model definition.

Example of loading MobileNetV2 from a URL and making a prediction with a zeros input:

const modelUrl =
    'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json';
const model = await tf.loadGraphModel(modelUrl);
const zeros = tf.zeros([1, 224, 224, 3]);
model.predict(zeros).print();

Example of loading MobileNetV2 from a TF Hub URL and making a prediction with a zeros input:

const modelUrl =
    'https://tfhub.dev/google/imagenet/mobilenet_v2_140_224/classification/2';
const model = await tf.loadGraphModel(modelUrl, {fromTFHub: true});
const zeros = tf.zeros([1, 224, 224, 3]);
model.predict(zeros).print();

Parameters:

    modelUrl (string|io.IOHandler) The url or an io.IOHandler that loads the model.
    options (Object) Options for the HTTP request, which allows to send credentials and custom headers. Optional
    requestInit (RequestInit) RequestInit (options) for HTTP requests.

    For detailed information on the supported fields, see https://developer.mozilla.org/en-US/docs/Web/API/Request/Request
    onProgress (OnProgressCallback) Progress callback.
    fetchFunc (typeof tf.fetch()) A function used to override the window.fetch function.
    strict (boolean) Strict loading model: whether extraneous weights or missing weights should trigger an Error.

    If true, require that the provided weights exactly match those required by the layers. false means that both extra weights and missing weights will be silently ignored.

    Default: true.
    weightPathPrefix (string) Path prefix for weight files, by default this is calculated from the path of the model JSON file.

    For instance, if the path to the model JSON file is http://localhost/foo/model.json, then the default path prefix will be http://localhost/foo/. If a weight file has the path value group1-shard1of2 in the weight manifest, then the weight file will be loaded from http://localhost/foo/group1-shard1of2 by default. However, if you provide a weightPathPrefix value of http://localhost/foo/alt-weights, then the weight file will be loaded from the path http://localhost/foo/alt-weights/group1-shard1of2 instead.
    fromTFHub (boolean) Whether the module or model is to be loaded from TF Hub.

    Setting this to true allows passing a TF-Hub module URL, omitting the standard model file name and the query parameters.

    Default: false.
    weightUrlConverter ((weightFileName: string) => Promise<string>) An async function to convert weight file name to URL. The weight file names are stored in model.json's weightsManifest.paths field. By default we consider weight files are colocated with the model.json file. For example: model.json URL: https://www.google.com/models/1/model.json group1-shard1of1.bin url: https://www.google.com/models/1/group1-shard1of1.bin

    With this func you can convert the weight file name to any URL.
    streamWeights (boolean) Whether to stream the model directly to the backend or cache all its weights on CPU first. Useful for large models.
    tfio (typeof import("@tensorflow/tfjs-core/dist/io/io")) Optional

Returns: Promise<tf.GraphModel>
tf.loadLayersModel (pathOrIOHandler, options?) function Source

Load a model composed of Layer objects, including its topology and optionally weights. See the Tutorial named "How to import a Keras Model" for usage examples.

This method is applicable to:

    Models created with the tf.layers.*, tf.sequential(), and tf.model() APIs of TensorFlow.js and later saved with the tf.LayersModel.save() method.
    Models converted from Keras or TensorFlow tf.keras using the tensorflowjs_converter.

This mode is not applicable to TensorFlow SavedModels or their converted forms. For those models, use tf.loadGraphModel().

Example 1. Load a model from an HTTP server.

const model = await tf.loadLayersModel(
     'https://storage.googleapis.com/tfjs-models/tfjs/iris_v1/model.json');
model.summary();

Example 2: Save model's topology and weights to browser local storage; then load it back.

const model = tf.sequential(
     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});
console.log('Prediction from original model:');
model.predict(tf.ones([1, 3])).print();

const saveResults = await model.save('localstorage://my-model-1');

const loadedModel = await tf.loadLayersModel('localstorage://my-model-1');
console.log('Prediction from loaded model:');
loadedModel.predict(tf.ones([1, 3])).print();

Example 3. Saving model's topology and weights to browser IndexedDB; then load it back.

const model = tf.sequential(
     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});
console.log('Prediction from original model:');
model.predict(tf.ones([1, 3])).print();

const saveResults = await model.save('indexeddb://my-model-1');

const loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');
console.log('Prediction from loaded model:');
loadedModel.predict(tf.ones([1, 3])).print();

Example 4. Load a model from user-selected files from HTML file input elements.

// Note: this code snippet will not work without the HTML elements in the
//   page
const jsonUpload = document.getElementById('json-upload');
const weightsUpload = document.getElementById('weights-upload');

const model = await tf.loadLayersModel(
     tf.io.browserFiles([jsonUpload.files[0], weightsUpload.files[0]]));

Parameters:

    pathOrIOHandler (string|io.IOHandler) Can be either of the two formats

        A string path to the ModelAndWeightsConfig JSON describing the model in the canonical TensorFlow.js format. For file:// (tfjs-node-only), http:// and https:// schemas, the path can be either absolute or relative. The content of the JSON file is assumed to be a JSON object with the following fields and values:
        'modelTopology': A JSON object that can be either of:
        a model architecture JSON consistent with the format of the return value of keras.Model.to_json()
        a full model JSON in the format of keras.models.save_model().
        'weightsManifest': A TensorFlow.js weights manifest. See the Python converter function save_model() for more details. It is also assumed that model weights can be accessed from relative paths described by the paths fields in weights manifest.
        A tf.io.IOHandler object that loads model artifacts with its load method.
    options (Object) Optional configuration arguments for the model loading, including:

        strict: Require that the provided weights exactly match those required by the layers. Default true. Passing false means that both extra weights and missing weights will be silently ignored.
        onProgress: A progress callback of the form: (fraction: number) => void. This callback can be used to monitor the model-loading process.
    Optional
    requestInit (RequestInit) RequestInit (options) for HTTP requests.

    For detailed information on the supported fields, see https://developer.mozilla.org/en-US/docs/Web/API/Request/Request
    onProgress (OnProgressCallback) Progress callback.
    fetchFunc (typeof tf.fetch()) A function used to override the window.fetch function.
    strict (boolean) Strict loading model: whether extraneous weights or missing weights should trigger an Error.

    If true, require that the provided weights exactly match those required by the layers. false means that both extra weights and missing weights will be silently ignored.

    Default: true.
    weightPathPrefix (string) Path prefix for weight files, by default this is calculated from the path of the model JSON file.

    For instance, if the path to the model JSON file is http://localhost/foo/model.json, then the default path prefix will be http://localhost/foo/. If a weight file has the path value group1-shard1of2 in the weight manifest, then the weight file will be loaded from http://localhost/foo/group1-shard1of2 by default. However, if you provide a weightPathPrefix value of http://localhost/foo/alt-weights, then the weight file will be loaded from the path http://localhost/foo/alt-weights/group1-shard1of2 instead.
    fromTFHub (boolean) Whether the module or model is to be loaded from TF Hub.

    Setting this to true allows passing a TF-Hub module URL, omitting the standard model file name and the query parameters.

    Default: false.
    weightUrlConverter ((weightFileName: string) => Promise<string>) An async function to convert weight file name to URL. The weight file names are stored in model.json's weightsManifest.paths field. By default we consider weight files are colocated with the model.json file. For example: model.json URL: https://www.google.com/models/1/model.json group1-shard1of1.bin url: https://www.google.com/models/1/group1-shard1of1.bin

    With this func you can convert the weight file name to any URL.
    streamWeights (boolean) Whether to stream the model directly to the backend or cache all its weights on CPU first. Useful for large models.

Returns: Promise<tf.LayersModel>
tf.io.browserDownloads (fileNamePrefix?) function Source

Creates an IOHandler that triggers file downloads from the browser.

The returned IOHandler instance can be used as model exporting methods such as tf.Model.save and supports only saving.

const model = tf.sequential();
model.add(tf.layers.dense(
     {units: 1, inputShape: [10], activation: 'sigmoid'}));
const saveResult = await model.save('downloads://mymodel');
// This will trigger downloading of two files:
//   'mymodel.json' and 'mymodel.weights.bin'.
console.log(saveResult);

Parameters:

    fileNamePrefix (string) Prefix name of the files to be downloaded. For use with tf.Model, fileNamePrefix should follow either of the following two formats:

        null or undefined, in which case the default file names will be used:
        'model.json' for the JSON file containing the model topology and weights manifest.
        'model.weights.bin' for the binary file containing the binary weight values.
        A single string or an Array of a single string, as the file name prefix. For example, if 'foo' is provided, the downloaded JSON file and binary weights file will be named 'foo.json' and 'foo.weights.bin', respectively.
    Optional

Returns: IOHandler
tf.io.browserFiles (files) function Source

Creates an IOHandler that loads model artifacts from user-selected files.

This method can be used for loading from files such as user-selected files in the browser. When used in conjunction with tf.loadLayersModel(), an instance of tf.LayersModel (Keras-style) can be constructed from the loaded artifacts.

// Note: This code snippet won't run properly without the actual file input
//   elements in the HTML DOM.

// Suppose there are two HTML file input (`<input type="file" ...>`)
// elements.
const uploadJSONInput = document.getElementById('upload-json');
const uploadWeightsInput = document.getElementById('upload-weights');
const model = await tf.loadLayersModel(tf.io.browserFiles(
     [uploadJSONInput.files[0], uploadWeightsInput.files[0]]));

Parameters:

    files (File[]) Files to load from. Currently, this function supports only loading from files that contain Keras-style models (i.e., tf.Models), for which an Array of Files is expected (in that order):

        A JSON file containing the model topology and weight manifest.
        Optionally, one or more binary files containing the binary weights. These files must have names that match the paths in the weightsManifest contained by the aforementioned JSON file, or errors will be thrown during loading. These weights files have the same format as the ones generated by tensorflowjs_converter that comes with the tensorflowjs Python PIP package. If no weights files are provided, only the model topology will be loaded from the JSON file above.

Returns: IOHandler
tf.io.http (path, loadOptions?) function Source

Creates an IOHandler subtype that sends model artifacts to HTTP server.

An HTTP request of the multipart/form-data mime type will be sent to the path URL. The form data includes artifacts that represent the topology and/or weights of the model. In the case of Keras-style tf.Model, two blobs (files) exist in form-data:

    A JSON file consisting of modelTopology and weightsManifest.
    A binary weights file consisting of the concatenated weight values. These files are in the same format as the one generated by tfjs_converter.

The following code snippet exemplifies the client-side code that uses this function:

const model = tf.sequential();
model.add(
     tf.layers.dense({units: 1, inputShape: [100], activation: 'sigmoid'}));

const saveResult = await model.save(tf.io.http(
     'http://model-server:5000/upload', {requestInit: {method: 'PUT'}}));
console.log(saveResult);

If the default POST method is to be used, without any custom parameters such as headers, you can simply pass an HTTP or HTTPS URL to model.save:

const saveResult = await model.save('http://model-server:5000/upload');

The following GitHub Gist https://gist.github.com/dsmilkov/1b6046fd6132d7408d5257b0976f7864 implements a server based on flask that can receive the request. Upon receiving the model artifacts via the request, this particular server reconstitutes instances of Keras Models in memory.
Parameters:

    path (string) A URL path to the model. Can be an absolute HTTP path (e.g., 'http://localhost:8000/model-upload)') or a relative path (e.g., './model-upload').
    loadOptions (LoadOptions) Optional configuration for the loading. It includes the following fields:

        weightPathPrefix Optional, this specifies the path prefix for weight files, by default this is calculated from the path param.
        fetchFunc Optional, custom fetch function. E.g., in Node.js, the fetch from node-fetch can be used here.
        onProgress Optional, progress callback function, fired periodically before the load is completed.
    Optional

Returns: IOHandler
tf.loadGraphModelSync (modelSource) function Source

Load a graph model given a synchronous IO handler with a 'load' method.
Parameters:

    modelSource (io.IOHandlerSync| io.ModelArtifacts|[io.ModelJSON, /* Weights */ ArrayBuffer]) The io.IOHandlerSync that loads the model, or the io.ModelArtifacts that encode the model, or a tuple of [io.ModelJSON, ArrayBuffer] of which the first element encodes the model and the second contains the weights.

Returns: tf.GraphModel
Models / Management
tf.io.copyModel (sourceURL, destURL) function Source

Copy a model from one URL to another.

This function supports:

    Copying within a storage medium, e.g., tf.io.copyModel('localstorage://model-1', 'localstorage://model-2')
    Copying between two storage mediums, e.g., tf.io.copyModel('localstorage://model-1', 'indexeddb://model-1')

// First create and save a model.
const model = tf.sequential();
model.add(tf.layers.dense(
     {units: 1, inputShape: [10], activation: 'sigmoid'}));
await model.save('localstorage://demo/management/model1');

// Then list existing models.
console.log(JSON.stringify(await tf.io.listModels()));

// Copy the model, from Local Storage to IndexedDB.
await tf.io.copyModel(
     'localstorage://demo/management/model1',
     'indexeddb://demo/management/model1');

// List models again.
console.log(JSON.stringify(await tf.io.listModels()));

// Remove both models.
await tf.io.removeModel('localstorage://demo/management/model1');
await tf.io.removeModel('indexeddb://demo/management/model1');

Parameters:

    sourceURL (string) Source URL of copying.
    destURL (string) Destination URL of copying.

Returns: Promise<ModelArtifactsInfo>
tf.io.listModels () function Source

List all models stored in registered storage mediums.

For a web browser environment, the registered mediums are Local Storage and IndexedDB.

// First create and save a model.
const model = tf.sequential();
model.add(tf.layers.dense(
     {units: 1, inputShape: [10], activation: 'sigmoid'}));
await model.save('localstorage://demo/management/model1');

// Then list existing models.
console.log(JSON.stringify(await tf.io.listModels()));

// Delete the model.
await tf.io.removeModel('localstorage://demo/management/model1');

// List models again.
console.log(JSON.stringify(await tf.io.listModels()));

Returns: Promise<{[url: string]: ModelArtifactsInfo}>
tf.io.moveModel (sourceURL, destURL) function Source

Move a model from one URL to another.

This function supports:

    Moving within a storage medium, e.g., tf.io.moveModel('localstorage://model-1', 'localstorage://model-2')
    Moving between two storage mediums, e.g., tf.io.moveModel('localstorage://model-1', 'indexeddb://model-1')

// First create and save a model.
const model = tf.sequential();
model.add(tf.layers.dense(
     {units: 1, inputShape: [10], activation: 'sigmoid'}));
await model.save('localstorage://demo/management/model1');

// Then list existing models.
console.log(JSON.stringify(await tf.io.listModels()));

// Move the model, from Local Storage to IndexedDB.
await tf.io.moveModel(
     'localstorage://demo/management/model1',
     'indexeddb://demo/management/model1');

// List models again.
console.log(JSON.stringify(await tf.io.listModels()));

// Remove the moved model.
await tf.io.removeModel('indexeddb://demo/management/model1');

Parameters:

    sourceURL (string) Source URL of moving.
    destURL (string) Destination URL of moving.

Returns: Promise<ModelArtifactsInfo>
tf.io.removeModel (url) function Source

Remove a model specified by URL from a registered storage medium.

// First create and save a model.
const model = tf.sequential();
model.add(tf.layers.dense(
     {units: 1, inputShape: [10], activation: 'sigmoid'}));
await model.save('localstorage://demo/management/model1');

// Then list existing models.
console.log(JSON.stringify(await tf.io.listModels()));

// Delete the model.
await tf.io.removeModel('localstorage://demo/management/model1');

// List models again.
console.log(JSON.stringify(await tf.io.listModels()));

Parameters:

    url (string) A URL to a stored model, with a scheme prefix, e.g., 'localstorage://my-model-1', 'indexeddb://my/model/2'.

Returns: Promise<ModelArtifactsInfo>
Models / Serialization
tf.registerClass (cls, pkg?, name?) function Source

Register a class with the serialization map of TensorFlow.js.

This is often used for registering custom Layers, so they can be serialized and deserialized.

Example 1. Register the class without package name and specified name.

class MyCustomLayer extends tf.layers.Layer {
   static className = 'MyCustomLayer';

   constructor(config) {
     super(config);
   }
}
tf.serialization.registerClass(MyCustomLayer);
console.log(tf.serialization.GLOBALCUSTOMOBJECT.get("Custom>MyCustomLayer"));
console.log(tf.serialization.GLOBALCUSTOMNAMES.get(MyCustomLayer));

Example 2. Register the class with package name: "Package" and specified name: "MyLayer".

class MyCustomLayer extends tf.layers.Layer {
   static className = 'MyCustomLayer';

   constructor(config) {
     super(config);
   }
}
tf.serialization.registerClass(MyCustomLayer, "Package", "MyLayer");
console.log(tf.serialization.GLOBALCUSTOMOBJECT.get("Package>MyLayer"));
console.log(tf.serialization.GLOBALCUSTOMNAMES.get(MyCustomLayer));

Example 3. Register the class with specified name: "MyLayer".

class MyCustomLayer extends tf.layers.Layer {
   static className = 'MyCustomLayer';

   constructor(config) {
     super(config);
   }
}
tf.serialization.registerClass(MyCustomLayer, undefined, "MyLayer");
console.log(tf.serialization.GLOBALCUSTOMOBJECT.get("Custom>MyLayer"));
console.log(tf.serialization.GLOBALCUSTOMNAMES.get(MyCustomLayer));

Example 4. Register the class with specified package name: "Package".

class MyCustomLayer extends tf.layers.Layer {
   static className = 'MyCustomLayer';

   constructor(config) {
     super(config);
   }
}
tf.serialization.registerClass(MyCustomLayer, "Package");
console.log(tf.serialization.GLOBALCUSTOMOBJECT
.get("Package>MyCustomLayer"));
console.log(tf.serialization.GLOBALCUSTOMNAMES
.get(MyCustomLayer));

Parameters:

    cls (SerializableConstructor) The class to be registered. It must have a public static member called className defined and the value must be a non-empty string.
    pkg (string) The package name that this class belongs to. This used to define the key in GlobalCustomObject. If not defined, it defaults to Custom. Optional
    name (string) The name that user specified. It defaults to the actual name of the class as specified by its static className property. Optional

Returns: SerializableConstructor
Models / Classes
tf.Functional extends tf.LayersModel class Source

A tf.Functional is an alias to tf.LayersModel.

See also: tf.LayersModel, tf.Sequential, tf.loadLayersModel().
tf.GraphModel extends InferenceModel class Source

A tf.GraphModel is a directed, acyclic graph built from a SavedModel GraphDef and allows inference execution.

A tf.GraphModel can only be created by loading from a model converted from a TensorFlow SavedModel using the command line converter tool and loaded via tf.loadGraphModel().
loadSync (artifacts) method Source

Synchronously construct the in memory weight map and compile the inference graph.
Parameters:

    artifacts (io.ModelArtifacts)

Returns: boolean
save (handlerOrURL, config?) method Source

Save the configuration and/or weights of the GraphModel.

An IOHandler is an object that has a save method of the proper signature defined. The save method manages the storing or transmission of serialized data ("artifacts") that represent the model's topology and weights onto or via a specific medium, such as file downloads, local storage, IndexedDB in the web browser and HTTP requests to a server. TensorFlow.js provides IOHandler implementations for a number of frequently used saving mediums, such as tf.io.browserDownloads() and tf.io.browserLocalStorage. See tf.io for more details.

This method also allows you to refer to certain types of IOHandlers as URL-like string shortcuts, such as 'localstorage://' and 'indexeddb://'.

Example 1: Save model's topology and weights to browser local storage; then load it back.

const modelUrl =
    'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json';
const model = await tf.loadGraphModel(modelUrl);
const zeros = tf.zeros([1, 224, 224, 3]);
model.predict(zeros).print();

const saveResults = await model.save('localstorage://my-model-1');

const loadedModel = await tf.loadGraphModel('localstorage://my-model-1');
console.log('Prediction from loaded model:');
model.predict(zeros).print();

Parameters:

    handlerOrURL (io.IOHandler|string) An instance of IOHandler or a URL-like, scheme-based string shortcut for IOHandler.
    config (Object) Options for saving the model. Optional
    trainableOnly (boolean) Whether to save only the trainable weights of the model, ignoring the non-trainable ones.
    includeOptimizer (boolean) Whether the optimizer will be saved (if exists).

    Default: false.

Returns: Promise<io.SaveResult>
predict (inputs, config?) method Source

Execute the inference for the input tensors.
Parameters:

    inputs (tf.Tensor|tf.Tensor[]|{[name: string]: tf.Tensor})
    config (Object) Prediction configuration for specifying the batch size. Currently the batch size option is ignored for graph model. Optional
    batchSize (number) Optional. Batch size (Integer). If unspecified, it will default to 32.
    verbose (boolean) Optional. Verbosity mode. Defaults to false.

Returns: tf.Tensor|tf.Tensor[]|{[name: string]: tf.Tensor}
predictAsync (inputs, config?) method Source

Execute the inference for the input tensors in async fashion, use this method when your model contains control flow ops.
Parameters:

    inputs (tf.Tensor|tf.Tensor[]|{[name: string]: tf.Tensor})
    config (Object) Prediction configuration for specifying the batch size. Currently the batch size option is ignored for graph model. Optional
    batchSize (number) Optional. Batch size (Integer). If unspecified, it will default to 32.
    verbose (boolean) Optional. Verbosity mode. Defaults to false.

Returns: Promise<tf.Tensor|tf.Tensor[]|{[name: string]: tf.Tensor}>
execute (inputs, outputs?) method Source

Executes inference for the model for given input tensors.
Parameters:

    inputs (tf.Tensor|tf.Tensor[]|{[name: string]: tf.Tensor}) tensor, tensor array or tensor map of the inputs for the model, keyed by the input node names.
    outputs (string|string[]) output node name from the TensorFlow model, if no outputs are specified, the default outputs of the model would be used. You can inspect intermediate nodes of the model by adding them to the outputs array. Optional

Returns: tf.Tensor|tf.Tensor[]
executeAsync (inputs, outputs?) method Source

Executes inference for the model for given input tensors in async fashion, use this method when your model contains control flow ops.
Parameters:

    inputs (tf.Tensor|tf.Tensor[]|{[name: string]: tf.Tensor}) tensor, tensor array or tensor map of the inputs for the model, keyed by the input node names.
    outputs (string|string[]) output node name from the TensorFlow model, if no outputs are specified, the default outputs of the model would be used. You can inspect intermediate nodes of the model by adding them to the outputs array. Optional

Returns: Promise<tf.Tensor|tf.Tensor[]>
getIntermediateTensors () method Source

Get intermediate tensors for model debugging mode (flag KEEP_INTERMEDIATE_TENSORS is true).
Returns: NamedTensorsMap
disposeIntermediateTensors () method Source

Dispose intermediate tensors for model debugging mode (flag KEEP_INTERMEDIATE_TENSORS is true).
Returns: void
dispose () method Source

Releases the memory used by the weight tensors and resourceManager.
Returns: void
tf.LayersModel extends Container|tfc.InferenceModel class Source

A tf.LayersModel is a directed, acyclic graph of tf.Layers plus methods for training, evaluation, prediction and saving.

tf.LayersModel is the basic unit of training, inference and evaluation in TensorFlow.js. To create a tf.LayersModel, use tf.LayersModel.

See also: tf.Sequential, tf.loadLayersModel().
summary (lineLength?, positions?, printFn?) method Source

Print a text summary of the model's layers.

The summary includes

    Name and type of all layers that comprise the model.
    Output shape(s) of the layers
    Number of weight parameters of each layer
    If the model has non-sequential-like topology, the inputs each layer receives
    The total number of trainable and non-trainable parameters of the model.

const input1 = tf.input({shape: [10]});
const input2 = tf.input({shape: [20]});
const dense1 = tf.layers.dense({units: 4}).apply(input1);
const dense2 = tf.layers.dense({units: 8}).apply(input2);
const concat = tf.layers.concatenate().apply([dense1, dense2]);
const output =
     tf.layers.dense({units: 3, activation: 'softmax'}).apply(concat);

const model = tf.model({inputs: [input1, input2], outputs: output});
model.summary();

Parameters:

    lineLength (number) Custom line length, in number of characters. Optional
    positions (number[]) Custom widths of each of the columns, as either fractions of lineLength (e.g., [0.5, 0.75, 1]) or absolute number of characters (e.g., [30, 50, 65]). Each number corresponds to right-most (i.e., ending) position of a column. Optional
    printFn ((message?: tf.any(), ...optionalParams: tf.any()[]) => void) Custom print function. Can be used to replace the default console.log. For example, you can use x => {} to mute the printed messages in the console. Optional

Returns: void
compile (args) method Source

Configures and prepares the model for training and evaluation. Compiling outfits the model with an optimizer, loss, and/or metrics. Calling fit or evaluate on an un-compiled model will throw an error.
Parameters:

    args (Object) a ModelCompileArgs specifying the loss, optimizer, and metrics to be used for fitting and evaluating this model.
    optimizer (string|tf.train.Optimizer) An instance of tf.train.Optimizer or a string name for an Optimizer.
    loss (string|string[]|{[outputName: string]: string}|LossOrMetricFn| LossOrMetricFn[]|{[outputName: string]: LossOrMetricFn}) Object function(s) or name(s) of object function(s). If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or an Array of losses. The loss value that will be minimized by the model will then be the sum of all individual losses.
    metrics (string|LossOrMetricFn|Array| {[outputName: string]: string | LossOrMetricFn}) List of metrics to be evaluated by the model during training and testing. Typically you will use metrics=['accuracy']. To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary.

Returns: void
evaluate (x, y, args?) method Source

Returns the loss value & metrics values for the model in test mode.

Loss and metrics are specified during compile(), which needs to happen before calls to evaluate().

Computation is done in batches.

const model = tf.sequential({
   layers: [tf.layers.dense({units: 1, inputShape: [10]})]
});
model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});
const result = model.evaluate(
     tf.ones([8, 10]), tf.ones([8, 1]), {batchSize: 4});
result.print();

Parameters:

    x (tf.Tensor|tf.Tensor[]) tf.Tensor of test data, or an Array of tf.Tensors if the model has multiple inputs.
    y (tf.Tensor|tf.Tensor[]) tf.Tensor of target data, or an Array of tf.Tensors if the model has multiple outputs.
    args (Object) A ModelEvaluateArgs, containing optional fields. Optional
    batchSize (number) Batch size (Integer). If unspecified, it will default to 32.
    verbose (ModelLoggingVerbosity) Verbosity mode.
    sampleWeight (tf.Tensor) Tensor of weights to weight the contribution of different samples to the loss and metrics.
    steps (number) integer: total number of steps (batches of samples) before declaring the evaluation round finished. Ignored with the default value of undefined.

Returns: tf.Scalar|tf.Scalar[]
evaluateDataset (dataset, args?) method Source

Evaluate model using a dataset object.

Note: Unlike evaluate(), this method is asynchronous (async).
Parameters:

    dataset (tf.data.Dataset) A dataset object. Its iterator() method is expected to generate a dataset iterator object, the next() method of which is expected to produce data batches for evaluation. The return value of the next() call ought to contain a boolean done field and a value field. The value field is expected to be an array of two tf.Tensors or an array of two nested tf.Tensor structures. The former case is for models with exactly one input and one output (e.g. a sequential model). The latter case is for models with multiple inputs and/or multiple outputs. Of the two items in the array, the first is the input feature(s) and the second is the output target(s).
    args (Object) A configuration object for the dataset-based evaluation. Optional
    batches (number) Number of batches to draw from the dataset object before ending the evaluation.
    verbose (ModelLoggingVerbosity) Verbosity mode.

Returns: Promise<tf.Scalar|tf.Scalar[]>
predict (x, args?) method Source

Generates output predictions for the input samples.

Computation is done in batches.

Note: the "step" mode of predict() is currently not supported. This is because the TensorFlow.js core backend is imperative only.

const model = tf.sequential({
   layers: [tf.layers.dense({units: 1, inputShape: [10]})]
});
model.predict(tf.ones([8, 10]), {batchSize: 4}).print();

Parameters:

    x (tf.Tensor|tf.Tensor[]) The input data, as a Tensor, or an Array of tf.Tensors if the model has multiple inputs.
    args (Object) A ModelPredictArgs object containing optional fields. Optional
    batchSize (number) Optional. Batch size (Integer). If unspecified, it will default to 32.
    verbose (boolean) Optional. Verbosity mode. Defaults to false.

Returns: tf.Tensor|tf.Tensor[]
predictOnBatch (x) method Source

Returns predictions for a single batch of samples.

const model = tf.sequential({
   layers: [tf.layers.dense({units: 1, inputShape: [10]})]
});
model.predictOnBatch(tf.ones([8, 10])).print();

Parameters:

    x (tf.Tensor|tf.Tensor[]) : Input samples, as a Tensor (for models with exactly one input) or an array of Tensors (for models with more than one input).

Returns: tf.Tensor|tf.Tensor[]
fit (x, y, args?) method Source

Trains the model for a fixed number of epochs (iterations on a dataset).

const model = tf.sequential({
     layers: [tf.layers.dense({units: 1, inputShape: [10]})]
});
model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});
for (let i = 1; i < 5 ; ++i) {
   const h = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {
       batchSize: 4,
       epochs: 3
   });
   console.log("Loss after Epoch " + i + " : " + h.history.loss[0]);
}

Parameters:

    x (tf.Tensor|tf.Tensor[]|{[inputName: string]: tf.Tensor}) tf.Tensor of training data, or an array of tf.Tensors if the model has multiple inputs. If all inputs in the model are named, you can also pass a dictionary mapping input names to tf.Tensors.
    y (tf.Tensor|tf.Tensor[]|{[inputName: string]: tf.Tensor}) tf.Tensor of target (label) data, or an array of tf.Tensors if the model has multiple outputs. If all outputs in the model are named, you can also pass a dictionary mapping output names to tf.Tensors.
    args (Object) A ModelFitArgs, containing optional fields. Optional
    batchSize (number) Number of samples per gradient update. If unspecified, it will default to 32.
    epochs (number) Integer number of times to iterate over the training data arrays.
    verbose (ModelLoggingVerbosity | 2) Verbosity level.

    Expected to be 0, 1, or 2. Default: 1.

    0 - No printed message during fit() call. 1 - In Node.js (tfjs-node), prints the progress bar, together with real-time updates of loss and metric values and training speed. In the browser: no action. This is the default. 2 - Not implemented yet.
    callbacks (BaseCallback[]|CustomCallbackArgs|CustomCallbackArgs[]) List of callbacks to be called during training. Can have one or more of the following callbacks:

        onTrainBegin(logs): called when training starts.
        onTrainEnd(logs): called when training ends.
        onEpochBegin(epoch, logs): called at the start of every epoch.
        onEpochEnd(epoch, logs): called at the end of every epoch.
        onBatchBegin(batch, logs): called at the start of every batch.
        onBatchEnd(batch, logs): called at the end of every batch.
        onYield(epoch, batch, logs): called every yieldEvery milliseconds with the current epoch, batch and logs. The logs are the same as in onBatchEnd(). Note that onYield can skip batches or epochs. See also docs for yieldEvery below.
    validationSplit (number) Float between 0 and 1: fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling.
    validationData ([ tf.Tensor|tf.Tensor[], tf.Tensor|tf.Tensor[] ]|[tf.Tensor | tf.Tensor[], tf.Tensor|tf.Tensor[], tf.Tensor|tf.Tensor[]]) Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. This could be a tuple [xVal, yVal] or a tuple [xVal, yVal, valSampleWeights]. The model will not be trained on this data. validationData will override validationSplit.
    shuffle (boolean) Whether to shuffle the training data before each epoch. Has no effect when stepsPerEpoch is not null.
    classWeight (ClassWeight|ClassWeight[]|ClassWeightMap) Optional object mapping class indices (integers) to a weight (float) to apply to the model's loss for the samples from this class during training. This can be useful to tell the model to "pay more attention" to samples from an under-represented class.

    If the model has multiple outputs, a class weight can be specified for each of the outputs by setting this field an array of weight object or an object that maps model output names (e.g., model.outputNames[0]) to weight objects.
    sampleWeight (tf.Tensor) Optional array of the same length as x, containing weights to apply to the model's loss for each sample. In the case of temporal data, you can pass a 2D array with shape (samples, sequenceLength), to apply a different weight to every timestep of every sample. In this case you should make sure to specify sampleWeightMode="temporal" in compile().
    initialEpoch (number) Epoch at which to start training (useful for resuming a previous training run). When this is used, epochs is the index of the "final epoch". The model is not trained for a number of iterations given by epochs, but merely until the epoch of index epochs is reached.
    stepsPerEpoch (number) Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with Input Tensors such as TensorFlow data tensors, the default null is equal to the number of unique samples in your dataset divided by the batch size, or 1 if that cannot be determined.
    validationSteps (number) Only relevant if stepsPerEpoch is specified. Total number of steps (batches of samples) to validate before stopping.
    yieldEvery (YieldEveryOptions) Configures the frequency of yielding the main thread to other tasks.

    In the browser environment, yielding the main thread can improve the responsiveness of the page during training. In the Node.js environment, it can ensure tasks queued in the event loop can be handled in a timely manner.

    The value can be one of the following:
        'auto': The yielding happens at a certain frame rate (currently set at 125ms). This is the default.
        'batch': yield every batch.
        'epoch': yield every epoch.
        any number: yield every number milliseconds.
        'never': never yield. (yielding can still happen through await nextFrame() calls in custom callbacks.)

Returns: Promise<History>
fitDataset (dataset, args) method Source

Trains the model using a dataset object.
Parameters:

    dataset (tf.data.Dataset) A dataset object. Its iterator() method is expected to generate a dataset iterator object, the next() method of which is expected to produce data batches for training. The return value of the next() call ought to contain a boolean done field and a value field. The value field is expected to be an array of two tf.Tensors or an array of two nested tf.Tensor structures. The former case is for models with exactly one input and one output (e.g. a sequential model). The latter case is for models with multiple inputs and/or multiple outputs. Of the two items in the array, the first is the input feature(s) and the second is the output target(s).
    args (Object) A ModelFitDatasetArgs, containing optional fields.
    batchesPerEpoch (number) (Optional) Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. It should typically be equal to the number of samples of your dataset divided by the batch size, so that fitDataset() call can utilize the entire dataset. If it is not provided, use done return value in iterator.next() as signal to finish an epoch.
    epochs (number) Integer number of times to iterate over the training dataset.
    verbose (ModelLoggingVerbosity) Verbosity level.

    Expected to be 0, 1, or 2. Default: 1.

    0 - No printed message during fit() call. 1 - In Node.js (tfjs-node), prints the progress bar, together with real-time updates of loss and metric values and training speed. In the browser: no action. This is the default. 2 - Not implemented yet.
    callbacks (BaseCallback[]|CustomCallbackArgs|CustomCallbackArgs[]) List of callbacks to be called during training. Can have one or more of the following callbacks:

        onTrainBegin(logs): called when training starts.
        onTrainEnd(logs): called when training ends.
        onEpochBegin(epoch, logs): called at the start of every epoch.
        onEpochEnd(epoch, logs): called at the end of every epoch.
        onBatchBegin(batch, logs): called at the start of every batch.
        onBatchEnd(batch, logs): called at the end of every batch.
        onYield(epoch, batch, logs): called every yieldEvery milliseconds with the current epoch, batch and logs. The logs are the same as in onBatchEnd(). Note that onYield can skip batches or epochs. See also docs for yieldEvery below.
    validationData ([ TensorOrArrayOrMap, TensorOrArrayOrMap ]|[TensorOrArrayOrMap, TensorOrArrayOrMap, TensorOrArrayOrMap]|tf.data.Dataset) Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. This could be any of the following:

        An array [xVal, yVal], where the two values may be tf.Tensor, an array of Tensors, or a map of string to Tensor.
        Similarly, an array [xVal, yVal, valSampleWeights] (not implemented yet).
        a Dataset object with elements of the form {xs: xVal, ys: yVal}, where xs and ys are the feature and label tensors, respectively.

    If validationData is an Array of Tensor objects, each tf.Tensor will be sliced into batches during validation, using the parameter validationBatchSize (which defaults to 32). The entirety of the tf.Tensor objects will be used in the validation.

    If validationData is a dataset object, and the validationBatches parameter is specified, the validation will use validationBatches batches drawn from the dataset object. If validationBatches parameter is not specified, the validation will stop when the dataset is exhausted.

    The model will not be trained on this data.
    validationBatchSize (number) Optional batch size for validation.

    Used only if validationData is an array of tf.Tensor objects, i.e., not a dataset object.

    If not specified, its value defaults to 32.
    validationBatches (number) (Optional) Only relevant if validationData is specified and is a dataset object.

    Total number of batches of samples to draw from validationData for validation purpose before stopping at the end of every epoch. If not specified, evaluateDataset will use iterator.next().done as signal to stop validation.
    yieldEvery (YieldEveryOptions) Configures the frequency of yielding the main thread to other tasks.

    In the browser environment, yielding the main thread can improve the responsiveness of the page during training. In the Node.js environment, it can ensure tasks queued in the event loop can be handled in a timely manner.

    The value can be one of the following:
        'auto': The yielding happens at a certain frame rate (currently set at 125ms). This is the default.
        'batch': yield every batch.
        'epoch': yield every epoch.
        a number: Will yield every number milliseconds.
        'never': never yield. (But yielding can still happen through await nextFrame() calls in custom callbacks.)
    initialEpoch (number) Epoch at which to start training (useful for resuming a previous training run). When this is used, epochs is the index of the "final epoch". The model is not trained for a number of iterations given by epochs, but merely until the epoch of index epochs is reached.
    classWeight (ClassWeight|ClassWeight[]|ClassWeightMap) Optional object mapping class indices (integers) to a weight (float) to apply to the model's loss for the samples from this class during training. This can be useful to tell the model to "pay more attention" to samples from an under-represented class.

    If the model has multiple outputs, a class weight can be specified for each of the outputs by setting this field an array of weight object or an object that maps model output names (e.g., model.outputNames[0]) to weight objects.

Returns: Promise<History>
trainOnBatch (x, y) method Source

Runs a single gradient update on a single batch of data.

This method differs from fit() and fitDataset() in the following regards:

    It operates on exactly one batch of data.
    It returns only the loss and metric values, instead of returning the batch-by-batch loss and metric values.
    It doesn't support fine-grained options such as verbosity and callbacks.

Parameters:

    x (tf.Tensor|tf.Tensor[]|{[inputName: string]: tf.Tensor}) Input data. It could be one of the following:

        A tf.Tensor, or an Array of tf.Tensors (in case the model has multiple inputs).
        An Object mapping input names to corresponding tf.Tensor (if the model has named inputs).
    y (tf.Tensor|tf.Tensor[]| {[inputName: string]: tf.Tensor}) Target data. It could be either a tf.Tensor or multiple tf.Tensors. It should be consistent with x.

Returns: Promise<number|number[]>
save (handlerOrURL, config?) method Source

Save the configuration and/or weights of the LayersModel.

An IOHandler is an object that has a save method of the proper signature defined. The save method manages the storing or transmission of serialized data ("artifacts") that represent the model's topology and weights onto or via a specific medium, such as file downloads, local storage, IndexedDB in the web browser and HTTP requests to a server. TensorFlow.js provides IOHandler implementations for a number of frequently used saving mediums, such as tf.io.browserDownloads() and tf.io.browserLocalStorage. See tf.io for more details.

This method also allows you to refer to certain types of IOHandlers as URL-like string shortcuts, such as 'localstorage://' and 'indexeddb://'.

Example 1: Save model's topology and weights to browser local storage; then load it back.

const model = tf.sequential(
     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});
console.log('Prediction from original model:');
model.predict(tf.ones([1, 3])).print();

const saveResults = await model.save('localstorage://my-model-1');

const loadedModel = await tf.loadLayersModel('localstorage://my-model-1');
console.log('Prediction from loaded model:');
loadedModel.predict(tf.ones([1, 3])).print();

Example 2. Saving model's topology and weights to browser IndexedDB; then load it back.

const model = tf.sequential(
     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});
console.log('Prediction from original model:');
model.predict(tf.ones([1, 3])).print();

const saveResults = await model.save('indexeddb://my-model-1');

const loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');
console.log('Prediction from loaded model:');
loadedModel.predict(tf.ones([1, 3])).print();

Example 3. Saving model's topology and weights as two files (my-model-1.json and my-model-1.weights.bin) downloaded from browser.

const model = tf.sequential(
     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});
const saveResults = await model.save('downloads://my-model-1');

Example 4. Send model's topology and weights to an HTTP server. See the documentation of tf.io.http() for more details including specifying request parameters and implementation of the server.

const model = tf.sequential(
     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});
const saveResults = await model.save('http://my-server/model/upload');

Parameters:

    handlerOrURL (io.IOHandler|string) An instance of IOHandler or a URL-like, scheme-based string shortcut for IOHandler.
    config (Object) Options for saving the model. Optional
    trainableOnly (boolean) Whether to save only the trainable weights of the model, ignoring the non-trainable ones.
    includeOptimizer (boolean) Whether the optimizer will be saved (if exists).

    Default: false.

Returns: Promise<io.SaveResult>
getLayer (name) method Source

Retrieves a layer based on either its name (unique) or index.

Indices are based on order of horizontal graph traversal (bottom-up).

If both name and index are specified, index takes precedence.
Parameters:

    name (string) Name of layer.

Returns: tf.layers.Layer
getLayer (name) method Source

Retrieves a layer based on either its name (unique) or index.

Indices are based on order of horizontal graph traversal (bottom-up).

If both name and index are specified, index takes precedence.
Parameters:

    name (string) Name of layer.

Returns: tf.layers.Layer
getLayer (name) method Source

Retrieves a layer based on either its name (unique) or index.

Indices are based on order of horizontal graph traversal (bottom-up).

If both name and index are specified, index takes precedence.
Parameters:

    name (string) Name of layer.

Returns: tf.layers.Layer
getLayer (name) method Source

Retrieves a layer based on either its name (unique) or index.

Indices are based on order of horizontal graph traversal (bottom-up).

If both name and index are specified, index takes precedence.
Parameters:

    name (string) Name of layer.

Returns: tf.layers.Layer
tf.Sequential extends tf.LayersModel class Source

A model with a stack of layers, feeding linearly from one to the next.

tf.sequential() is a factory function that creates an instance of tf.Sequential.

  // Define a model for linear regression.
  const model = tf.sequential();
  model.add(tf.layers.dense({units: 1, inputShape: [1]}));

  // Prepare the model for training: Specify the loss and the optimizer.
  model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});

  // Generate some synthetic data for training.
  const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);
  const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);

  // Train the model using the data then do inference on a data point the
  // model hasn't seen:
  await model.fit(xs, ys);
  model.predict(tf.tensor2d([5], [1, 1])).print();

add (layer) method Source

Adds a layer instance on top of the layer stack.

  const model = tf.sequential();
  model.add(tf.layers.dense({units: 8, inputShape: [1]}));
  model.add(tf.layers.dense({units: 4, activation: 'relu6'}));
  model.add(tf.layers.dense({units: 1, activation: 'relu6'}));
  // Note that the untrained model is random at this point.
  model.predict(tf.randomNormal([10, 1])).print();

Parameters:

    layer (tf.layers.Layer) Layer instance.

Returns: void
tf.SymbolicTensor class Source

tf.SymbolicTensor is a placeholder for a Tensor without any concrete value.

They are most often encountered when building a graph of Layers for a tf.LayersModel and the input data's shape, but not values are known.
Models / Op Registry
tf.deregisterOp (name) function Source

Deregister the Op for graph model executor.
Parameters:

    name (string) The Tensorflow Op name.

Returns: void
tf.getRegisteredOp (name) function Source

Retrieve the OpMapper object for the registered op.
Parameters:

    name (string) The Tensorflow Op name.

Returns: OpMapper
tf.registerOp (name, opFunc) function Source

Register an Op for graph model executor. This allows you to register TensorFlow custom op or override existing op.

Here is an example of registering a new MatMul Op.

const customMatmul = (node) =>
    tf.matMul(
        node.inputs[0], node.inputs[1],
        node.attrs['transpose_a'], node.attrs['transpose_b']);

tf.registerOp('MatMul', customMatmul);

The inputs and attrs of the node object are based on the TensorFlow op registry.
Parameters:

    name (string) The Tensorflow Op name.
    opFunc (Object) An op function which is called with the current graph node during execution and needs to return a tensor or a list of tensors. The node has the following attributes:

        attr: A map from attribute name to its value
        inputs: A list of input tensors

Returns: void
Layers

Layers are the primary building block for constructing a Model. Each layer will typically perform some computation to transform its input to its output.

Layers will automatically take care of creating and initializing the various internal variables/weights they need to function.
Layers / Advanced Activation
tf.layers.elu (args?) function Source

Exponential Linear Unit (ELU).

It follows: f(x) = alpha * (exp(x) - 1.) for x < 0, f(x) = x for x >= 0.

Input shape: Arbitrary. Use the configuration inputShape when using this layer as the first layer in a model.

Output shape: Same shape as the input.

References:

    Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)

Parameters:

    args (Object) Optional
    alpha (number) Float >= 0. Negative slope coefficient. Defaults to 1.0.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: ELU
tf.layers.leakyReLU (args?) function Source

Leaky version of a rectified linear unit.

It allows a small gradient when the unit is not active: f(x) = alpha * x for x < 0. f(x) = x for x >= 0.

Input shape: Arbitrary. Use the configuration inputShape when using this layer as the first layer in a model.

Output shape: Same shape as the input.
Parameters:

    args (Object) Optional
    alpha (number) Float >= 0. Negative slope coefficient. Defaults to 0.3.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: LeakyReLU
tf.layers.prelu (args?) function Source

Parameterized version of a leaky rectified linear unit.

It follows f(x) = alpha * x for x < 0. f(x) = x for x >= 0. wherein alpha is a trainable weight.

Input shape: Arbitrary. Use the configuration inputShape when using this layer as the first layer in a model.

Output shape: Same shape as the input.
Parameters:

    args (Object) Optional
    alphaInitializer (tf.initializers.Initializer|'constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string) Initializer for the learnable alpha.
    alphaRegularizer (Regularizer) Regularizer for the learnable alpha.
    alphaConstraint (tf.constraints.Constraint) Constraint for the learnable alpha.
    sharedAxes (number|number[]) The axes along which to share learnable parameters for the activation function. For example, if the incoming feature maps are from a 2D convolution with output shape [numExamples, height, width, channels], and you wish to share parameters across space (height and width) so that each filter channels has only one set of parameters, set shared_axes: [1, 2].
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: PReLU
tf.layers.reLU (args?) function Source

Rectified Linear Unit activation function.

Input shape: Arbitrary. Use the config field inputShape (Array of integers, does not include the sample axis) when using this layer as the first layer in a model.

Output shape: Same shape as the input.
Parameters:

    args (Object) Optional
    maxValue (number) Float, the maximum output value.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: ReLU
tf.layers.softmax (args?) function Source

Softmax activation layer.

Input shape: Arbitrary. Use the configuration inputShape when using this layer as the first layer in a model.

Output shape: Same shape as the input.
Parameters:

    args (Object) Optional
    axis (number|number[]) Integer, axis along which the softmax normalization is applied. Defaults to -1 (i.e., the last axis).
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Softmax
tf.layers.thresholdedReLU (args?) function Source

Thresholded Rectified Linear Unit.

It follows: f(x) = x for x > theta, f(x) = 0 otherwise.

Input shape: Arbitrary. Use the configuration inputShape when using this layer as the first layer in a model.

Output shape: Same shape as the input.

References:

    Zero-Bias Autoencoders and the Benefits of Co-Adapting Features

Parameters:

    args (Object) Optional
    theta (number) Float >= 0. Threshold location of activation.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: ThresholdedReLU
Layers / Basic
tf.layers.activation (args) function Source

Applies an activation function to an output.

This layer applies element-wise activation function. Other layers, notably dense can also apply activation functions. Use this isolated activation function to extract the values before and after the activation. For instance:

const input = tf.input({shape: [5]});
const denseLayer = tf.layers.dense({units: 1});
const activationLayer = tf.layers.activation({activation: 'relu6'});

// Obtain the output symbolic tensors by applying the layers in order.
const denseOutput = denseLayer.apply(input);
const activationOutput = activationLayer.apply(denseOutput);

// Create the model based on the inputs.
const model = tf.model({
     inputs: input,
     outputs: [denseOutput, activationOutput]
});

// Collect both outputs and print separately.
const [denseOut, activationOut] = model.predict(tf.randomNormal([6, 5]));
denseOut.print();
activationOut.print();

Parameters:

    args (Object)
    activation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Name of the activation function to use.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Activation
tf.layers.dense (args) function Source

Creates a dense (fully connected) layer.

This layer implements the operation: output = activation(dot(input, kernel) + bias)

activation is the element-wise activation function passed as the activation argument.

kernel is a weights matrix created by the layer.

bias is a bias vector created by the layer (only applicable if useBias is true).

Input shape:*

nD tf.Tensor with shape: (batchSize, ..., inputDim).

The most common situation would be a 2D input with shape (batchSize, inputDim).

Output shape:*

nD tensor with shape: (batchSize, ..., units).

For instance, for a 2D input with shape (batchSize, inputDim), the output would have shape (batchSize, units).

Note: if the input to the layer has a rank greater than 2, then it is flattened prior to the initial dot product with the kernel.
Parameters:

    args (Object)
    units (number) Positive integer, dimensionality of the output space.
    activation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Activation function to use.

    If unspecified, no activation is applied.
    useBias (boolean) Whether to apply a bias.
    kernelInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the dense kernel weights matrix.
    biasInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the bias vector.
    inputDim (number) If specified, defines inputShape as [inputDim].
    kernelConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint for the kernel weights.
    biasConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint for the bias vector.
    kernelRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the dense kernel weights matrix.
    biasRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the bias vector.
    activityRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the activation.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Dense
tf.layers.dropout (args) function Source

Applies dropout to the input.

Dropout consists in randomly setting a fraction rate of input units to 0 at each update during training time, which helps prevent overfitting.
Parameters:

    args (Object)
    rate (number) Float between 0 and 1. Fraction of the input units to drop.
    noiseShape (number[]) Integer array representing the shape of the binary dropout mask that will be multiplied with the input.

    For instance, if your inputs have shape (batchSize, timesteps, features) and you want the dropout mask to be the same for all timesteps, you can use noise_shape=(batch_size, 1, features).
    seed (number) An integer to use as random seed.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Dropout
tf.layers.embedding (args) function Source

Maps positive integers (indices) into dense vectors of fixed size. E.g. [[4], [20]] -> [[0.25, 0.1], [0.6, -0.2]]

Input shape:* 2D tensor with shape: [batchSize, sequenceLength].

Output shape:* 3D tensor with shape: [batchSize, sequenceLength, outputDim].
Parameters:

    args (Object)
    inputDim (number) Integer > 0. Size of the vocabulary, i.e. maximum integer index + 1.
    outputDim (number) Integer >= 0. Dimension of the dense embedding.
    embeddingsInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the embeddings matrix.
    embeddingsRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the embeddings matrix.
    activityRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the activation.
    embeddingsConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the embeddings matrix.
    maskZero (boolean) Whether the input value 0 is a special "padding" value that should be masked out. This is useful when using recurrent layers which may take variable length input.

    If this is True then all subsequent layers in the model need to support masking or an exception will be raised. If maskZero is set to True, as a consequence, index 0 cannot be used in the vocabulary (inputDim should equal size of vocabulary + 1).
    inputLength (number|number[]) Length of input sequences, when it is constant.

    This argument is required if you are going to connect flatten then dense layers upstream (without it, the shape of the dense outputs cannot be computed).
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Embedding
tf.layers.flatten (args?) function Source

Flattens the input. Does not affect the batch size.

A Flatten layer flattens each batch in its inputs to 1D (making the output 2D).

For example:

const input = tf.input({shape: [4, 3]});
const flattenLayer = tf.layers.flatten();
// Inspect the inferred output shape of the flatten layer, which
// equals `[null, 12]`. The 2nd dimension is 4 * 3, i.e., the result of the
// flattening. (The 1st dimension is the undermined batch size.)
console.log(JSON.stringify(flattenLayer.apply(input).shape));

Parameters:

    args (Object) Optional
    dataFormat ('channelsFirst'|'channelsLast') Image data format: channelsLast (default) or channelsFirst.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Flatten
tf.layers.permute (args) function Source

Permutes the dimensions of the input according to a given pattern.

Useful for, e.g., connecting RNNs and convnets together.

Example:

const model = tf.sequential();
model.add(tf.layers.permute({
   dims: [2, 1],
   inputShape: [10, 64]
}));
console.log(model.outputShape);
// Now model's output shape is [null, 64, 10], where null is the
// unpermuted sample (batch) dimension.

Input shape: Arbitrary. Use the configuration field inputShape when using this layer as the first layer in a model.

Output shape: Same rank as the input shape, but with the dimensions re-ordered (i.e., permuted) according to the dims configuration of this layer.
Parameters:

    args (Object)
    dims (number[]) Array of integers. Permutation pattern. Does not include the sample (batch) dimension. Index starts at 1. For instance, [2, 1] permutes the first and second dimensions of the input.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Permute
tf.layers.repeatVector (args) function Source

Repeats the input n times in a new dimension.

  const model = tf.sequential();
  model.add(tf.layers.repeatVector({n: 4, inputShape: [2]}));
  const x = tf.tensor2d([[10, 20]]);
  // Use the model to do inference on a data point the model hasn't seen
  model.predict(x).print();
  // output shape is now [batch, 2, 4]

Parameters:

    args (Object)
    n (number) The integer number of times to repeat the input.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: RepeatVector
tf.layers.reshape (args) function Source

Reshapes an input to a certain shape.

const input = tf.input({shape: [4, 3]});
const reshapeLayer = tf.layers.reshape({targetShape: [2, 6]});
// Inspect the inferred output shape of the Reshape layer, which
// equals `[null, 2, 6]`. (The 1st dimension is the undermined batch size.)
console.log(JSON.stringify(reshapeLayer.apply(input).shape));

Input shape: Arbitrary, although all dimensions in the input shape must be fixed. Use the configuration inputShape when using this layer as the first layer in a model.

Output shape: [batchSize, targetShape[0], targetShape[1], ..., targetShape[targetShape.length - 1]].
Parameters:

    args (Object)
    targetShape ((null | number)[]) The target shape. Does not include the batch axis.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Reshape
tf.layers.spatialDropout1d (args) function Source

Spatial 1D version of Dropout.

This Layer type performs the same function as the Dropout layer, but it drops entire 1D feature maps instead of individual elements. For example, if an input example consists of 3 timesteps and the feature map for each timestep has a size of 4, a spatialDropout1d layer may zero out the feature maps of the 1st timesteps and 2nd timesteps completely while sparing all feature elements of the 3rd timestep.

If adjacent frames (timesteps) are strongly correlated (as is normally the case in early convolution layers), regular dropout will not regularize the activation and will otherwise just result in merely an effective learning rate decrease. In this case, spatialDropout1d will help promote independence among feature maps and should be used instead.

Arguments:* rate: A floating-point number >=0 and <=1. Fraction of the input elements to drop.

Input shape:* 3D tensor with shape (samples, timesteps, channels).

Output shape:* Same as the input shape.

References:

    Efficient Object Localization Using Convolutional Networks

Parameters:

    args (Object)
    rate (number) Float between 0 and 1. Fraction of the input units to drop.
    seed (number) An integer to use as random seed.
    input_shape ((null | number)[])
    batch_input_shape ((null | number)[])
    batch_size (number)
    dtype ('float32'|'int32'|'bool'|'complex64'|'string')
    name (string)
    trainable (boolean)
    input_dtype ('float32'|'int32'|'bool'|'complex64'|'string')

Returns: SpatialDropout1D
Layers / Convolutional
tf.layers.conv1d (args) function Source

1D convolution layer (e.g., temporal convolution).

This layer creates a convolution kernel that is convolved with the layer input over a single spatial (or temporal) dimension to produce a tensor of outputs.

If use_bias is True, a bias vector is created and added to the outputs.

If activation is not null, it is applied to the outputs as well.

When using this layer as the first layer in a model, provide an inputShape argument Array or null.

For example, inputShape would be:

    [10, 128] for sequences of 10 vectors of 128-dimensional vectors
    [null, 128] for variable-length sequences of 128-dimensional vectors.

Parameters:

    args (Object)
    filters (number) The dimensionality of the output space (i.e. the number of filters in the convolution).
    kernelSize (number|number[]) The dimensions of the convolution window. If kernelSize is a number, the convolutional window will be square.
    strides (number|number[]) The strides of the convolution in each dimension. If strides is a number, strides in both dimensions are equal.

    Specifying any stride value != 1 is incompatible with specifying any dilationRate value != 1.
    padding ('valid'|'same'|'causal') Padding mode.
    dataFormat ('channelsFirst'|'channelsLast') Format of the data, which determines the ordering of the dimensions in the inputs.

    channels_last corresponds to inputs with shape (batch, ..., channels)

    channels_first corresponds to inputs with shape (batch, channels, ...).

    Defaults to channels_last.
    dilationRate (number|[number]|[number, number]|[number, number, number]) The dilation rate to use for the dilated convolution in each dimension. Should be an integer or array of two or three integers.

    Currently, specifying any dilationRate value != 1 is incompatible with specifying any strides value != 1.
    activation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Activation function of the layer.

    If you don't specify the activation, none is applied.
    useBias (boolean) Whether the layer uses a bias vector. Defaults to true.
    kernelInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the convolutional kernel weights matrix.
    biasInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the bias vector.
    kernelConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint for the convolutional kernel weights.
    biasConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint for the bias vector.
    kernelRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the kernel weights matrix.
    biasRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the bias vector.
    activityRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the activation.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Conv1D
tf.layers.conv2d (args) function Source

2D convolution layer (e.g. spatial convolution over images).

This layer creates a convolution kernel that is convolved with the layer input to produce a tensor of outputs.

If useBias is True, a bias vector is created and added to the outputs.

If activation is not null, it is applied to the outputs as well.

When using this layer as the first layer in a model, provide the keyword argument inputShape (Array of integers, does not include the sample axis), e.g. inputShape=[128, 128, 3] for 128x128 RGB pictures in dataFormat='channelsLast'.
Parameters:

    args (Object)
    filters (number) The dimensionality of the output space (i.e. the number of filters in the convolution).
    kernelSize (number|number[]) The dimensions of the convolution window. If kernelSize is a number, the convolutional window will be square.
    strides (number|number[]) The strides of the convolution in each dimension. If strides is a number, strides in both dimensions are equal.

    Specifying any stride value != 1 is incompatible with specifying any dilationRate value != 1.
    padding ('valid'|'same'|'causal') Padding mode.
    dataFormat ('channelsFirst'|'channelsLast') Format of the data, which determines the ordering of the dimensions in the inputs.

    channels_last corresponds to inputs with shape (batch, ..., channels)

    channels_first corresponds to inputs with shape (batch, channels, ...).

    Defaults to channels_last.
    dilationRate (number|[number]|[number, number]|[number, number, number]) The dilation rate to use for the dilated convolution in each dimension. Should be an integer or array of two or three integers.

    Currently, specifying any dilationRate value != 1 is incompatible with specifying any strides value != 1.
    activation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Activation function of the layer.

    If you don't specify the activation, none is applied.
    useBias (boolean) Whether the layer uses a bias vector. Defaults to true.
    kernelInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the convolutional kernel weights matrix.
    biasInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the bias vector.
    kernelConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint for the convolutional kernel weights.
    biasConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint for the bias vector.
    kernelRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the kernel weights matrix.
    biasRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the bias vector.
    activityRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the activation.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Conv2D
tf.layers.conv2dTranspose (args) function Source

Transposed convolutional layer (sometimes called Deconvolution).

The need for transposed convolutions generally arises from the desire to use a transformation going in the opposite direction of a normal convolution, i.e., from something that has the shape of the output of some convolution to something that has the shape of its input while maintaining a connectivity pattern that is compatible with said convolution.

When using this layer as the first layer in a model, provide the configuration inputShape (Array of integers, does not include the sample axis), e.g., inputShape: [128, 128, 3] for 128x128 RGB pictures in dataFormat: 'channelsLast'.

Input shape: 4D tensor with shape: [batch, channels, rows, cols] if dataFormat is 'channelsFirst'. or 4D tensor with shape [batch, rows, cols, channels] if dataFormat is 'channelsLast'.

Output shape: 4D tensor with shape: [batch, filters, newRows, newCols] if dataFormat is 'channelsFirst'. or 4D tensor with shape: [batch, newRows, newCols, filters] if dataFormat is 'channelsLast'.

References:

    A guide to convolution arithmetic for deep learning
    Deconvolutional Networks

Parameters:

    args (Object)
    filters (number) The dimensionality of the output space (i.e. the number of filters in the convolution).
    kernelSize (number|number[]) The dimensions of the convolution window. If kernelSize is a number, the convolutional window will be square.
    strides (number|number[]) The strides of the convolution in each dimension. If strides is a number, strides in both dimensions are equal.

    Specifying any stride value != 1 is incompatible with specifying any dilationRate value != 1.
    padding ('valid'|'same'|'causal') Padding mode.
    dataFormat ('channelsFirst'|'channelsLast') Format of the data, which determines the ordering of the dimensions in the inputs.

    channels_last corresponds to inputs with shape (batch, ..., channels)

    channels_first corresponds to inputs with shape (batch, channels, ...).

    Defaults to channels_last.
    dilationRate (number|[number]|[number, number]|[number, number, number]) The dilation rate to use for the dilated convolution in each dimension. Should be an integer or array of two or three integers.

    Currently, specifying any dilationRate value != 1 is incompatible with specifying any strides value != 1.
    activation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Activation function of the layer.

    If you don't specify the activation, none is applied.
    useBias (boolean) Whether the layer uses a bias vector. Defaults to true.
    kernelInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the convolutional kernel weights matrix.
    biasInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the bias vector.
    kernelConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint for the convolutional kernel weights.
    biasConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint for the bias vector.
    kernelRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the kernel weights matrix.
    biasRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the bias vector.
    activityRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the activation.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Conv2DTranspose
tf.layers.conv3d (args) function Source

3D convolution layer (e.g. spatial convolution over volumes).

This layer creates a convolution kernel that is convolved with the layer input to produce a tensor of outputs.

If useBias is True, a bias vector is created and added to the outputs.

If activation is not null, it is applied to the outputs as well.

When using this layer as the first layer in a model, provide the keyword argument inputShape (Array of integers, does not include the sample axis), e.g. inputShape=[128, 128, 128, 1] for 128x128x128 grayscale volumes in dataFormat='channelsLast'.
Parameters:

    args (Object)
    filters (number) The dimensionality of the output space (i.e. the number of filters in the convolution).
    kernelSize (number|number[]) The dimensions of the convolution window. If kernelSize is a number, the convolutional window will be square.
    strides (number|number[]) The strides of the convolution in each dimension. If strides is a number, strides in both dimensions are equal.

    Specifying any stride value != 1 is incompatible with specifying any dilationRate value != 1.
    padding ('valid'|'same'|'causal') Padding mode.
    dataFormat ('channelsFirst'|'channelsLast') Format of the data, which determines the ordering of the dimensions in the inputs.

    channels_last corresponds to inputs with shape (batch, ..., channels)

    channels_first corresponds to inputs with shape (batch, channels, ...).

    Defaults to channels_last.
    dilationRate (number|[number]|[number, number]|[number, number, number]) The dilation rate to use for the dilated convolution in each dimension. Should be an integer or array of two or three integers.

    Currently, specifying any dilationRate value != 1 is incompatible with specifying any strides value != 1.
    activation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Activation function of the layer.

    If you don't specify the activation, none is applied.
    useBias (boolean) Whether the layer uses a bias vector. Defaults to true.
    kernelInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the convolutional kernel weights matrix.
    biasInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the bias vector.
    kernelConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint for the convolutional kernel weights.
    biasConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint for the bias vector.
    kernelRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the kernel weights matrix.
    biasRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the bias vector.
    activityRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the activation.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Conv3D
tf.layers.cropping2D (args) function Source

Cropping layer for 2D input (e.g., image).

This layer can crop an input at the top, bottom, left and right side of an image tensor.

Input shape: 4D tensor with shape:

    If dataFormat is "channelsLast": [batch, rows, cols, channels]
    If data_format is "channels_first": [batch, channels, rows, cols].

Output shape: 4D with shape:

    If dataFormat is "channelsLast": [batch, croppedRows, croppedCols, channels] - If dataFormat is "channelsFirst": [batch, channels, croppedRows, croppedCols].

Examples


const model = tf.sequential();
model.add(tf.layers.cropping2D({cropping:[[2, 2], [2, 2]],
                                inputShape: [128, 128, 3]}));
//now output shape is [batch, 124, 124, 3]

Parameters:

    args (Object)
    cropping (number|[number, number]|[[number, number], [number, number]]) Dimension of the cropping along the width and the height.

        If integer: the same symmetric cropping is applied to width and height.
        If list of 2 integers: interpreted as two different symmetric cropping values for height and width: [symmetric_height_crop, symmetric_width_crop].
        If a list of 2 lists of 2 integers: interpreted as [[top_crop, bottom_crop], [left_crop, right_crop]]
    dataFormat ('channelsFirst'|'channelsLast') Format of the data, which determines the ordering of the dimensions in the inputs.

    channels_last corresponds to inputs with shape (batch, ..., channels)

    channels_first corresponds to inputs with shape (batch, channels, ...)

    Defaults to channels_last.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Cropping2D
tf.layers.depthwiseConv2d (args) function Source

Depthwise separable 2D convolution.

Depthwise Separable convolutions consists in performing just the first step in a depthwise spatial convolution (which acts on each input channel separately). The depthMultiplier argument controls how many output channels are generated per input channel in the depthwise step.
Parameters:

    args (Object)
    kernelSize (number|[number, number]) An integer or Array of 2 integers, specifying the width and height of the 2D convolution window. Can be a single integer to specify the same value for all spatial dimensions.
    depthMultiplier (number) The number of depthwise convolution output channels for each input channel. The total number of depthwise convolution output channels will be equal to filtersIn * depthMultiplier. Default: 1.
    depthwiseInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the depthwise kernel matrix. Default: GlorotNormal.
    depthwiseConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint for the depthwise kernel matrix.
    depthwiseRegularizer ('l1l2'|string|Regularizer) Regularizer function for the depthwise kernel matrix.
    strides (number|number[]) The strides of the convolution in each dimension. If strides is a number, strides in both dimensions are equal.

    Specifying any stride value != 1 is incompatible with specifying any dilationRate value != 1.
    padding ('valid'|'same'|'causal') Padding mode.
    dataFormat ('channelsFirst'|'channelsLast') Format of the data, which determines the ordering of the dimensions in the inputs.

    channels_last corresponds to inputs with shape (batch, ..., channels)

    channels_first corresponds to inputs with shape (batch, channels, ...).

    Defaults to channels_last.
    dilationRate (number|[number]|[number, number]|[number, number, number]) The dilation rate to use for the dilated convolution in each dimension. Should be an integer or array of two or three integers.

    Currently, specifying any dilationRate value != 1 is incompatible with specifying any strides value != 1.
    activation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Activation function of the layer.

    If you don't specify the activation, none is applied.
    useBias (boolean) Whether the layer uses a bias vector. Defaults to true.
    kernelInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the convolutional kernel weights matrix.
    biasInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the bias vector.
    kernelConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint for the convolutional kernel weights.
    biasConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint for the bias vector.
    kernelRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the kernel weights matrix.
    biasRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the bias vector.
    activityRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the activation.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: DepthwiseConv2D
tf.layers.separableConv2d (args) function Source

Depthwise separable 2D convolution.

Separable convolution consists of first performing a depthwise spatial convolution (which acts on each input channel separately) followed by a pointwise convolution which mixes together the resulting output channels. The depthMultiplier argument controls how many output channels are generated per input channel in the depthwise step.

Intuitively, separable convolutions can be understood as a way to factorize a convolution kernel into two smaller kernels, or as an extreme version of an Inception block.

Input shape: 4D tensor with shape: [batch, channels, rows, cols] if data_format='channelsFirst' or 4D tensor with shape: [batch, rows, cols, channels] if data_format='channelsLast'.

Output shape: 4D tensor with shape: [batch, filters, newRows, newCols] if data_format='channelsFirst' or 4D tensor with shape: [batch, newRows, newCols, filters] if data_format='channelsLast'. rows and cols values might have changed due to padding.
Parameters:

    args (Object)
    depthMultiplier (number) The number of depthwise convolution output channels for each input channel. The total number of depthwise convolution output channels will be equal to filtersIn * depthMultiplier. Default: 1.
    depthwiseInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the depthwise kernel matrix.
    pointwiseInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the pointwise kernel matrix.
    depthwiseRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the depthwise kernel matrix.
    pointwiseRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the pointwise kernel matrix.
    depthwiseConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the depthwise kernel matrix.
    pointwiseConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the pointwise kernel matrix.
    filters (number) The dimensionality of the output space (i.e. the number of filters in the convolution).
    kernelSize (number|number[]) The dimensions of the convolution window. If kernelSize is a number, the convolutional window will be square.
    strides (number|number[]) The strides of the convolution in each dimension. If strides is a number, strides in both dimensions are equal.

    Specifying any stride value != 1 is incompatible with specifying any dilationRate value != 1.
    padding ('valid'|'same'|'causal') Padding mode.
    dataFormat ('channelsFirst'|'channelsLast') Format of the data, which determines the ordering of the dimensions in the inputs.

    channels_last corresponds to inputs with shape (batch, ..., channels)

    channels_first corresponds to inputs with shape (batch, channels, ...).

    Defaults to channels_last.
    dilationRate (number|[number]|[number, number]|[number, number, number]) The dilation rate to use for the dilated convolution in each dimension. Should be an integer or array of two or three integers.

    Currently, specifying any dilationRate value != 1 is incompatible with specifying any strides value != 1.
    activation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Activation function of the layer.

    If you don't specify the activation, none is applied.
    useBias (boolean) Whether the layer uses a bias vector. Defaults to true.
    kernelInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the convolutional kernel weights matrix.
    biasInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the bias vector.
    kernelConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint for the convolutional kernel weights.
    biasConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint for the bias vector.
    kernelRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the kernel weights matrix.
    biasRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the bias vector.
    activityRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the activation.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: SeparableConv2D
tf.layers.upSampling2d (args) function Source

Upsampling layer for 2D inputs.

Repeats the rows and columns of the data by size[0] and size[1] respectively.

Input shape: 4D tensor with shape: - If dataFormat is "channelsLast": [batch, rows, cols, channels] - If dataFormat is "channelsFirst": [batch, channels, rows, cols]

Output shape: 4D tensor with shape: - If dataFormat is "channelsLast": [batch, upsampledRows, upsampledCols, channels] - If dataFormat is "channelsFirst": [batch, channels, upsampledRows, upsampledCols]
Parameters:

    args (Object)
    size (number[]) The upsampling factors for rows and columns.

    Defaults to [2, 2].
    dataFormat ('channelsFirst'|'channelsLast') Format of the data, which determines the ordering of the dimensions in the inputs.

    "channelsLast" corresponds to inputs with shape [batch, ..., channels]

    "channelsFirst" corresponds to inputs with shape [batch, channels, ...].

    Defaults to "channelsLast".
    interpolation (InterpolationFormat) The interpolation mechanism, one of "nearest" or "bilinear", default to "nearest".
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: UpSampling2D
Layers / Merge
tf.layers.add (args?) function Source

Layer that performs element-wise addition on an Array of inputs.

It takes as input a list of tensors, all of the same shape, and returns a single tensor (also of the same shape). The inputs are specified as an Array when the apply method of the Add layer instance is called. For example:

const input1 = tf.input({shape: [2, 2]});
const input2 = tf.input({shape: [2, 2]});
const addLayer = tf.layers.add();
const sum = addLayer.apply([input1, input2]);
console.log(JSON.stringify(sum.shape));
// You get [null, 2, 2], with the first dimension as the undetermined batch
// dimension.

Parameters:

    args (Object) Optional
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Add
tf.layers.average (args?) function Source

Layer that performs element-wise averaging on an Array of inputs.

It takes as input a list of tensors, all of the same shape, and returns a single tensor (also of the same shape). For example:

const input1 = tf.input({shape: [2, 2]});
const input2 = tf.input({shape: [2, 2]});
const averageLayer = tf.layers.average();
const average = averageLayer.apply([input1, input2]);
console.log(JSON.stringify(average.shape));
// You get [null, 2, 2], with the first dimension as the undetermined batch
// dimension.

Parameters:

    args (Object) Optional
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Average
tf.layers.concatenate (args?) function Source

Layer that concatenates an Array of inputs.

It takes a list of tensors, all of the same shape except for the concatenation axis, and returns a single tensor, the concatenation of all inputs. For example:

const input1 = tf.input({shape: [2, 2]});
const input2 = tf.input({shape: [2, 3]});
const concatLayer = tf.layers.concatenate();
const output = concatLayer.apply([input1, input2]);
console.log(JSON.stringify(output.shape));
// You get [null, 2, 5], with the first dimension as the undetermined batch
// dimension. The last dimension (5) is the result of concatenating the
// last dimensions of the inputs (2 and 3).

Parameters:

    args (Object) Optional
    axis (number) Axis along which to concatenate.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Concatenate
tf.layers.dot (args) function Source

Layer that computes a dot product between samples in two tensors.

E.g., if applied to a list of two tensors a and b both of shape [batchSize, n], the output will be a tensor of shape [batchSize, 1], where each entry at index [i, 0] will be the dot product between a[i, :] and b[i, :].

Example:

const dotLayer = tf.layers.dot({axes: -1});
const x1 = tf.tensor2d([[10, 20], [30, 40]]);
const x2 = tf.tensor2d([[-1, -2], [-3, -4]]);

// Invoke the layer's apply() method in eager (imperative) mode.
const y = dotLayer.apply([x1, x2]);
y.print();

Parameters:

    args (Object)
    axes (number|[number, number]) Axis or axes along which the dot product will be taken.

    Integer or an Array of integers.
    normalize (boolean) Whether to L2-normalize samples along the dot product axis before taking the dot product.

    If set to true, the output of the dot product is the cosine proximity between the two samples.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Dot
tf.layers.maximum (args?) function Source

Layer that computes the element-wise maximum of an Array of inputs.

It takes as input a list of tensors, all of the same shape, and returns a single tensor (also of the same shape). For example:

const input1 = tf.input({shape: [2, 2]});
const input2 = tf.input({shape: [2, 2]});
const maxLayer = tf.layers.maximum();
const max = maxLayer.apply([input1, input2]);
console.log(JSON.stringify(max.shape));
// You get [null, 2, 2], with the first dimension as the undetermined batch
// dimension.

Parameters:

    args (Object) Optional
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Maximum
tf.layers.minimum (args?) function Source

Layer that computes the element-wise minimum of an Array of inputs.

It takes as input a list of tensors, all of the same shape, and returns a single tensor (also of the same shape). For example:

const input1 = tf.input({shape: [2, 2]});
const input2 = tf.input({shape: [2, 2]});
const minLayer = tf.layers.minimum();
const min = minLayer.apply([input1, input2]);
console.log(JSON.stringify(min.shape));
// You get [null, 2, 2], with the first dimension as the undetermined batch
// dimension.

Parameters:

    args (Object) Optional
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Minimum
tf.layers.multiply (args?) function Source

Layer that multiplies (element-wise) an Array of inputs.

It takes as input an Array of tensors, all of the same shape, and returns a single tensor (also of the same shape). For example:

const input1 = tf.input({shape: [2, 2]});
const input2 = tf.input({shape: [2, 2]});
const input3 = tf.input({shape: [2, 2]});
const multiplyLayer = tf.layers.multiply();
const product = multiplyLayer.apply([input1, input2, input3]);
console.log(product.shape);
// You get [null, 2, 2], with the first dimension as the undetermined batch
// dimension.

Parameters:

    args (Object) Optional
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Multiply
Layers / Normalization
tf.layers.batchNormalization (args?) function Source

Batch normalization layer (Ioffe and Szegedy, 2014).

Normalize the activations of the previous layer at each batch, i.e. applies a transformation that maintains the mean activation close to 0 and the activation standard deviation close to 1.

Input shape: Arbitrary. Use the keyword argument inputShape (Array of integers, does not include the sample axis) when calling the constructor of this class, if this layer is used as a first layer in a model.

Output shape: Same shape as input.

References:

    Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift

Parameters:

    args (Object) Optional
    axis (number) The integer axis that should be normalized (typically the features axis). Defaults to -1.

    For instance, after a Conv2D layer with data_format="channels_first", set axis=1 in batchNormalization.
    momentum (number) Momentum of the moving average. Defaults to 0.99.
    epsilon (number) Small float added to the variance to avoid dividing by zero. Defaults to 1e-3.
    center (boolean) If true, add offset of beta to normalized tensor. If false, beta is ignored. Defaults to true.
    scale (boolean) If true, multiply by gamma. If false, gamma is not used. When the next layer is linear (also e.g. nn.relu), this can be disabled since the scaling will be done by the next layer. Defaults to true.
    betaInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the beta weight. Defaults to 'zeros'.
    gammaInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the gamma weight. Defaults to ones.
    movingMeanInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the moving mean. Defaults to zeros
    movingVarianceInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the moving variance. Defaults to 'Ones'.
    betaConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint for the beta weight.
    gammaConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint for gamma weight.
    betaRegularizer ('l1l2'|string|Regularizer) Regularizer for the beta weight.
    gammaRegularizer ('l1l2'|string|Regularizer) Regularizer for the gamma weight.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: BatchNormalization
tf.layers.layerNormalization (args?) function Source

Layer-normalization layer (Ba et al., 2016).

Normalizes the activations of the previous layer for each given example in a batch independently, instead of across a batch like in batchNormalization. In other words, this layer applies a transformation that maintains the mean activation within each example close to 0 and activation variance close to 1.

Input shape: Arbitrary. Use the argument inputShape when using this layer as the first layer in a model.

Output shape: Same as input.

References:

    Layer Normalization

Parameters:

    args (Object) Optional
    axis (number|number[]) The axis or axes that should be normalized (typically, the feature axis). Defaults to -1 (the last axis).
    epsilon (number) A small positive float added to variance to avoid division by zero. Defaults to 1e-3.
    center (boolean) If true, add offset of beta to normalized tensor. If false, beta is ignored. Default: true.
    scale (boolean) If true, multiply output by gamma. If false, gamma is not used. When the next layer is linear, this can be disabled since scaling will be done by the next layer. Default: true.
    betaInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the beta weight. Default: 'zeros'.
    gammaInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the gamma weight. Default: 'ones'.
    betaRegularizer ('l1l2'|string|Regularizer) Regularizer for the beta weight.
    gammaRegularizer ('l1l2'|string|Regularizer) Regularizer for the gamma weight.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: LayerNormalization
Layers / Pooling
tf.layers.averagePooling1d (args) function Source

Average pooling operation for spatial data.

Input shape: [batchSize, inLength, channels]

Output shape: [batchSize, pooledLength, channels]

tf.avgPool1d is an alias.
Parameters:

    args (Object)
    poolSize (number|[number]) Size of the window to pool over, should be an integer.
    strides (number|[number]) Period at which to sample the pooled values.

    If null, defaults to poolSize.
    padding ('valid'|'same'|'causal') How to fill in data that's not an integer multiple of poolSize.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: AveragePooling1D
tf.layers.averagePooling2d (args) function Source

Average pooling operation for spatial data.

Input shape:

    If dataFormat === CHANNEL_LAST: 4D tensor with shape: [batchSize, rows, cols, channels]
    If dataFormat === CHANNEL_FIRST: 4D tensor with shape: [batchSize, channels, rows, cols]

Output shape

    If dataFormat === CHANNEL_LAST: 4D tensor with shape: [batchSize, pooledRows, pooledCols, channels]
    If dataFormat === CHANNEL_FIRST: 4D tensor with shape: [batchSize, channels, pooledRows, pooledCols]

tf.avgPool2d is an alias.
Parameters:

    args (Object)
    poolSize (number|[number, number]) Factors by which to downscale in each dimension [vertical, horizontal]. Expects an integer or an array of 2 integers.

    For example, [2, 2] will halve the input in both spatial dimensions. If only one integer is specified, the same window length will be used for both dimensions.
    strides (number|[number, number]) The size of the stride in each dimension of the pooling window. Expects an integer or an array of 2 integers. Integer, tuple of 2 integers, or None.

    If null, defaults to poolSize.
    padding ('valid'|'same'|'causal') The padding type to use for the pooling layer.
    dataFormat ('channelsFirst'|'channelsLast') The data format to use for the pooling layer.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: AveragePooling2D
tf.layers.averagePooling3d (args) function Source

Average pooling operation for 3D data.

Input shape

    If dataFormat === channelsLast: 5D tensor with shape: [batchSize, depths, rows, cols, channels]
    If dataFormat === channelsFirst: 4D tensor with shape: [batchSize, channels, depths, rows, cols]

Output shape

    If dataFormat=channelsLast: 5D tensor with shape: [batchSize, pooledDepths, pooledRows, pooledCols, channels]
    If dataFormat=channelsFirst: 5D tensor with shape: [batchSize, channels, pooledDepths, pooledRows, pooledCols]

Parameters:

    args (Object)
    poolSize (number|[number, number, number]) Factors by which to downscale in each dimension [depth, height, width]. Expects an integer or an array of 3 integers.

    For example, [2, 2, 2] will halve the input in three dimensions. If only one integer is specified, the same window length will be used for all dimensions.
    strides (number|[number, number, number]) The size of the stride in each dimension of the pooling window. Expects an integer or an array of 3 integers. Integer, tuple of 3 integers, or None.

    If null, defaults to poolSize.
    padding ('valid'|'same'|'causal') The padding type to use for the pooling layer.
    dataFormat ('channelsFirst'|'channelsLast') The data format to use for the pooling layer.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: AveragePooling3D
tf.layers.globalAveragePooling1d (args?) function Source

Global average pooling operation for temporal data.

Input Shape: 3D tensor with shape: [batchSize, steps, features].

Output Shape: 2D tensor with shape: [batchSize, features].
Parameters:

    args (Object) Optional
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: GlobalAveragePooling1D
tf.layers.globalAveragePooling2d (args) function Source

Global average pooling operation for spatial data.

Input shape:

    If dataFormat is CHANNEL_LAST: 4D tensor with shape: [batchSize, rows, cols, channels].
    If dataFormat is CHANNEL_FIRST: 4D tensor with shape: [batchSize, channels, rows, cols].

Output shape: 2D tensor with shape: [batchSize, channels].
Parameters:

    args (Object)
    dataFormat ('channelsFirst'|'channelsLast') One of CHANNEL_LAST (default) or CHANNEL_FIRST.

    The ordering of the dimensions in the inputs. CHANNEL_LAST corresponds to inputs with shape [batch, height, width, channels] while CHANNEL_FIRST corresponds to inputs with shape [batch, channels, height, width].
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: GlobalAveragePooling2D
tf.layers.globalMaxPooling1d (args?) function Source

Global max pooling operation for temporal data.

Input Shape: 3D tensor with shape: [batchSize, steps, features].

Output Shape: 2D tensor with shape: [batchSize, features].
Parameters:

    args (Object) Optional
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: GlobalMaxPooling1D
tf.layers.globalMaxPooling2d (args) function Source

Global max pooling operation for spatial data.

Input shape:

    If dataFormat is CHANNEL_LAST: 4D tensor with shape: [batchSize, rows, cols, channels].
    If dataFormat is CHANNEL_FIRST: 4D tensor with shape: [batchSize, channels, rows, cols].

Output shape: 2D tensor with shape: [batchSize, channels].
Parameters:

    args (Object)
    dataFormat ('channelsFirst'|'channelsLast') One of CHANNEL_LAST (default) or CHANNEL_FIRST.

    The ordering of the dimensions in the inputs. CHANNEL_LAST corresponds to inputs with shape [batch, height, width, channels] while CHANNEL_FIRST corresponds to inputs with shape [batch, channels, height, width].
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: GlobalMaxPooling2D
tf.layers.maxPooling1d (args) function Source

Max pooling operation for temporal data.

Input shape: [batchSize, inLength, channels]

Output shape: [batchSize, pooledLength, channels]
Parameters:

    args (Object)
    poolSize (number|[number]) Size of the window to pool over, should be an integer.
    strides (number|[number]) Period at which to sample the pooled values.

    If null, defaults to poolSize.
    padding ('valid'|'same'|'causal') How to fill in data that's not an integer multiple of poolSize.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: MaxPooling1D
tf.layers.maxPooling2d (args) function Source

Max pooling operation for spatial data.

Input shape

    If dataFormat === CHANNEL_LAST: 4D tensor with shape: [batchSize, rows, cols, channels]
    If dataFormat === CHANNEL_FIRST: 4D tensor with shape: [batchSize, channels, rows, cols]

Output shape

    If dataFormat=CHANNEL_LAST: 4D tensor with shape: [batchSize, pooledRows, pooledCols, channels]
    If dataFormat=CHANNEL_FIRST: 4D tensor with shape: [batchSize, channels, pooledRows, pooledCols]

Parameters:

    args (Object)
    poolSize (number|[number, number]) Factors by which to downscale in each dimension [vertical, horizontal]. Expects an integer or an array of 2 integers.

    For example, [2, 2] will halve the input in both spatial dimensions. If only one integer is specified, the same window length will be used for both dimensions.
    strides (number|[number, number]) The size of the stride in each dimension of the pooling window. Expects an integer or an array of 2 integers. Integer, tuple of 2 integers, or None.

    If null, defaults to poolSize.
    padding ('valid'|'same'|'causal') The padding type to use for the pooling layer.
    dataFormat ('channelsFirst'|'channelsLast') The data format to use for the pooling layer.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: MaxPooling2D
tf.layers.maxPooling3d (args) function Source

Max pooling operation for 3D data.

Input shape

    If dataFormat === channelsLast: 5D tensor with shape: [batchSize, depths, rows, cols, channels]
    If dataFormat === channelsFirst: 5D tensor with shape: [batchSize, channels, depths, rows, cols]

Output shape

    If dataFormat=channelsLast: 5D tensor with shape: [batchSize, pooledDepths, pooledRows, pooledCols, channels]
    If dataFormat=channelsFirst: 5D tensor with shape: [batchSize, channels, pooledDepths, pooledRows, pooledCols]

Parameters:

    args (Object)
    poolSize (number|[number, number, number]) Factors by which to downscale in each dimension [depth, height, width]. Expects an integer or an array of 3 integers.

    For example, [2, 2, 2] will halve the input in three dimensions. If only one integer is specified, the same window length will be used for all dimensions.
    strides (number|[number, number, number]) The size of the stride in each dimension of the pooling window. Expects an integer or an array of 3 integers. Integer, tuple of 3 integers, or None.

    If null, defaults to poolSize.
    padding ('valid'|'same'|'causal') The padding type to use for the pooling layer.
    dataFormat ('channelsFirst'|'channelsLast') The data format to use for the pooling layer.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: MaxPooling3D
Layers / Recurrent
tf.layers.convLstm2d (args) function Source

Convolutional LSTM layer - Xingjian Shi 2015.

This is a ConvRNN2D layer consisting of one ConvLSTM2DCell. However, unlike the underlying ConvLSTM2DCell, the apply method of ConvLSTM2D operates on a sequence of inputs. The shape of the input (not including the first, batch dimension) needs to be 4-D, with the first dimension being time steps. For example:

const filters = 3;
const kernelSize = 3;

const batchSize = 4;
const sequenceLength = 2;
const size = 5;
const channels = 3;

const inputShape = [batchSize, sequenceLength, size, size, channels];
const input = tf.ones(inputShape);

const layer = tf.layers.convLstm2d({filters, kernelSize});

const output = layer.apply(input);

Parameters:

    args (Object)
    activation (tf.any()) Activation function to use.

    Defaults to hyperbolic tangent (tanh)

    If you pass null, no activation will be applied.
    useBias (tf.any()) Whether the layer uses a bias vector.
    kernelInitializer (tf.any()) Initializer for the kernel weights matrix, used for the linear transformation of the inputs.
    recurrentInitializer (tf.any()) Initializer for the recurrentKernel weights matrix, used for linear transformation of the recurrent state.
    biasInitializer (tf.any()) Initializer for the bias vector.
    kernelRegularizer (tf.any()) Regularizer function applied to the kernel weights matrix.
    recurrentRegularizer (tf.any()) Regularizer function applied to the recurrentKernel weights matrix.
    biasRegularizer (tf.any()) Regularizer function applied to the bias vector.
    kernelConstraint (tf.any()) Constraint function applied to the kernel weights matrix.
    recurrentConstraint (tf.any()) Constraint function applied to the recurrentKernel weights matrix.
    biasConstraint (tf.any()) Constraint function applied to the bias vector.
    dropout (tf.any()) Number between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs.
    recurrentDropout (tf.any()) Number between 0 and 1. Fraction of the units to drop for the linear transformation of the recurrent state.
    dropoutFunc (tf.any()) This is added for test DI purpose.
    inputShape (tf.any()) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape (tf.any()) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (tf.any()) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype (tf.any()) The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (tf.any()) Name for this layer.
    trainable (tf.any()) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.any()) Initial weight values of the layer.
    inputDType (tf.any()) Legacy support. Do not use for new code.
    recurrentActivation (tf.any()) Activation function to use for the recurrent step.

    Defaults to hard sigmoid (hardSigmoid).

    If null, no activation is applied.
    unitForgetBias (tf.any()) If true, add 1 to the bias of the forget gate at initialization. Setting it to true will also force biasInitializer = 'zeros'. This is recommended in Jozefowicz et al.
    implementation (tf.any()) Implementation mode, either 1 or 2. Mode 1 will structure its operations as a larger number of smaller dot products and additions, whereas mode 2 will batch them into fewer, larger operations. These modes will have different performance profiles on different hardware and for different applications.

    Note: For superior performance, TensorFlow.js always uses implementation 2, regardless of the actual value of this config field.
    returnSequences (tf.any()) Whether to return the last output in the output sequence, or the full sequence.
    returnState (tf.any()) Whether to return the last state in addition to the output.
    goBackwards (tf.any()) If true, process the input sequence backwards and return the reversed sequence (default: false).
    stateful (tf.any()) If true, the last state for each sample at index i in a batch will be used as initial state of the sample of index i in the following batch (default: false).

    You can set RNN layers to be "stateful", which means that the states computed for the samples in one batch will be reused as initial states for the samples in the next batch. This assumes a one-to-one mapping between samples in different successive batches.

    To enable "statefulness":
        specify stateful: true in the layer constructor.
        specify a fixed batch size for your model, by passing
            if sequential model: batchInputShape: [...] to the first layer in your model.
            else for functional model with 1 or more Input layers: batchShape: [...] to all the first layers in your model. This is the expected shape of your inputs including the batch size. It should be a tuple of integers, e.g., [32, 10, 100].
        specify shuffle: false when calling LayersModel.fit().

    To reset the state of your model, call resetStates() on either the specific layer or on the entire model.
    unroll (tf.any()) If true, the network will be unrolled, else a symbolic loop will be used. Unrolling can speed up a RNN, although it tends to be more memory-intensive. Unrolling is only suitable for short sequences (default: false). Porting Note: tfjs-layers has an imperative backend. RNNs are executed with normal TypeScript control flow. Hence this property is inapplicable and ignored in tfjs-layers.
    inputDim (tf.any()) Dimensionality of the input (integer). This option (or alternatively, the option inputShape) is required when this layer is used as the first layer in a model.
    inputLength (tf.any()) Length of the input sequences, to be specified when it is constant. This argument is required if you are going to connect Flatten then Dense layers upstream (without it, the shape of the dense outputs cannot be computed). Note that if the recurrent layer is not the first layer in your model, you would need to specify the input length at the level of the first layer (e.g., via the inputShape option).
    cell (tf.RNNCell|tf.RNNCell[]) A RNN cell instance. A RNN cell is a class that has:

        a call() method, which takes [Tensor, Tensor] as the first input argument. The first item is the input at time t, and second item is the cell state at time t. The call() method returns [outputAtT, statesAtTPlus1]. The call() method of the cell can also take the argument constants, see section "Note on passing external constants" below. Porting Node: PyKeras overrides the call() signature of RNN cells, which are Layer subtypes, to accept two arguments. tfjs-layers does not do such overriding. Instead we preserve the call() signature, which due to its Tensor|Tensor[] argument and return value is flexible enough to handle the inputs and states.
        a stateSize attribute. This can be a single integer (single state) in which case it is the size of the recurrent state (which should be the same as the size of the cell output). This can also be an Array of integers (one size per state). In this case, the first entry (stateSize[0]) should be the same as the size of the cell output. It is also possible for cell to be a list of RNN cell instances, in which case the cells get stacked on after the other in the RNN, implementing an efficient stacked RNN.
    filters (number) The dimensionality of the output space (i.e. the number of filters in the convolution).
    kernelSize (number|number[]) The dimensions of the convolution window. If kernelSize is a number, the convolutional window will be square.
    strides (number|number[]) The strides of the convolution in each dimension. If strides is a number, strides in both dimensions are equal.

    Specifying any stride value != 1 is incompatible with specifying any dilationRate value != 1.
    padding ('valid'|'same'|'causal') Padding mode.
    dataFormat ('channelsFirst'|'channelsLast') Format of the data, which determines the ordering of the dimensions in the inputs.

    channels_last corresponds to inputs with shape (batch, ..., channels)

    channels_first corresponds to inputs with shape (batch, channels, ...).

    Defaults to channels_last.
    dilationRate (number|[number]|[number, number]) The dilation rate to use for the dilated convolution in each dimension. Should be an integer or array of two or three integers.

    Currently, specifying any dilationRate value != 1 is incompatible with specifying any strides value != 1.

Returns: ConvLSTM2D
tf.layers.convLstm2dCell (args) function Source

Cell class for ConvLSTM2D.

ConvLSTM2DCell is distinct from the ConvRNN2D subclass ConvLSTM2D in that its call method takes the input data of only a single time step and returns the cell's output at the time step, while ConvLSTM2D takes the input data over a number of time steps. For example:

const filters = 3;
const kernelSize = 3;

const sequenceLength = 1;
const size = 5;
const channels = 3;

const inputShape = [sequenceLength, size, size, channels];
const input = tf.ones(inputShape);

const cell = tf.layers.convLstm2dCell({filters, kernelSize});

cell.build(input.shape);

const outputSize = size - kernelSize + 1;
const outShape = [sequenceLength, outputSize, outputSize, filters];

const initialH = tf.zeros(outShape);
const initialC = tf.zeros(outShape);

const [o, h, c] = cell.call([input, initialH, initialC], {});

Parameters:

    args (Object)
    activation (tf.any()) Activation function to use. Default: hyperbolic tangent ('tanh'). If you pass null, 'linear' activation will be applied.
    useBias (tf.any()) Whether the layer uses a bias vector.
    kernelInitializer (tf.any()) Initializer for the kernel weights matrix, used for the linear transformation of the inputs.
    recurrentInitializer (tf.any()) Initializer for the recurrentKernel weights matrix, used for linear transformation of the recurrent state.
    biasInitializer (tf.any()) Initializer for the bias vector.
    kernelRegularizer (tf.any()) Regularizer function applied to the kernel weights matrix.
    recurrentRegularizer (tf.any()) Regularizer function applied to the recurrent_kernel weights matrix.
    biasRegularizer (tf.any()) Regularizer function applied to the bias vector.
    kernelConstraint (tf.any()) Constraint function applied to the kernel weights matrix.
    recurrentConstraint (tf.any()) Constraint function applied to the recurrentKernel weights matrix.
    biasConstraint (tf.any()) Constraint function applied to the bias vector.
    dropout (tf.any()) Float number between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs.
    recurrentDropout (tf.any()) Float number between 0 and 1. Fraction of the units to drop for the linear transformation of the recurrent state.
    dropoutFunc (tf.any()) This is added for test DI purpose.
    inputShape (tf.any()) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape (tf.any()) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (tf.any()) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype (tf.any()) The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (tf.any()) Name for this layer.
    trainable (tf.any()) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.any()) Initial weight values of the layer.
    inputDType (tf.any()) Legacy support. Do not use for new code.
    recurrentActivation (tf.any()) Activation function to use for the recurrent step.

    Defaults to hard sigmoid (hardSigmoid).

    If null, no activation is applied.
    unitForgetBias (tf.any()) If true, add 1 to the bias of the forget gate at initialization. Setting it to true will also force biasInitializer = 'zeros'. This is recommended in Jozefowicz et al.
    implementation (tf.any()) Implementation mode, either 1 or 2.

    Mode 1 will structure its operations as a larger number of smaller dot products and additions.

    Mode 2 will batch them into fewer, larger operations. These modes will have different performance profiles on different hardware and for different applications.

    Note: For superior performance, TensorFlow.js always uses implementation 2, regardless of the actual value of this configuration field.
    filters (number) The dimensionality of the output space (i.e. the number of filters in the convolution).
    kernelSize (number|number[]) The dimensions of the convolution window. If kernelSize is a number, the convolutional window will be square.
    strides (number|number[]) The strides of the convolution in each dimension. If strides is a number, strides in both dimensions are equal.

    Specifying any stride value != 1 is incompatible with specifying any dilationRate value != 1.
    padding ('valid'|'same'|'causal') Padding mode.
    dataFormat ('channelsFirst'|'channelsLast') Format of the data, which determines the ordering of the dimensions in the inputs.

    channels_last corresponds to inputs with shape (batch, ..., channels)

    channels_first corresponds to inputs with shape (batch, channels, ...).

    Defaults to channels_last.
    dilationRate (number|[number]|[number, number]) The dilation rate to use for the dilated convolution in each dimension. Should be an integer or array of two or three integers.

    Currently, specifying any dilationRate value != 1 is incompatible with specifying any strides value != 1.

Returns: ConvLSTM2DCell
tf.layers.gru (args) function Source

Gated Recurrent Unit - Cho et al. 2014.

This is an RNN layer consisting of one GRUCell. However, unlike the underlying GRUCell, the apply method of SimpleRNN operates on a sequence of inputs. The shape of the input (not including the first, batch dimension) needs to be at least 2-D, with the first dimension being time steps. For example:

const rnn = tf.layers.gru({units: 8, returnSequences: true});

// Create an input with 10 time steps.
const input = tf.input({shape: [10, 20]});
const output = rnn.apply(input);

console.log(JSON.stringify(output.shape));
// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the
// same as the sequence length of `input`, due to `returnSequences`: `true`;
// 3rd dimension is the `GRUCell`'s number of units.

Parameters:

    args (Object)
    recurrentActivation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Activation function to use for the recurrent step.

    Defaults to hard sigmoid (hardSigmoid).

    If null, no activation is applied.
    implementation (number) Implementation mode, either 1 or 2.

    Mode 1 will structure its operations as a larger number of smaller dot products and additions.

    Mode 2 will batch them into fewer, larger operations. These modes will have different performance profiles on different hardware and for different applications.

    Note: For superior performance, TensorFlow.js always uses implementation 2, regardless of the actual value of this configuration field.
    units (number) Positive integer, dimensionality of the output space.
    activation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Activation function to use.

    Defaults to hyperbolic tangent (tanh)

    If you pass null, no activation will be applied.
    useBias (boolean) Whether the layer uses a bias vector.
    kernelInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the kernel weights matrix, used for the linear transformation of the inputs.
    recurrentInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the recurrentKernel weights matrix, used for linear transformation of the recurrent state.
    biasInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the bias vector.
    kernelRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the kernel weights matrix.
    recurrentRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the recurrentKernel weights matrix.
    biasRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the bias vector.
    kernelConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the kernel weights matrix.
    recurrentConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the recurrentKernel weights matrix.
    biasConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the bias vector.
    dropout (number) Number between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs.
    recurrentDropout (number) Number between 0 and 1. Fraction of the units to drop for the linear transformation of the recurrent state.
    dropoutFunc (Function) This is added for test DI purpose.
    cell (tf.RNNCell|tf.RNNCell[]) A RNN cell instance. A RNN cell is a class that has:

        a call() method, which takes [Tensor, Tensor] as the first input argument. The first item is the input at time t, and second item is the cell state at time t. The call() method returns [outputAtT, statesAtTPlus1]. The call() method of the cell can also take the argument constants, see section "Note on passing external constants" below. Porting Node: PyKeras overrides the call() signature of RNN cells, which are Layer subtypes, to accept two arguments. tfjs-layers does not do such overriding. Instead we preserve the call() signature, which due to its Tensor|Tensor[] argument and return value is flexible enough to handle the inputs and states.
        a stateSize attribute. This can be a single integer (single state) in which case it is the size of the recurrent state (which should be the same as the size of the cell output). This can also be an Array of integers (one size per state). In this case, the first entry (stateSize[0]) should be the same as the size of the cell output. It is also possible for cell to be a list of RNN cell instances, in which case the cells get stacked on after the other in the RNN, implementing an efficient stacked RNN.
    returnSequences (boolean) Whether to return the last output in the output sequence, or the full sequence.
    returnState (boolean) Whether to return the last state in addition to the output.
    goBackwards (boolean) If true, process the input sequence backwards and return the reversed sequence (default: false).
    stateful (boolean) If true, the last state for each sample at index i in a batch will be used as initial state of the sample of index i in the following batch (default: false).

    You can set RNN layers to be "stateful", which means that the states computed for the samples in one batch will be reused as initial states for the samples in the next batch. This assumes a one-to-one mapping between samples in different successive batches.

    To enable "statefulness":
        specify stateful: true in the layer constructor.
        specify a fixed batch size for your model, by passing
            if sequential model: batchInputShape: [...] to the first layer in your model.
            else for functional model with 1 or more Input layers: batchShape: [...] to all the first layers in your model. This is the expected shape of your inputs including the batch size. It should be a tuple of integers, e.g., [32, 10, 100].
        specify shuffle: false when calling LayersModel.fit().

    To reset the state of your model, call resetStates() on either the specific layer or on the entire model.
    unroll (boolean) If true, the network will be unrolled, else a symbolic loop will be used. Unrolling can speed up a RNN, although it tends to be more memory-intensive. Unrolling is only suitable for short sequences (default: false). Porting Note: tfjs-layers has an imperative backend. RNNs are executed with normal TypeScript control flow. Hence this property is inapplicable and ignored in tfjs-layers.
    inputDim (number) Dimensionality of the input (integer). This option (or alternatively, the option inputShape) is required when this layer is used as the first layer in a model.
    inputLength (number) Length of the input sequences, to be specified when it is constant. This argument is required if you are going to connect Flatten then Dense layers upstream (without it, the shape of the dense outputs cannot be computed). Note that if the recurrent layer is not the first layer in your model, you would need to specify the input length at the level of the first layer (e.g., via the inputShape option).
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: GRU
tf.layers.gruCell (args) function Source

Cell class for GRU.

GRUCell is distinct from the RNN subclass GRU in that its apply method takes the input data of only a single time step and returns the cell's output at the time step, while GRU takes the input data over a number of time steps. For example:

const cell = tf.layers.gruCell({units: 2});
const input = tf.input({shape: [10]});
const output = cell.apply(input);

console.log(JSON.stringify(output.shape));
// [null, 10]: This is the cell's output at a single time step. The 1st
// dimension is the unknown batch size.

Instance(s) of GRUCell can be used to construct RNN layers. The most typical use of this workflow is to combine a number of cells into a stacked RNN cell (i.e., StackedRNNCell internally) and use it to create an RNN. For example:

const cells = [
   tf.layers.gruCell({units: 4}),
   tf.layers.gruCell({units: 8}),
];
const rnn = tf.layers.rnn({cell: cells, returnSequences: true});

// Create an input with 10 time steps and a length-20 vector at each step.
const input = tf.input({shape: [10, 20]});
const output = rnn.apply(input);

console.log(JSON.stringify(output.shape));
// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the
// same as the sequence length of `input`, due to `returnSequences`: `true`;
// 3rd dimension is the last `gruCell`'s number of units.

To create an RNN consisting of only one GRUCell, use the tf.layers.gru().
Parameters:

    args (Object)
    recurrentActivation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Activation function to use for the recurrent step.

    Defaults to hard sigmoid (hardSigmoid).

    If null, no activation is applied.
    implementation (number) Implementation mode, either 1 or 2.

    Mode 1 will structure its operations as a larger number of smaller dot products and additions.

    Mode 2 will batch them into fewer, larger operations. These modes will have different performance profiles on different hardware and for different applications.

    Note: For superior performance, TensorFlow.js always uses implementation 2, regardless of the actual value of this configuration field.
    resetAfter (boolean) GRU convention (whether to apply reset gate after or before matrix multiplication). false = "before", true = "after" (only false is supported).
    units (number) units: Positive integer, dimensionality of the output space.
    activation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Activation function to use. Default: hyperbolic tangent ('tanh'). If you pass null, 'linear' activation will be applied.
    useBias (boolean) Whether the layer uses a bias vector.
    kernelInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the kernel weights matrix, used for the linear transformation of the inputs.
    recurrentInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the recurrentKernel weights matrix, used for linear transformation of the recurrent state.
    biasInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the bias vector.
    kernelRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the kernel weights matrix.
    recurrentRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the recurrent_kernel weights matrix.
    biasRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the bias vector.
    kernelConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the kernel weights matrix.
    recurrentConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the recurrentKernel weights matrix.
    biasConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the bias vector.
    dropout (number) Float number between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs.
    recurrentDropout (number) Float number between 0 and 1. Fraction of the units to drop for the linear transformation of the recurrent state.
    dropoutFunc (Function) This is added for test DI purpose.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: GRUCell
tf.layers.lstm (args) function Source

Long-Short Term Memory layer - Hochreiter 1997.

This is an RNN layer consisting of one LSTMCell. However, unlike the underlying LSTMCell, the apply method of LSTM operates on a sequence of inputs. The shape of the input (not including the first, batch dimension) needs to be at least 2-D, with the first dimension being time steps. For example:

const lstm = tf.layers.lstm({units: 8, returnSequences: true});

// Create an input with 10 time steps.
const input = tf.input({shape: [10, 20]});
const output = lstm.apply(input);

console.log(JSON.stringify(output.shape));
// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the
// same as the sequence length of `input`, due to `returnSequences`: `true`;
// 3rd dimension is the `LSTMCell`'s number of units.

Parameters:

    args (Object)
    recurrentActivation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Activation function to use for the recurrent step.

    Defaults to hard sigmoid (hardSigmoid).

    If null, no activation is applied.
    unitForgetBias (boolean) If true, add 1 to the bias of the forget gate at initialization. Setting it to true will also force biasInitializer = 'zeros'. This is recommended in Jozefowicz et al.
    implementation (number) Implementation mode, either 1 or 2. Mode 1 will structure its operations as a larger number of smaller dot products and additions, whereas mode 2 will batch them into fewer, larger operations. These modes will have different performance profiles on different hardware and for different applications.

    Note: For superior performance, TensorFlow.js always uses implementation 2, regardless of the actual value of this config field.
    units (number) Positive integer, dimensionality of the output space.
    activation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Activation function to use.

    Defaults to hyperbolic tangent (tanh)

    If you pass null, no activation will be applied.
    useBias (boolean) Whether the layer uses a bias vector.
    kernelInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the kernel weights matrix, used for the linear transformation of the inputs.
    recurrentInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the recurrentKernel weights matrix, used for linear transformation of the recurrent state.
    biasInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the bias vector.
    kernelRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the kernel weights matrix.
    recurrentRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the recurrentKernel weights matrix.
    biasRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the bias vector.
    kernelConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the kernel weights matrix.
    recurrentConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the recurrentKernel weights matrix.
    biasConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the bias vector.
    dropout (number) Number between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs.
    recurrentDropout (number) Number between 0 and 1. Fraction of the units to drop for the linear transformation of the recurrent state.
    dropoutFunc (Function) This is added for test DI purpose.
    cell (tf.RNNCell|tf.RNNCell[]) A RNN cell instance. A RNN cell is a class that has:

        a call() method, which takes [Tensor, Tensor] as the first input argument. The first item is the input at time t, and second item is the cell state at time t. The call() method returns [outputAtT, statesAtTPlus1]. The call() method of the cell can also take the argument constants, see section "Note on passing external constants" below. Porting Node: PyKeras overrides the call() signature of RNN cells, which are Layer subtypes, to accept two arguments. tfjs-layers does not do such overriding. Instead we preserve the call() signature, which due to its Tensor|Tensor[] argument and return value is flexible enough to handle the inputs and states.
        a stateSize attribute. This can be a single integer (single state) in which case it is the size of the recurrent state (which should be the same as the size of the cell output). This can also be an Array of integers (one size per state). In this case, the first entry (stateSize[0]) should be the same as the size of the cell output. It is also possible for cell to be a list of RNN cell instances, in which case the cells get stacked on after the other in the RNN, implementing an efficient stacked RNN.
    returnSequences (boolean) Whether to return the last output in the output sequence, or the full sequence.
    returnState (boolean) Whether to return the last state in addition to the output.
    goBackwards (boolean) If true, process the input sequence backwards and return the reversed sequence (default: false).
    stateful (boolean) If true, the last state for each sample at index i in a batch will be used as initial state of the sample of index i in the following batch (default: false).

    You can set RNN layers to be "stateful", which means that the states computed for the samples in one batch will be reused as initial states for the samples in the next batch. This assumes a one-to-one mapping between samples in different successive batches.

    To enable "statefulness":
        specify stateful: true in the layer constructor.
        specify a fixed batch size for your model, by passing
            if sequential model: batchInputShape: [...] to the first layer in your model.
            else for functional model with 1 or more Input layers: batchShape: [...] to all the first layers in your model. This is the expected shape of your inputs including the batch size. It should be a tuple of integers, e.g., [32, 10, 100].
        specify shuffle: false when calling LayersModel.fit().

    To reset the state of your model, call resetStates() on either the specific layer or on the entire model.
    unroll (boolean) If true, the network will be unrolled, else a symbolic loop will be used. Unrolling can speed up a RNN, although it tends to be more memory-intensive. Unrolling is only suitable for short sequences (default: false). Porting Note: tfjs-layers has an imperative backend. RNNs are executed with normal TypeScript control flow. Hence this property is inapplicable and ignored in tfjs-layers.
    inputDim (number) Dimensionality of the input (integer). This option (or alternatively, the option inputShape) is required when this layer is used as the first layer in a model.
    inputLength (number) Length of the input sequences, to be specified when it is constant. This argument is required if you are going to connect Flatten then Dense layers upstream (without it, the shape of the dense outputs cannot be computed). Note that if the recurrent layer is not the first layer in your model, you would need to specify the input length at the level of the first layer (e.g., via the inputShape option).
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: LSTM
tf.layers.lstmCell (args) function Source

Cell class for LSTM.

LSTMCell is distinct from the RNN subclass LSTM in that its apply method takes the input data of only a single time step and returns the cell's output at the time step, while LSTM takes the input data over a number of time steps. For example:

const cell = tf.layers.lstmCell({units: 2});
const input = tf.input({shape: [10]});
const output = cell.apply(input);

console.log(JSON.stringify(output.shape));
// [null, 10]: This is the cell's output at a single time step. The 1st
// dimension is the unknown batch size.

Instance(s) of LSTMCell can be used to construct RNN layers. The most typical use of this workflow is to combine a number of cells into a stacked RNN cell (i.e., StackedRNNCell internally) and use it to create an RNN. For example:

const cells = [
   tf.layers.lstmCell({units: 4}),
   tf.layers.lstmCell({units: 8}),
];
const rnn = tf.layers.rnn({cell: cells, returnSequences: true});

// Create an input with 10 time steps and a length-20 vector at each step.
const input = tf.input({shape: [10, 20]});
const output = rnn.apply(input);

console.log(JSON.stringify(output.shape));
// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the
// same as the sequence length of `input`, due to `returnSequences`: `true`;
// 3rd dimension is the last `lstmCell`'s number of units.

To create an RNN consisting of only one LSTMCell, use the tf.layers.lstm().
Parameters:

    args (Object)
    recurrentActivation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Activation function to use for the recurrent step.

    Defaults to hard sigmoid (hardSigmoid).

    If null, no activation is applied.
    unitForgetBias (boolean) If true, add 1 to the bias of the forget gate at initialization. Setting it to true will also force biasInitializer = 'zeros'. This is recommended in Jozefowicz et al.
    implementation (number) Implementation mode, either 1 or 2.

    Mode 1 will structure its operations as a larger number of smaller dot products and additions.

    Mode 2 will batch them into fewer, larger operations. These modes will have different performance profiles on different hardware and for different applications.

    Note: For superior performance, TensorFlow.js always uses implementation 2, regardless of the actual value of this configuration field.
    units (number) units: Positive integer, dimensionality of the output space.
    activation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Activation function to use. Default: hyperbolic tangent ('tanh'). If you pass null, 'linear' activation will be applied.
    useBias (boolean) Whether the layer uses a bias vector.
    kernelInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the kernel weights matrix, used for the linear transformation of the inputs.
    recurrentInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the recurrentKernel weights matrix, used for linear transformation of the recurrent state.
    biasInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the bias vector.
    kernelRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the kernel weights matrix.
    recurrentRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the recurrent_kernel weights matrix.
    biasRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the bias vector.
    kernelConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the kernel weights matrix.
    recurrentConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the recurrentKernel weights matrix.
    biasConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the bias vector.
    dropout (number) Float number between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs.
    recurrentDropout (number) Float number between 0 and 1. Fraction of the units to drop for the linear transformation of the recurrent state.
    dropoutFunc (Function) This is added for test DI purpose.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: LSTMCell
tf.layers.rnn (args) function Source

Base class for recurrent layers.

Input shape: 3D tensor with shape [batchSize, timeSteps, inputDim].

Output shape:

    if returnState, an Array of tensors (i.e., tf.Tensors). The first tensor is the output. The remaining tensors are the states at the last time step, each with shape [batchSize, units].
    if returnSequences, the output will have shape [batchSize, timeSteps, units].
    else, the output will have shape [batchSize, units].

Masking: This layer supports masking for input data with a variable number of timesteps. To introduce masks to your data, use an embedding layer with the mask_zero parameter set to True.

Notes on using statefulness in RNNs: You can set RNN layers to be 'stateful', which means that the states computed for the samples in one batch will be reused as initial states for the samples in the next batch. This assumes a one-to-one mapping between samples in different successive batches.

To enable statefulness: - specify stateful: true in the layer constructor. - specify a fixed batch size for your model, by passing if sequential model: batchInputShape=[...] to the first layer in your model. else for functional model with 1 or more Input layers: batchShape=[...] to all the first layers in your model. This is the expected shape of your inputs including the batch size. It should be a tuple of integers, e.g. (32, 10, 100). - specify shuffle=False when calling fit().

To reset the states of your model, call .resetStates() on either a specific layer, or on your entire model.

Note on specifying the initial state of RNNs You can specify the initial state of RNN layers symbolically by calling them with the option initialState. The value of initialState should be a tensor or list of tensors representing the initial state of the RNN layer.

You can specify the initial state of RNN layers numerically by calling resetStates with the keyword argument states. The value of states should be a numpy array or list of numpy arrays representing the initial state of the RNN layer.

Note on passing external constants to RNNs You can pass "external" constants to the cell using the constants keyword argument of RNN.call method. This requires that the cell.call method accepts the same keyword argument constants. Such constants can be used to condition the cell transformation on additional static inputs (not changing over time), a.k.a. an attention mechanism.
Parameters:

    args (Object)
    cell (tf.RNNCell|tf.RNNCell[]) A RNN cell instance. A RNN cell is a class that has:

        a call() method, which takes [Tensor, Tensor] as the first input argument. The first item is the input at time t, and second item is the cell state at time t. The call() method returns [outputAtT, statesAtTPlus1]. The call() method of the cell can also take the argument constants, see section "Note on passing external constants" below. Porting Node: PyKeras overrides the call() signature of RNN cells, which are Layer subtypes, to accept two arguments. tfjs-layers does not do such overriding. Instead we preserve the call() signature, which due to its Tensor|Tensor[] argument and return value is flexible enough to handle the inputs and states.
        a stateSize attribute. This can be a single integer (single state) in which case it is the size of the recurrent state (which should be the same as the size of the cell output). This can also be an Array of integers (one size per state). In this case, the first entry (stateSize[0]) should be the same as the size of the cell output. It is also possible for cell to be a list of RNN cell instances, in which case the cells get stacked on after the other in the RNN, implementing an efficient stacked RNN.
    returnSequences (boolean) Whether to return the last output in the output sequence, or the full sequence.
    returnState (boolean) Whether to return the last state in addition to the output.
    goBackwards (boolean) If true, process the input sequence backwards and return the reversed sequence (default: false).
    stateful (boolean) If true, the last state for each sample at index i in a batch will be used as initial state of the sample of index i in the following batch (default: false).

    You can set RNN layers to be "stateful", which means that the states computed for the samples in one batch will be reused as initial states for the samples in the next batch. This assumes a one-to-one mapping between samples in different successive batches.

    To enable "statefulness":
        specify stateful: true in the layer constructor.
        specify a fixed batch size for your model, by passing
            if sequential model: batchInputShape: [...] to the first layer in your model.
            else for functional model with 1 or more Input layers: batchShape: [...] to all the first layers in your model. This is the expected shape of your inputs including the batch size. It should be a tuple of integers, e.g., [32, 10, 100].
        specify shuffle: false when calling LayersModel.fit().

    To reset the state of your model, call resetStates() on either the specific layer or on the entire model.
    unroll (boolean) If true, the network will be unrolled, else a symbolic loop will be used. Unrolling can speed up a RNN, although it tends to be more memory-intensive. Unrolling is only suitable for short sequences (default: false). Porting Note: tfjs-layers has an imperative backend. RNNs are executed with normal TypeScript control flow. Hence this property is inapplicable and ignored in tfjs-layers.
    inputDim (number) Dimensionality of the input (integer). This option (or alternatively, the option inputShape) is required when this layer is used as the first layer in a model.
    inputLength (number) Length of the input sequences, to be specified when it is constant. This argument is required if you are going to connect Flatten then Dense layers upstream (without it, the shape of the dense outputs cannot be computed). Note that if the recurrent layer is not the first layer in your model, you would need to specify the input length at the level of the first layer (e.g., via the inputShape option).
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: RNN
tf.layers.simpleRNN (args) function Source

Fully-connected RNN where the output is to be fed back to input.

This is an RNN layer consisting of one SimpleRNNCell. However, unlike the underlying SimpleRNNCell, the apply method of SimpleRNN operates on a sequence of inputs. The shape of the input (not including the first, batch dimension) needs to be at least 2-D, with the first dimension being time steps. For example:

const rnn = tf.layers.simpleRNN({units: 8, returnSequences: true});

// Create an input with 10 time steps.
const input = tf.input({shape: [10, 20]});
const output = rnn.apply(input);

console.log(JSON.stringify(output.shape));
// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the
// same as the sequence length of `input`, due to `returnSequences`: `true`;
// 3rd dimension is the `SimpleRNNCell`'s number of units.

Parameters:

    args (Object)
    units (number) Positive integer, dimensionality of the output space.
    activation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Activation function to use.

    Defaults to hyperbolic tangent (tanh)

    If you pass null, no activation will be applied.
    useBias (boolean) Whether the layer uses a bias vector.
    kernelInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the kernel weights matrix, used for the linear transformation of the inputs.
    recurrentInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the recurrentKernel weights matrix, used for linear transformation of the recurrent state.
    biasInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the bias vector.
    kernelRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the kernel weights matrix.
    recurrentRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the recurrentKernel weights matrix.
    biasRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the bias vector.
    kernelConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the kernel weights matrix.
    recurrentConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the recurrentKernel weights matrix.
    biasConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the bias vector.
    dropout (number) Number between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs.
    recurrentDropout (number) Number between 0 and 1. Fraction of the units to drop for the linear transformation of the recurrent state.
    dropoutFunc (Function) This is added for test DI purpose.
    cell (tf.RNNCell|tf.RNNCell[]) A RNN cell instance. A RNN cell is a class that has:

        a call() method, which takes [Tensor, Tensor] as the first input argument. The first item is the input at time t, and second item is the cell state at time t. The call() method returns [outputAtT, statesAtTPlus1]. The call() method of the cell can also take the argument constants, see section "Note on passing external constants" below. Porting Node: PyKeras overrides the call() signature of RNN cells, which are Layer subtypes, to accept two arguments. tfjs-layers does not do such overriding. Instead we preserve the call() signature, which due to its Tensor|Tensor[] argument and return value is flexible enough to handle the inputs and states.
        a stateSize attribute. This can be a single integer (single state) in which case it is the size of the recurrent state (which should be the same as the size of the cell output). This can also be an Array of integers (one size per state). In this case, the first entry (stateSize[0]) should be the same as the size of the cell output. It is also possible for cell to be a list of RNN cell instances, in which case the cells get stacked on after the other in the RNN, implementing an efficient stacked RNN.
    returnSequences (boolean) Whether to return the last output in the output sequence, or the full sequence.
    returnState (boolean) Whether to return the last state in addition to the output.
    goBackwards (boolean) If true, process the input sequence backwards and return the reversed sequence (default: false).
    stateful (boolean) If true, the last state for each sample at index i in a batch will be used as initial state of the sample of index i in the following batch (default: false).

    You can set RNN layers to be "stateful", which means that the states computed for the samples in one batch will be reused as initial states for the samples in the next batch. This assumes a one-to-one mapping between samples in different successive batches.

    To enable "statefulness":
        specify stateful: true in the layer constructor.
        specify a fixed batch size for your model, by passing
            if sequential model: batchInputShape: [...] to the first layer in your model.
            else for functional model with 1 or more Input layers: batchShape: [...] to all the first layers in your model. This is the expected shape of your inputs including the batch size. It should be a tuple of integers, e.g., [32, 10, 100].
        specify shuffle: false when calling LayersModel.fit().

    To reset the state of your model, call resetStates() on either the specific layer or on the entire model.
    unroll (boolean) If true, the network will be unrolled, else a symbolic loop will be used. Unrolling can speed up a RNN, although it tends to be more memory-intensive. Unrolling is only suitable for short sequences (default: false). Porting Note: tfjs-layers has an imperative backend. RNNs are executed with normal TypeScript control flow. Hence this property is inapplicable and ignored in tfjs-layers.
    inputDim (number) Dimensionality of the input (integer). This option (or alternatively, the option inputShape) is required when this layer is used as the first layer in a model.
    inputLength (number) Length of the input sequences, to be specified when it is constant. This argument is required if you are going to connect Flatten then Dense layers upstream (without it, the shape of the dense outputs cannot be computed). Note that if the recurrent layer is not the first layer in your model, you would need to specify the input length at the level of the first layer (e.g., via the inputShape option).
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: SimpleRNN
tf.layers.simpleRNNCell (args) function Source

Cell class for SimpleRNN.

SimpleRNNCell is distinct from the RNN subclass SimpleRNN in that its apply method takes the input data of only a single time step and returns the cell's output at the time step, while SimpleRNN takes the input data over a number of time steps. For example:

const cell = tf.layers.simpleRNNCell({units: 2});
const input = tf.input({shape: [10]});
const output = cell.apply(input);

console.log(JSON.stringify(output.shape));
// [null, 10]: This is the cell's output at a single time step. The 1st
// dimension is the unknown batch size.

Instance(s) of SimpleRNNCell can be used to construct RNN layers. The most typical use of this workflow is to combine a number of cells into a stacked RNN cell (i.e., StackedRNNCell internally) and use it to create an RNN. For example:

const cells = [
   tf.layers.simpleRNNCell({units: 4}),
   tf.layers.simpleRNNCell({units: 8}),
];
const rnn = tf.layers.rnn({cell: cells, returnSequences: true});

// Create an input with 10 time steps and a length-20 vector at each step.
const input = tf.input({shape: [10, 20]});
const output = rnn.apply(input);

console.log(JSON.stringify(output.shape));
// [null, 10, 8]: 1st dimension is unknown batch size; 2nd dimension is the
// same as the sequence length of `input`, due to `returnSequences`: `true`;
// 3rd dimension is the last `SimpleRNNCell`'s number of units.

To create an RNN consisting of only one SimpleRNNCell, use the tf.layers.simpleRNN().
Parameters:

    args (Object)
    units (number) units: Positive integer, dimensionality of the output space.
    activation ('elu'|'hardSigmoid'|'linear'|'relu'|'relu6'| 'selu'|'sigmoid'|'softmax'|'softplus'|'softsign'|'tanh'|'swish'|'mish'|'gelu'|'gelu_new') Activation function to use. Default: hyperbolic tangent ('tanh'). If you pass null, 'linear' activation will be applied.
    useBias (boolean) Whether the layer uses a bias vector.
    kernelInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the kernel weights matrix, used for the linear transformation of the inputs.
    recurrentInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the recurrentKernel weights matrix, used for linear transformation of the recurrent state.
    biasInitializer ('constant'|'glorotNormal'|'glorotUniform'|'heNormal'|'heUniform'|'identity'| 'leCunNormal'|'leCunUniform'|'ones'|'orthogonal'|'randomNormal'| 'randomUniform'|'truncatedNormal'|'varianceScaling'|'zeros'|string|tf.initializers.Initializer) Initializer for the bias vector.
    kernelRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the kernel weights matrix.
    recurrentRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the recurrent_kernel weights matrix.
    biasRegularizer ('l1l2'|string|Regularizer) Regularizer function applied to the bias vector.
    kernelConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the kernel weights matrix.
    recurrentConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the recurrentKernel weights matrix.
    biasConstraint ('maxNorm'|'minMaxNorm'|'nonNeg'|'unitNorm'|string|tf.constraints.Constraint) Constraint function applied to the bias vector.
    dropout (number) Float number between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs.
    recurrentDropout (number) Float number between 0 and 1. Fraction of the units to drop for the linear transformation of the recurrent state.
    dropoutFunc (Function) This is added for test DI purpose.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: SimpleRNNCell
tf.layers.stackedRNNCells (args) function Source

Wrapper allowing a stack of RNN cells to behave as a single cell.

Used to implement efficient stacked RNNs.
Parameters:

    args (Object)
    cells (tf.RNNCell[]) An Array of RNNCell instances.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: StackedRNNCells
Layers / Wrapper
tf.layers.bidirectional (args) function Source
Parameters:

    args (Object)
    layer (RNN) The instance of an RNN layer to be wrapped.
    mergeMode ('sum'|'mul'|'concat'|'ave') Mode by which outputs of the forward and backward RNNs are combined. If null or undefined, the output will not be combined, they will be returned as an Array.

    If undefined (i.e., not provided), defaults to 'concat'.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Bidirectional
tf.layers.timeDistributed (args) function Source

This wrapper applies a layer to every temporal slice of an input.

The input should be at least 3D, and the dimension of the index 1 will be considered to be the temporal dimension.

Consider a batch of 32 samples, where each sample is a sequence of 10 vectors of 16 dimensions. The batch input shape of the layer is then [32, 10, 16], and the inputShape, not including the sample dimension, is [10, 16].

You can then use TimeDistributed to apply a Dense layer to each of the 10 timesteps, independently:

const model = tf.sequential();
model.add(tf.layers.timeDistributed({
   layer: tf.layers.dense({units: 8}),
   inputShape: [10, 16],
}));

// Now model.outputShape = [null, 10, 8].
// The output will then have shape `[32, 10, 8]`.

// In subsequent layers, there is no need for `inputShape`:
model.add(tf.layers.timeDistributed({layer: tf.layers.dense({units: 32})}));
console.log(JSON.stringify(model.outputs[0].shape));
// Now model.outputShape = [null, 10, 32].

The output will then have shape [32, 10, 32].

TimeDistributed can be used with arbitrary layers, not just Dense, for instance a Conv2D layer.

const model = tf.sequential();
model.add(tf.layers.timeDistributed({
   layer: tf.layers.conv2d({filters: 64, kernelSize: [3, 3]}),
   inputShape: [10, 299, 299, 3],
}));
console.log(JSON.stringify(model.outputs[0].shape));

Parameters:

    args (Object)
    layer (tf.layers.Layer) The layer to be wrapped.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: TimeDistributed
Layers / Classes
tf.layers.Layer extends serialization.Serializable class Source

A layer is a grouping of operations and weights that can be composed to create a tf.LayersModel.

Layers are constructed by using the functions under the tf.layers namespace.
apply (inputs, kwargs?) method Source

Builds or executes a Layer's logic.

When called with tf.Tensor(s), execute the Layer's computation and return Tensor(s). For example:

const denseLayer = tf.layers.dense({
   units: 1,
   kernelInitializer: 'zeros',
   useBias: false
});

// Invoke the layer's apply() method with a [tf.Tensor](#class:Tensor) (with concrete
// numeric values).
const input = tf.ones([2, 2]);
const output = denseLayer.apply(input);

// The output's value is expected to be [[0], [0]], due to the fact that
// the dense layer has a kernel initialized to all-zeros and does not have
// a bias.
output.print();

When called with tf.SymbolicTensor(s), this will prepare the layer for future execution. This entails internal book-keeping on shapes of expected Tensors, wiring layers together, and initializing weights.

Calling apply with tf.SymbolicTensors are typically used during the building of non-tf.Sequential models. For example:

const flattenLayer = tf.layers.flatten();
const denseLayer = tf.layers.dense({units: 1});

// Use tf.layers.input() to obtain a SymbolicTensor as input to apply().
const input = tf.input({shape: [2, 2]});
const output1 = flattenLayer.apply(input);

// output1.shape is [null, 4]. The first dimension is the undetermined
// batch size. The second dimension comes from flattening the [2, 2]
// shape.
console.log(JSON.stringify(output1.shape));

// The output SymbolicTensor of the flatten layer can be used to call
// the apply() of the dense layer:
const output2 = denseLayer.apply(output1);

// output2.shape is [null, 1]. The first dimension is the undetermined
// batch size. The second dimension matches the number of units of the
// dense layer.
console.log(JSON.stringify(output2.shape));

// The input and output can be used to construct a model that consists
// of the flatten and dense layers.
const model = tf.model({inputs: input, outputs: output2});

Parameters:

    inputs (tf.Tensor|tf.Tensor[]|tf.SymbolicTensor|tf.SymbolicTensor[]) a tf.Tensor or tf.SymbolicTensor or an Array of them.
    kwargs (Kwargs) Additional keyword arguments to be passed to call(). Optional

Returns: tf.Tensor|tf.Tensor[]|tf.SymbolicTensor|tf.SymbolicTensor[]
countParams () method Source

Counts the total number of numbers (e.g., float32, int32) in the weights.
Returns: number
build (inputShape) method Source

Creates the layer weights.

Must be implemented on all layers that have weights.

Called when apply() is called to construct the weights.
Parameters:

    inputShape ((null | number)[]|(null | number)[][]) A Shape or array of Shape (unused).

Returns: void
getWeights (trainableOnly?) method Source

Returns the current values of the weights of the layer.
Parameters:

    trainableOnly (boolean) Whether to get the values of only trainable weights. Optional

Returns: tf.Tensor[]
setWeights (weights) method Source

Sets the weights of the layer, from Tensors.
Parameters:

    weights (tf.Tensor[]) a list of Tensors. The number of arrays and their shape must match number of the dimensions of the weights of the layer (i.e. it should match the output of getWeights).

Returns: void
addWeight (name, shape, dtype?, initializer?, regularizer?, trainable?, constraint?, getInitializerFunc?) method Source

Adds a weight variable to the layer.
Parameters:

    name (string) Name of the new weight variable.
    shape ((null | number)[]) The shape of the weight.
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The dtype of the weight. Optional
    initializer (tf.initializers.Initializer) An initializer instance. Optional
    regularizer (Regularizer) A regularizer instance. Optional
    trainable (boolean) Whether the weight should be trained via backprop or not (assuming that the layer itself is also trainable). Optional
    constraint (tf.constraints.Constraint) An optional trainable. Optional
    getInitializerFunc (Function) Optional

Returns: LayerVariable
addLoss (losses) method Source

Add losses to the layer.

The loss may potentially be conditional on some inputs tensors, for instance activity losses are conditional on the layer's inputs.
Parameters:

    losses (RegularizerFn|RegularizerFn[])

Returns: void
computeOutputShape (inputShape) method Source

Computes the output shape of the layer.

Assumes that the layer will be built to match that input shape provided.
Parameters:

    inputShape ((null | number)[]|(null | number)[][]) A shape (tuple of integers) or a list of shape tuples (one per output tensor of the layer). Shape tuples can include null for free dimensions, instead of an integer.

Returns: (null | number)[]|(null | number)[][]
getConfig () method Source

Returns the config of the layer.

A layer config is a TS dictionary (serializable) containing the configuration of a layer. The same layer can be reinstantiated later (without its trained weights) from this configuration.

The config of a layer does not include connectivity information, nor the layer class name. These are handled by 'Container' (one layer of abstraction above).

Porting Note: The TS dictionary follows TS naming standards for keys, and uses tfjs-layers type-safe Enums. Serialization methods should use a helper function to convert to the pythonic storage standard. (see serialization_utils.convertTsToPythonic)
Returns: serialization.ConfigDict
dispose () method Source

Attempt to dispose layer's weights.

This method decreases the reference count of the Layer object by 1.

A Layer is reference-counted. Its reference count is incremented by 1 the first item its apply() method is called and when it becomes a part of a new Node (through calling the apply() method on a tf.SymbolicTensor).

If the reference count of a Layer becomes 0, all the weights will be disposed and the underlying memory (e.g., the textures allocated in WebGL) will be freed.

Note: If the reference count is greater than 0 after the decrement, the weights of the Layer will not be disposed.

After a Layer is disposed, it cannot be used in calls such as apply(), getWeights() or setWeights() anymore.
Returns: DisposeResult
tf.RNNCell extends tf.layers.Layer class Source

An RNNCell layer.
Layers / Inputs
tf.layers.inputLayer (args) function Source

An input layer is an entry point into a tf.LayersModel.

InputLayer is generated automatically for tf.Sequential models by specifying the inputshape or batchInputShape for the first layer. It should not be specified explicitly. However, it can be useful sometimes, e.g., when constructing a sequential model from a subset of another sequential model's layers. Like the code snippet below shows.

// Define a model which simply adds two inputs.
const model1 = tf.sequential();
model1.add(tf.layers.dense({inputShape: [4], units: 3, activation: 'relu'}));
model1.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));
model1.summary();
model1.predict(tf.zeros([1, 4])).print();

// Construct another model, reusing the second layer of `model1` while
// not using the first layer of `model1`. Note that you cannot add the second
// layer of `model` directly as the first layer of the new sequential model,
// because doing so will lead to an error related to the fact that the layer
// is not an input layer. Instead, you need to create an `inputLayer` and add
// it to the new sequential model before adding the reused layer.
const model2 = tf.sequential();
// Use an inputShape that matches the input shape of `model1`'s second
// layer.
model2.add(tf.layers.inputLayer({inputShape: [3]}));
model2.add(model1.layers[1]);
model2.summary();
model2.predict(tf.zeros([1, 3])).print();

Parameters:

    args (Object)
    inputShape ((null | number)[]) Input shape, not including the batch axis.
    batchSize (number) Optional input batch size (integer or null).
    batchInputShape ((null | number)[]) Batch input shape, including the batch axis.
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') Datatype of the input.
    sparse (boolean) Whether the placeholder created is meant to be sparse.
    name (string) Name of the layer.

Returns: InputLayer
Layers / Padding
tf.layers.zeroPadding2d (args?) function Source

Zero-padding layer for 2D input (e.g., image).

This layer can add rows and columns of zeros at the top, bottom, left and right side of an image tensor.

Input shape: 4D tensor with shape:

    If dataFormat is "channelsLast": [batch, rows, cols, channels]
    If data_format is "channels_first": [batch, channels, rows, cols].

Output shape: 4D with shape:

    If dataFormat is "channelsLast": [batch, paddedRows, paddedCols, channels] - If dataFormat is "channelsFirst": [batch, channels, paddedRows, paddedCols].

Parameters:

    args (Object) Optional
    padding (number|[number, number]|[[number, number], [number, number]]) Integer, or Array of 2 integers, or Array of 2 Arrays, each of which is an Array of 2 integers.

        If integer, the same symmetric padding is applied to width and height.
        If Array of 2 integers, interpreted as two different symmetric values for height and width: [symmetricHeightPad, symmetricWidthPad].
        If Array of 2 Arrays, interpreted as: [[topPad, bottomPad], [leftPad, rightPad]].
    dataFormat ('channelsFirst'|'channelsLast') One of 'channelsLast' (default) and 'channelsFirst'.

    The ordering of the dimensions in the inputs. channelsLast corresponds to inputs with shape [batch, height, width, channels] while channelsFirst corresponds to inputs with shape [batch, channels, height, width].
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: ZeroPadding2D
Layers / Noise
tf.layers.alphaDropout (args) function Source

Applies Alpha Dropout to the input.

As it is a regularization layer, it is only active at training time.

Alpha Dropout is a Dropout that keeps mean and variance of inputs to their original values, in order to ensure the self-normalizing property even after this dropout. Alpha Dropout fits well to Scaled Exponential Linear Units by randomly setting activations to the negative saturation value.

Arguments:

    rate: float, drop probability (as with Dropout). The multiplicative noise will have standard deviation sqrt(rate / (1 - rate)).
    noise_shape: A 1-D Tensor of type int32, representing the shape for randomly generated keep/drop flags.

Input shape: Arbitrary. Use the keyword argument inputShape (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model.

Output shape: Same shape as input.

References:

    Self-Normalizing Neural Networks

Parameters:

    args (Object)
    rate (number) drop probability.
    noiseShape ((null | number)[]) A 1-D Tensor of type int32, representing the shape for randomly generated keep/drop flags.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: AlphaDropout
tf.layers.gaussianDropout (args) function Source

Apply multiplicative 1-centered Gaussian noise.

As it is a regularization layer, it is only active at training time.

Arguments:

    rate: float, drop probability (as with Dropout). The multiplicative noise will have standard deviation sqrt(rate / (1 - rate)).

Input shape: Arbitrary. Use the keyword argument inputShape (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model.

Output shape: Same shape as input.

References:

    Dropout: A Simple Way to Prevent Neural Networks from Overfitting

Parameters:

    args (Object)
    rate (number) drop probability.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: GaussianDropout
tf.layers.gaussianNoise (args) function Source

Apply additive zero-centered Gaussian noise.

As it is a regularization layer, it is only active at training time.

This is useful to mitigate overfitting (you could see it as a form of random data augmentation). Gaussian Noise (GS) is a natural choice as corruption process for real valued inputs.
Arguments

stddev: float, standard deviation of the noise distribution.
Input shape

Arbitrary. Use the keyword argument input_shape (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model.
Output shape

Same shape as input.
Parameters:

    args (Object)
    stddev (number) Standard Deviation.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: GaussianNoise
Layers / Mask
tf.layers.masking (args?) function Source

Masks a sequence by using a mask value to skip timesteps.

If all features for a given sample timestep are equal to mask_value, then the sample timestep will be masked (skipped) in all downstream layers (as long as they support masking).

If any downstream layer does not support masking yet receives such an input mask, an exception will be raised.

Arguments:

    maskValue: Either None or mask value to skip.

Input shape: Arbitrary. Use the keyword argument inputShape (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model.

Output shape: Same shape as input.
Parameters:

    args (Object) Optional
    maskValue (number) Masking Value. Defaults to 0.0.
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Masking
Layers / Rescaling
tf.layers.rescaling (args?) function Source

A preprocessing layer which rescales input values to a new range.

This layer rescales every value of an input (often an image) by multiplying by scale and adding offset.

For instance:

    To rescale an input in the [0, 255] range to be in the [0, 1] range, you would pass scale=1/255.
    To rescale an input in the [0, 255] range to be in the [-1, 1] range, you would pass scale=1./127.5, offset=-1. The rescaling is applied both during training and inference. Inputs can be of integer or floating point dtype, and by default the layer will output floats.

Arguments:

    scale: Float, the scale to apply to the inputs.
    offset: Float, the offset to apply to the inputs.

Input shape: Arbitrary.

Output shape: Same as input.
Parameters:

    args (Object) Optional
    scale (number)
    offset (number)
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Rescaling
Layers / CenterCrop
tf.layers.centerCrop (args?) function Source

A preprocessing layer which center crops images.

This layers crops the central portion of the images to a target size. If an image is smaller than the target size, it will be resized and cropped so as to return the largest possible window in the image that matches the target aspect ratio.

Input pixel values can be of any range (e.g. [0., 1.) or [0, 255]) and of integer or floating point dtype.

If the input height/width is even and the target height/width is odd (or inversely), the input image is left-padded by 1 pixel.

Arguments: height: Integer, the height of the output shape. width: Integer, the width of the output shape.

Input shape: 3D (unbatched) or 4D (batched) tensor with shape: (..., height, width, channels), in channelsLast format.

Output shape: 3D (unbatched) or 4D (batched) tensor with shape: (..., targetHeight, targetWidth, channels).
Parameters:

    args (Object) Optional
    height (number)
    width (number)
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: CenterCrop
Layers / Resizing
tf.layers.resizing (args?) function Source

A preprocessing layer which resizes images. This layer resizes an image input to a target height and width. The input should be a 4D (batched) or 3D (unbatched) tensor in "channels_last" format. Input pixel values can be of any range (e.g. [0., 1.) or [0, 255]) and of interger or floating point dtype. By default, the layer will output floats.

Arguments:

    height: number, the height for the output tensor.
    width: number, the width for the output tensor.
    interpolation: string, the method for image resizing interpolation.
    cropToAspectRatio: boolean, whether to keep image aspect ratio.

Input shape: Arbitrary.

Output shape: height, width, num channels.
Parameters:

    args (Object) Optional
    height (number)
    width (number)
    interpolation (InterpolationType)
    cropToAspectRatio (boolean)
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: Resizing
Layers / CategoryEncoding
tf.layers.categoryEncoding (args) function Source

A preprocessing layer which encodes integer features.

This layer provides options for condensing data into a categorical encoding when the total number of tokens are known in advance. It accepts integer values as inputs, and it outputs a dense representation of those inputs.

Arguments:

numTokens: The total number of tokens the layer should support. All inputs to the layer must integers in the range 0 <= value < numTokens, or an error will be thrown.

outputMode: Specification for the output of the layer. Defaults to multiHot. Values can be oneHot, multiHot or count, configuring the layer as follows:

oneHot: Encodes each individual element in the input into an
  array of `numTokens` size, containing a 1 at the element index. If
  the last dimension is size 1, will encode on that dimension. If the
  last dimension is not size 1, will append a new dimension for the
  encoded output.

multiHot: Encodes each sample in the input into a single array
 of `numTokens` size, containing a 1 for each vocabulary term
 present in the sample. Treats the last dimension as the sample
 dimension, if input shape is `(..., sampleLength)`, output shape
 will be `(..., numTokens)`.

count: Like `multiHot`, but the int array contains a count of
 the number of times the token at that index appeared in the sample.

For all output modes, currently only output up to rank 2 is supported. Call arguments: inputs: A 1D or 2D tensor of integer inputs. countWeights: A tensor in the same shape as inputs indicating the weight for each sample value when summing up in count mode. Not used in multiHot or oneHot modes.
Parameters:

    args (Object)
    numTokens (number)
    outputMode (OutputMode)
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: CategoryEncoding
Layers / RandomWidth
tf.layers.randomWidth (args) function Source

A preprocessing layer which randomly varies image width during training.

This layer will randomly adjusts the width of a batch of images of a batch of images by a random factor.

The input should be a 3D (unbatched) or 4D (batched) tensor in the "channels_last" image data format. Input pixel values can be of any range (e.g. [0., 1.) or [0, 255]) and of integer or floating point dtype. By default, the layer will output floats. By default, this layer is inactive during inference. For an overview and full list of preprocessing layers, see the preprocessing [guide] (https://www.tensorflow.org/guide/keras/preprocessing_layers).

Arguments:

factor: A positive float (fraction of original width), or a tuple of size 2 representing lower and upper bound for resizing vertically. When represented as a single float, this value is used for both the upper and lower bound. For instance, factor=(0.2, 0.3) results in an output with width changed by a random amount in the range [20%, 30%]. factor=(-0.2, 0.3) results in an output with width changed by a random amount in the range [-20%, +30%]. factor=0.2 results in an output with width changed by a random amount in the range [-20%, +20%]. interpolation: String, the interpolation method. Defaults to bilinear. Supports "bilinear", "nearest". The tf methods "bicubic", "area", "lanczos3", "lanczos5", "gaussian", "mitchellcubic" are unimplemented in tfjs. seed: Integer. Used to create a random seed.

Input shape: 3D (unbatched) or 4D (batched) tensor with shape: (..., height, width, channels), in "channels_last" format. Output shape: 3D (unbatched) or 4D (batched) tensor with shape: (..., height, random_width, channels).
Parameters:

    args (Object)
    factor (number | [number, number])
    interpolation (InterpolationType)
    seed (number)
    autoVectorize (boolean)
    inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
    batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
    dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
    name (string) Name for this layer.
    trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
    weights (tf.Tensor[]) Initial weight values of the layer.
    inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.

Returns: RandomWidth
Operations
Operations / Arithmetic

To perform mathematical computation on Tensors, we use operations. Tensors are immutable, so all operations always return new Tensors and never modify input Tensors.
tf.add (a, b) function Source

Adds two tf.Tensors element-wise, A + B. Supports broadcasting.

const a = tf.tensor1d([1, 2, 3, 4]);
const b = tf.tensor1d([10, 20, 30, 40]);

a.add(b).print();  // or tf.add(a, b)

// Broadcast add a with b.
const a = tf.scalar(5);
const b = tf.tensor1d([10, 20, 30, 40]);

a.add(b).print();  // or tf.add(a, b)

Parameters:

    a (tf.Tensor|TypedArray|Array) The first tf.Tensor to add.
    b (tf.Tensor|TypedArray|Array) The second tf.Tensor to add. Must have the same type as a.

Returns: tf.Tensor
tf.sub (a, b) function Source

Subtracts two tf.Tensors element-wise, A - B. Supports broadcasting.

const a = tf.tensor1d([10, 20, 30, 40]);
const b = tf.tensor1d([1, 2, 3, 4]);

a.sub(b).print();  // or tf.sub(a, b)

// Broadcast subtract a with b.
const a = tf.tensor1d([10, 20, 30, 40]);
const b = tf.scalar(5);

a.sub(b).print();  // or tf.sub(a, b)

Parameters:

    a (tf.Tensor|TypedArray|Array) The first tf.Tensor to subtract from.
    b (tf.Tensor|TypedArray|Array) The second tf.Tensor to be subtracted. Must have the same dtype as a.

Returns: tf.Tensor
tf.mul (a, b) function Source

Multiplies two tf.Tensors element-wise, A * B. Supports broadcasting.

We also expose tf.mulStrict which has the same signature as this op and asserts that a and b are the same shape (does not broadcast).

const a = tf.tensor1d([1, 2, 3, 4]);
const b = tf.tensor1d([2, 3, 4, 5]);

a.mul(b).print();  // or tf.mul(a, b)

// Broadcast mul a with b.
const a = tf.tensor1d([1, 2, 3, 4]);
const b = tf.scalar(5);

a.mul(b).print();  // or tf.mul(a, b)

Parameters:

    a (tf.Tensor|TypedArray|Array) The first tensor to multiply.
    b (tf.Tensor|TypedArray|Array) The second tensor to multiply. Must have the same dtype as a.

Returns: tf.Tensor
tf.div (a, b) function Source

Divides two tf.Tensors element-wise, A / B. Supports broadcasting.

const a = tf.tensor1d([1, 4, 9, 16]);
const b = tf.tensor1d([1, 2, 3, 4]);

a.div(b).print();  // or tf.div(a, b)

// Broadcast div a with b.
const a = tf.tensor1d([2, 4, 6, 8]);
const b = tf.scalar(2);

a.div(b).print();  // or tf.div(a, b)

Parameters:

    a (tf.Tensor|TypedArray|Array) The first tensor as the numerator.
    b (tf.Tensor|TypedArray|Array) The second tensor as the denominator. Must have the same dtype as a.

Returns: tf.Tensor
tf.addN (tensors) function Source

Adds a list of tf.Tensors element-wise, each with the same shape and dtype.

const a = tf.tensor1d([1, 2]);
const b = tf.tensor1d([3, 4]);
const c = tf.tensor1d([5, 6]);

tf.addN([a, b, c]).print();

Parameters:

    tensors (Array) A list of tensors with the same shape and dtype.

Returns: tf.Tensor
tf.divNoNan (a, b) function Source

Divides two tf.Tensors element-wise, A / B. Supports broadcasting. Return 0 if denominator is 0.

const a = tf.tensor1d([1, 4, 9, 16]);
const b = tf.tensor1d([1, 2, 3, 4]);
const c = tf.tensor1d([0, 0, 0, 0]);

a.divNoNan(b).print();  // or tf.divNoNan(a, b)
a.divNoNan(c).print();  // or tf.divNoNan(a, c)

// Broadcast div a with b.
const a = tf.tensor1d([2, 4, 6, 8]);
const b = tf.scalar(2);
const c = tf.scalar(0);

a.divNoNan(b).print();  // or tf.divNoNan(a, b)
a.divNoNan(c).print();  // or tf.divNoNan(a, c)

Parameters:

    a (tf.Tensor|TypedArray|Array) The first tensor as the numerator.
    b (tf.Tensor|TypedArray|Array) The second tensor as the denominator. Must have the same dtype as a.

Returns: tf.Tensor
tf.floorDiv (a, b) function Source

Divides two tf.Tensors element-wise, A / B. Supports broadcasting. The result is rounded with floor function.

const a = tf.tensor1d([1, 4, 9, 16]);
const b = tf.tensor1d([1, 2, 3, 4]);

a.floorDiv(b).print();  // or tf.div(a, b)

// Broadcast div a with b.
const a = tf.tensor1d([2, 4, 6, 8]);
const b = tf.scalar(2);

a.floorDiv(b).print();  // or tf.floorDiv(a, b)

Parameters:

    a (tf.Tensor|TypedArray|Array) The first tensor as the numerator.
    b (tf.Tensor|TypedArray|Array) The second tensor as the denominator. Must have the same dtype as a.

Returns: tf.Tensor
tf.maximum (a, b) function Source

Returns the max of a and b (a > b ? a : b) element-wise. Supports broadcasting.

We also expose tf.maximumStrict which has the same signature as this op and asserts that a and b are the same shape (does not broadcast).

const a = tf.tensor1d([1, 4, 3, 16]);
const b = tf.tensor1d([1, 2, 9, 4]);

a.maximum(b).print();  // or tf.maximum(a, b)

// Broadcast maximum a with b.
const a = tf.tensor1d([2, 4, 6, 8]);
const b = tf.scalar(5);

a.maximum(b).print();  // or tf.maximum(a, b)

Parameters:

    a (tf.Tensor|TypedArray|Array) The first tensor.
    b (tf.Tensor|TypedArray|Array) The second tensor. Must have the same type as a.

Returns: tf.Tensor
tf.minimum (a, b) function Source

Returns the min of a and b (a < b ? a : b) element-wise. Supports broadcasting.

We also expose minimumStrict which has the same signature as this op and asserts that a and b are the same shape (does not broadcast).

const a = tf.tensor1d([1, 4, 3, 16]);
const b = tf.tensor1d([1, 2, 9, 4]);

a.minimum(b).print();  // or tf.minimum(a, b)

// Broadcast minimum a with b.
const a = tf.tensor1d([2, 4, 6, 8]);
const b = tf.scalar(5);

a.minimum(b).print();  // or tf.minimum(a, b)

Parameters:

    a (tf.Tensor|TypedArray|Array) The first tensor.
    b (tf.Tensor|TypedArray|Array) The second tensor. Must have the same type as a.

Returns: tf.Tensor
tf.mod (a, b) function Source

Returns the mod of a and b element-wise. floor(x / y) * y + mod(x, y) = x Supports broadcasting.

We also expose tf.modStrict which has the same signature as this op and asserts that a and b are the same shape (does not broadcast).

const a = tf.tensor1d([1, 4, 3, 16]);
const b = tf.tensor1d([1, 2, 9, 4]);

a.mod(b).print();  // or tf.mod(a, b)

// Broadcast a mod b.
const a = tf.tensor1d([2, 4, 6, 8]);
const b = tf.scalar(5);

a.mod(b).print();  // or tf.mod(a, b)

Parameters:

    a (tf.Tensor|TypedArray|Array) The first tensor.
    b (tf.Tensor|TypedArray|Array) The second tensor. Must have the same type as a.

Returns: tf.Tensor
tf.pow (base, exp) function Source

Computes the power of one tf.Tensor to another. Supports broadcasting.

Given a tf.Tensor x and a tf.Tensor y, this operation computes x^y for corresponding elements in x and y. The result's dtype will be the upcasted type of the base and exp dtypes.

const a = tf.tensor([[2, 3], [4, 5]])
const b = tf.tensor([[1, 2], [3, 0]]).toInt();

a.pow(b).print();  // or tf.pow(a, b)

const a = tf.tensor([[1, 2], [3, 4]])
const b = tf.tensor(2).toInt();

a.pow(b).print();  // or tf.pow(a, b)

We also expose powStrict which has the same signature as this op and asserts that base and exp are the same shape (does not broadcast).
Parameters:

    base (tf.Tensor|TypedArray|Array) The base tf.Tensor to pow element-wise.
    exp (tf.Tensor|TypedArray|Array) The exponent tf.Tensor to pow element-wise.

Returns: tf.Tensor
tf.squaredDifference (a, b) function Source

Returns (a - b) * (a - b) element-wise. Supports broadcasting.

const a = tf.tensor1d([1, 4, 3, 16]);
const b = tf.tensor1d([1, 2, 9, 4]);

a.squaredDifference(b).print();  // or tf.squaredDifference(a, b)

// Broadcast squared difference  a with b.
const a = tf.tensor1d([2, 4, 6, 8]);
const b = tf.scalar(5);

a.squaredDifference(b).print();  // or tf.squaredDifference(a, b)

Parameters:

    a (tf.Tensor|TypedArray|Array) The first tensor.
    b (tf.Tensor|TypedArray|Array) The second tensor. Must have the same type as a.

Returns: tf.Tensor
Operations / Basic math
tf.abs (x) function Source

Computes absolute value element-wise: abs(x)

const x = tf.tensor1d([-1, 2, -3, 4]);

x.abs().print();  // or tf.abs(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tf.Tensor.

Returns: tf.Tensor
tf.acos (x) function Source

Computes acos of the input tf.Tensor element-wise: acos(x)

const x = tf.tensor1d([0, 1, -1, .7]);

x.acos().print();  // or tf.acos(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.acosh (x) function Source

Computes the inverse hyperbolic cos of the input tf.Tensor element-wise: acosh(x)

const x = tf.tensor1d([10, 1, 3, 5.7]);

x.acosh().print();  // or tf.acosh(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.asin (x) function Source

Computes asin of the input tf.Tensor element-wise: asin(x)

const x = tf.tensor1d([0, 1, -1, .7]);

x.asin().print();  // or tf.asin(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.asinh (x) function Source

Computes inverse hyperbolic sin of the input tf.Tensor element-wise: asinh(x)

const x = tf.tensor1d([0, 1, -1, .7]);

x.asinh().print();  // or tf.asinh(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.atan (x) function Source

Computes atan of the input tf.Tensor element-wise: atan(x)

const x = tf.tensor1d([0, 1, -1, .7]);

x.atan().print();  // or tf.atan(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.atan2 (a, b) function Source

Computes arctangent of tf.Tensors a / b element-wise: atan2(a, b). Supports broadcasting.

const a = tf.tensor1d([1.0, 1.0, -1.0, .7]);
const b = tf.tensor1d([2.0, 13.0, 3.5, .21]);

tf.atan2(a, b).print()

Parameters:

    a (tf.Tensor|TypedArray|Array) The first tensor.
    b (tf.Tensor|TypedArray|Array) The second tensor. Must have the same dtype as a.

Returns: tf.Tensor
tf.atanh (x) function Source

Computes inverse hyperbolic tan of the input tf.Tensor element-wise: atanh(x)

const x = tf.tensor1d([0, .1, -.1, .7]);

x.atanh().print();  // or tf.atanh(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.ceil (x) function Source

Computes ceiling of input tf.Tensor element-wise: ceil(x)

const x = tf.tensor1d([.6, 1.1, -3.3]);

x.ceil().print();  // or tf.ceil(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input Tensor.

Returns: tf.Tensor
tf.clipByValue (x, clipValueMin, clipValueMax) function Source

Clips values element-wise. max(min(x, clipValueMax), clipValueMin)

const x = tf.tensor1d([-1, 2, -3, 4]);

x.clipByValue(-2, 3).print();  // or tf.clipByValue(x, -2, 3)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.
    clipValueMin (number) Lower bound of range to be clipped to.
    clipValueMax (number) Upper bound of range to be clipped to.

Returns: tf.Tensor
tf.cos (x) function Source

Computes cos of the input tf.Tensor element-wise: cos(x)

const x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);

x.cos().print();  // or tf.cos(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor. Must be float32 type.

Returns: tf.Tensor
tf.cosh (x) function Source

Computes hyperbolic cos of the input tf.Tensor element-wise: cosh(x)

const x = tf.tensor1d([0, 1, -1, .7]);

x.cosh().print();  // or tf.cosh(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor. Must be float32 type.

Returns: tf.Tensor
tf.elu (x) function Source

Computes exponential linear element-wise: x > 0 ? x : (e ^ x) - 1.

const x = tf.tensor1d([-1, 1, -3, 2]);

x.elu().print();  // or tf.elu(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.erf (x) function Source

Computes Gauss error function of the input tf.Tensor element-wise: erf(x)

const x = tf.tensor1d([0, .1, -.1, .7]);

x.erf().print(); // or tf.erf(x);

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.exp (x) function Source

Computes exponential of the input tf.Tensor element-wise. e ^ x

const x = tf.tensor1d([1, 2, -3]);

x.exp().print();  // or tf.exp(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.expm1 (x) function Source

Computes exponential of the input tf.Tensor minus one element-wise. e ^ x - 1

const x = tf.tensor1d([1, 2, -3]);

x.expm1().print();  // or tf.expm1(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.floor (x) function Source

Computes floor of input tf.Tensor element-wise: floor(x).

const x = tf.tensor1d([.6, 1.1, -3.3]);

x.floor().print();  // or tf.floor(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.isFinite (x) function Source

Returns which elements of x are finite.

const x = tf.tensor1d([NaN, Infinity, -Infinity, 0, 1]);

x.isFinite().print();  // or tf.isNaN(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input Tensor.

Returns: tf.Tensor
tf.isInf (x) function Source

Returns which elements of x are Infinity or -Infinity.

const x = tf.tensor1d([NaN, Infinity, -Infinity, 0, 1]);

x.isInf().print();  // or tf.isNaN(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input Tensor.

Returns: tf.Tensor
tf.isNaN (x) function Source

Returns which elements of x are NaN.

const x = tf.tensor1d([NaN, Infinity, -Infinity, 0, 1]);

x.isNaN().print();  // or tf.isNaN(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input Tensor.

Returns: tf.Tensor
tf.leakyRelu (x, alpha?) function Source

Computes leaky rectified linear element-wise.

See http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf

const x = tf.tensor1d([-1, 2, -3, 4]);

x.leakyRelu(0.1).print();  // or tf.leakyRelu(x, 0.1)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.
    alpha (number) The scaling factor for negative values, defaults to 0.2. Optional

Returns: tf.Tensor
tf.log (x) function Source

Computes natural logarithm of the input tf.Tensor element-wise: ln(x)

const x = tf.tensor1d([1, 2, Math.E]);

x.log().print();  // or tf.log(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.log1p (x) function Source

Computes natural logarithm of the input tf.Tensor plus one element-wise: ln(1 + x)

const x = tf.tensor1d([1, 2, Math.E - 1]);

x.log1p().print();  // or tf.log1p(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.logSigmoid (x) function Source

Computes log sigmoid of the input tf.Tensor element-wise: logSigmoid(x). For numerical stability, we use -tf.softplus(-x).

const x = tf.tensor1d([0, 1, -1, .7]);

x.logSigmoid().print();  // or tf.logSigmoid(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.neg (x) function Source

Computes -1 * x element-wise.

const x = tf.tensor2d([1, 2, -2, 0], [2, 2]);

x.neg().print();  // or tf.neg(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.prelu (x, alpha) function Source

Computes leaky rectified linear element-wise with parametric alphas.

x < 0 ? alpha * x : f(x) = x

const x = tf.tensor1d([-1, 2, -3, 4]);
const alpha = tf.scalar(0.1);

x.prelu(alpha).print();  // or tf.prelu(x, alpha)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.
    alpha (tf.Tensor|TypedArray|Array) Scaling factor for negative values.

Returns: tf.Tensor
tf.reciprocal (x) function Source

Computes reciprocal of x element-wise: 1 / x

const x = tf.tensor1d([0, 1, 2]);

x.reciprocal().print();  // or tf.reciprocal(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.relu (x) function Source

Computes rectified linear element-wise: max(x, 0).

const x = tf.tensor1d([-1, 2, -3, 4]);

x.relu().print();  // or tf.relu(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor. If the dtype is bool, the output dtype will be int32.

Returns: tf.Tensor
tf.relu6 (x) function Source

Computes rectified linear 6 element-wise: min(max(x, 0), 6).

const x = tf.tensor1d([-1, 2, -3, 8]);

x.relu6().print();  // or tf.relu6(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor. If the dtype is bool, the output dtype will be int32.

Returns: tf.Tensor
tf.round (x) function Source

Computes round of input tf.Tensor element-wise: round(x). It implements banker's rounding.

const x = tf.tensor1d([.6, 1.1, -3.3]);

x.round().print();  // or tf.round(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.rsqrt (x) function Source

Computes reciprocal of square root of the input tf.Tensor element-wise: y = 1 / sqrt(x)

const x = tf.tensor1d([1, 2, 4, -1]);

x.rsqrt().print();  // or tf.rsqrt(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.selu (x) function Source

Computes scaled exponential linear element-wise.

x < 0 ? scale * alpha * (exp(x) - 1) : scale * x

const x = tf.tensor1d([-1, 2, -3, 4]);

x.selu().print();  // or tf.selu(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.sigmoid (x) function Source

Computes sigmoid element-wise, 1 / (1 + exp(-x))

const x = tf.tensor1d([0, -1, 2, -3]);

x.sigmoid().print();  // or tf.sigmoid(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.sign (x) function Source

Returns an element-wise indication of the sign of a number.

const x = tf.tensor1d([.6, 1.1, -3.3, NaN, 0]);

x.sign().print();  // or tf.sign(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input Tensor.

Returns: tf.Tensor
tf.sin (x) function Source

Computes sin of the input Tensor element-wise: sin(x)

const x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);

x.sin().print();  // or tf.sin(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.sinh (x) function Source

Computes hyperbolic sin of the input tf.Tensor element-wise: sinh(x)

const x = tf.tensor1d([0, 1, -1, .7]);

x.sinh().print();  // or tf.sinh(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.softplus (x) function Source

Computes softplus of the input tf.Tensor element-wise: log(exp(x) + 1)

const x = tf.tensor1d([0, 1, -1, .7]);

x.softplus().print();  // or tf.softplus(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.sqrt (x) function Source

Computes square root of the input tf.Tensor element-wise: y = sqrt(x)

const x = tf.tensor1d([1, 2, 4, -1]);

x.sqrt().print();  // or tf.sqrt(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.square (x) function Source

Computes square of x element-wise: x ^ 2

const x = tf.tensor1d([1, 2, Math.sqrt(2), -1]);

x.square().print();  // or tf.square(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input Tensor.

Returns: tf.Tensor
tf.step (x, alpha?) function Source

Computes step of the input tf.Tensor element-wise: x > 0 ? 1 : alpha

const x = tf.tensor1d([0, 2, -1, -3]);

x.step(.5).print();  // or tf.step(x, .5)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.
    alpha (number) The gradient when input is negative. Defaults to 0. Optional

Returns: tf.Tensor
tf.tan (x) function Source

Computes tan of the input tf.Tensor element-wise, tan(x)

const x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);

x.tan().print();  // or tf.tan(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
tf.tanh (x) function Source

Computes hyperbolic tangent of the input tf.Tensor element-wise: tanh(x)

const x = tf.tensor1d([0, 1, -1, 70]);

x.tanh().print();  // or tf.tanh(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.

Returns: tf.Tensor
Operations / Matrices
tf.dot (t1, t2) function Source

Computes the dot product of two matrices and/or vectors, t1 and t2.

const a = tf.tensor1d([1, 2]);
const b = tf.tensor2d([[1, 2], [3, 4]]);
const c = tf.tensor2d([[1, 2, 3], [4, 5, 6]]);

a.dot(b).print();  // or tf.dot(a, b)
b.dot(a).print();
b.dot(c).print();

Parameters:

    t1 (tf.Tensor|TypedArray|Array) The first tensor in the dot operation.
    t2 (tf.Tensor|TypedArray|Array) The second tensor in the dot operation.

Returns: tf.Tensor
tf.euclideanNorm (x, axis?, keepDims?) function Source

Computes the Euclidean norm of scalar, vectors, and matrices.

const x = tf.tensor1d([1, 2, 3, 4]);

x.euclideanNorm().print();  // or tf.euclideanNorm(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input array.
    axis (number|number[]) Optional. If axis is null (the default), the input is considered a vector and a single vector norm is computed over the entire set of values in the Tensor, i.e. euclideanNorm(x) is equivalent to euclideanNorm(x.reshape([-1])). If axis is an integer, the input is considered a batch of vectors, and axis determines the axis in x over which to compute vector norms. If axis is a 2-tuple of integer it is considered a batch of matrices and axis determines the axes in NDArray over which to compute a matrix norm. Optional
    keepDims (boolean) Optional. If true, the norm has the same dimensionality as the input. Optional

Returns: tf.Tensor
tf.matMul (a, b, transposeA?, transposeB?) function Source

Computes the dot product of two matrices, A * B. These must be matrices.

const a = tf.tensor2d([1, 2], [1, 2]);
const b = tf.tensor2d([1, 2, 3, 4], [2, 2]);

a.matMul(b).print();  // or tf.matMul(a, b)

Parameters:

    a (tf.Tensor|TypedArray|Array) First matrix in dot product operation.
    b (tf.Tensor|TypedArray|Array) Second matrix in dot product operation.
    transposeA (boolean) If true, a is transposed before multiplication. Optional
    transposeB (boolean) If true, b is transposed before multiplication. Optional

Returns: tf.Tensor
tf.norm (x, ord?, axis?, keepDims?) function Source

Computes the norm of scalar, vectors, and matrices. This function can compute several different vector norms (the 1-norm, the Euclidean or 2-norm, the inf-norm, and in general the p-norm for p > 0) and matrix norms (Frobenius, 1-norm, and inf-norm).

const x = tf.tensor1d([1, 2, 3, 4]);

x.norm().print();  // or tf.norm(x)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input array.
    ord (number|'euclidean'|'fro') Optional. Order of the norm. Supported norm types are following:

    ord 	norm for matrices 	norm for vectors
    'euclidean' 	Frobenius norm 	2-norm
    'fro' 	Frobenius norm 	
    Infinity 	max(sum(abs(x), axis=1)) 	max(abs(x))
    -Infinity 	min(sum(abs(x), axis=1)) 	min(abs(x))
    1 	max(sum(abs(x), axis=0)) 	sum(abs(x))
    2 		sum(abs(x)^2)^(1/2)
    Optional
    axis (number|number[]) Optional. If axis is null (the default), the input is considered a vector and a single vector norm is computed over the entire set of values in the Tensor, i.e. norm(x, ord) is equivalent to norm(x.reshape([-1]), ord). If axis is an integer, the input is considered a batch of vectors, and axis determines the axis in x over which to compute vector norms. If axis is a 2-tuple of integer it is considered a batch of matrices and axis determines the axes in NDArray over which to compute a matrix norm. Optional
    keepDims (boolean) Optional. If true, the norm has the same dimensionality as the input. Optional

Returns: tf.Tensor
tf.outerProduct (v1, v2) function Source

Computes the outer product of two vectors, v1 and v2.

const a = tf.tensor1d([1, 2, 3]);
const b = tf.tensor1d([3, 4, 5]);

tf.outerProduct(a, b).print();

Parameters:

    v1 (tf.Tensor1D|TypedArray|Array) The first vector in the outer product operation.
    v2 (tf.Tensor1D|TypedArray|Array) The second vector in the outer product operation.

Returns: tf.Tensor2D
tf.transpose (x, perm?, conjugate?) function Source

Transposes the tf.Tensor. Permutes the dimensions according to perm.

The returned tf.Tensor's dimension i will correspond to the input dimension perm[i]. If perm is not given, it is set to [n-1...0], where n is the rank of the input tf.Tensor. Hence by default, this operation performs a regular matrix transpose on 2-D input tf.Tensors.

const a = tf.tensor2d([1, 2, 3, 4, 5, 6], [2, 3]);

a.transpose().print();  // or tf.transpose(a)

Parameters:

    x (tf.Tensor|TypedArray|Array) The tensor to transpose.
    perm (number[]) The permutation of the dimensions of a. Optional
    conjugate (boolean) Will conjugate complex input if true. Optional

Returns: tf.Tensor
Operations / Convolution
tf.avgPool (x, filterSize, strides, pad, dimRoundingMode?) function Source

Computes the 2D average pooling of an image.
Parameters:

    x (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The input tensor, of rank 4 or rank 3 of shape [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
    filterSize ([number, number]|number) The filter size: [filterHeight, filterWidth]. If filterSize is a single number, then filterHeight == filterWidth.
    strides ([number, number]|number) The strides of the pooling: [strideHeight, strideWidth]. If strides is a single number, then strideHeight == strideWidth.
    pad ('valid'|'same'|number|conv_util.ExplicitPadding) The type of padding algorithm:

        same and stride 1: output will be of same size as input, regardless of filter size.
        valid: output will be smaller than input if filter is larger than 1x1.
        For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
    dimRoundingMode ('floor'|'round'|'ceil') A string from: 'ceil', 'round', 'floor'. If none is provided, it will default to truncate. Optional

Returns: tf.Tensor3D|tf.Tensor4D
tf.avgPool3d (x, filterSize, strides, pad, dimRoundingMode?, dataFormat?) function Source

Computes the 3D average pooling.

const x = tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]);
const result = tf.avgPool3d(x, 2, 1, 'valid');
result.print();

Parameters:

    x (tf.Tensor4D|tf.Tensor5D|TypedArray|Array) The input tensor, of rank 5 or rank 4 of shape [batch, depth, height, width, inChannels].
    filterSize ([number, number, number]|number) The filter size: [filterDepth, filterHeight, filterWidth]. If filterSize is a single number, then filterDepth == filterHeight == filterWidth.
    strides ([number, number, number]|number) The strides of the pooling: [strideDepth, strideHeight, strideWidth]. If strides is a single number, then strideDepth == strideHeight == strideWidth.
    pad ('valid'|'same'|number) The type of padding algorithm.

        same and stride 1: output will be of same size as input, regardless of filter size.
        valid: output will be smaller than input if filter is larger than 1*1x1.
        For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
    dimRoundingMode ('floor'|'round'|'ceil') A string from: 'ceil', 'round', 'floor'. If none is provided, it will default to truncate. Optional
    dataFormat ('NDHWC'|'NCDHW') An optional string from: "NDHWC", "NCDHW". Defaults to "NDHWC". Specify the data format of the input and output data. With the default format "NDHWC", the data is stored in the order of: [batch, depth, height, width, channels]. Only "NDHWC" is currently supported. Optional

Returns: tf.Tensor4D|tf.Tensor5D
tf.conv1d (x, filter, stride, pad, dataFormat?, dilation?, dimRoundingMode?) function Source

Computes a 1D convolution over the input x.
Parameters:

    x (tf.Tensor2D|tf.Tensor3D|TypedArray|Array) The input tensor, of rank 3 or rank 2, of shape [batch, width, inChannels]. If rank 2, batch of 1 is assumed.
    filter (tf.Tensor3D|TypedArray|Array) The filter, rank 3, of shape [filterWidth, inDepth, outDepth].
    stride (number) The number of entries by which the filter is moved right at each step.
    pad ('valid'|'same'|number|conv_util.ExplicitPadding) The type of padding algorithm.

        same and stride 1: output will be of same size as input, regardless of filter size.
        valid: output will be smaller than input if filter is larger than 1x1.
        For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
    dataFormat ('NWC'|'NCW') An optional string from "NWC", "NCW". Defaults to "NWC", the data is stored in the order of [batch, in_width, in_channels]. Only "NWC" is currently supported. Optional
    dilation (number) The dilation rate in which we sample input values in atrous convolution. Defaults to 1. If it is greater than 1, then stride must be 1. Optional
    dimRoundingMode ('floor'|'round'|'ceil') A string from: 'ceil', 'round', 'floor'. If none is provided, it will default to truncate. Optional

Returns: tf.Tensor2D|tf.Tensor3D
tf.conv2d (x, filter, strides, pad, dataFormat?, dilations?, dimRoundingMode?) function Source

Computes a 2D convolution over the input x.
Parameters:

    x (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The input tensor, of rank 4 or rank 3, of shape [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
    filter (tf.Tensor4D|TypedArray|Array) The filter, rank 4, of shape [filterHeight, filterWidth, inDepth, outDepth].
    strides ([number, number]|number) The strides of the convolution: [strideHeight, strideWidth].
    pad ('valid'|'same'|number|conv_util.ExplicitPadding) The type of padding algorithm.

        same and stride 1: output will be of same size as input, regardless of filter size.
        valid: output will be smaller than input if filter is larger than 1x1.
        For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
    dataFormat ('NHWC'|'NCHW') : An optional string from: "NHWC", "NCHW". Defaults to "NHWC". Specify the data format of the input and output data. With the default format "NHWC", the data is stored in the order of: [batch, height, width, channels]. Optional
    dilations ([number, number]|number) The dilation rates: [dilationHeight, dilationWidth] in which we sample input values across the height and width dimensions in atrous convolution. Defaults to [1, 1]. If dilations is a single number, then dilationHeight == dilationWidth. If it is greater than 1, then all values of strides must be 1. Optional
    dimRoundingMode ('floor'|'round'|'ceil') A string from: 'ceil', 'round', 'floor'. If none is provided, it will default to truncate. Optional

Returns: tf.Tensor3D|tf.Tensor4D
tf.conv2dTranspose (x, filter, outputShape, strides, pad, dimRoundingMode?) function Source

Computes the transposed 2D convolution of an image, also known as a deconvolution.
Parameters:

    x (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The input image, of rank 4 or rank 3, of shape [batch, height, width, inDepth]. If rank 3, batch of 1 is assumed.
    filter (tf.Tensor4D|TypedArray|Array) The filter, rank 4, of shape [filterHeight, filterWidth, outDepth, inDepth]. inDepth must match inDepth in x.
    outputShape ([number, number, number, number]|[number, number, number]) Output shape, of rank 4 or rank 3: [batch, height, width, outDepth]. If rank 3, batch of 1 is assumed.
    strides ([number, number]|number) The strides of the original convolution: [strideHeight, strideWidth].
    pad ('valid'|'same'|number|ExplicitPadding) The type of padding algorithm used in the non-transpose version of the op.
    dimRoundingMode ('floor'|'round'|'ceil') A string from: 'ceil', 'round', 'floor'. If none is provided, it will default to truncate. Optional

Returns: tf.Tensor3D|tf.Tensor4D
tf.conv3d (x, filter, strides, pad, dataFormat?, dilations?) function Source

Computes a 3D convolution over the input x.
Parameters:

    x (tf.Tensor4D|tf.Tensor5D|TypedArray|Array) The input tensor, of rank 5 or rank 4, of shape [batch, depth, height, width, channels]. If rank 4, batch of 1 is assumed.
    filter (tf.Tensor5D|TypedArray|Array) The filter, rank 5, of shape [filterDepth, filterHeight, filterWidth, inChannels, outChannels]. inChannels must match between input and filter.
    strides ([number, number, number]|number) The strides of the convolution: [strideDepth, strideHeight, strideWidth].
    pad ('valid'|'same') The type of padding algorithm.

        same and stride 1: output will be of same size as input, regardless of filter size.
        valid: output will be smaller than input if filter is larger than 1x1.
        For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
    dataFormat ('NDHWC'|'NCDHW') : An optional string from: "NDHWC", "NCDHW". Defaults to "NDHWC". Specify the data format of the input and output data. With the default format "NDHWC", the data is stored in the order of: [batch, depth, height, width, channels]. Only "NDHWC" is currently supported. Optional
    dilations ([number, number, number]|number) The dilation rates: [dilationDepth, dilationHeight, dilationWidth] in which we sample input values across the height and width dimensions in atrous convolution. Defaults to [1, 1, 1]. If dilations is a single number, then dilationDepth == dilationHeight == dilationWidth. If it is greater than 1, then all values of strides must be 1. Optional

Returns: tf.Tensor4D|tf.Tensor5D
tf.conv3dTranspose (x, filter, outputShape, strides, pad) function Source

Computes the transposed 3D convolution of a volume, also known as a deconvolution.
Parameters:

    x (tf.Tensor4D|tf.Tensor5D|TypedArray|Array) The input image, of rank 5 or rank 4, of shape [batch, depth, height, width, inDepth]. If rank 4, batch of 1 is assumed.
    filter (tf.Tensor5D|TypedArray|Array) The filter, rank 4, of shape [depth, filterHeight, filterWidth, outDepth, inDepth]. inDepth must match inDepth in x.
    outputShape ([number, number, number, number, number]|[number, number, number, number]) Output shape, of rank 5 or rank 4: [batch, depth, height, width, outDepth]. If rank 3, batch of 1 is assumed.
    strides ([number, number, number]|number) The strides of the original convolution: [strideDepth, strideHeight, strideWidth].
    pad ('valid'|'same') The type of padding algorithm used in the non-transpose version of the op.

Returns: tf.Tensor4D|tf.Tensor5D
tf.depthwiseConv2d (x, filter, strides, pad, dataFormat?, dilations?, dimRoundingMode?) function Source

Depthwise 2D convolution.

Given a 4D input array and a filter array of shape [filterHeight, filterWidth, inChannels, channelMultiplier] containing inChannels convolutional filters of depth 1, this op applies a different filter to each input channel (expanding from 1 channel to channelMultiplier channels for each), then concatenates the results together. The output has inChannels * channelMultiplier channels.

See https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d for more details.
Parameters:

    x (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The input tensor, of rank 4 or rank 3, of shape [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
    filter (tf.Tensor4D|TypedArray|Array) The filter tensor, rank 4, of shape [filterHeight, filterWidth, inChannels, channelMultiplier].
    strides ([number, number]|number) The strides of the convolution: [strideHeight, strideWidth]. If strides is a single number, then strideHeight == strideWidth.
    pad ('valid'|'same'|number|conv_util.ExplicitPadding) The type of padding algorithm.

        same and stride 1: output will be of same size as input, regardless of filter size.
        valid: output will be smaller than input if filter is larger than 1x1.
        For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
    dataFormat ('NHWC'|'NCHW') : An optional string from: "NHWC", "NCHW". Defaults to "NHWC". Specify the data format of the input and output data. With the default format "NHWC", the data is stored in the order of: [batch, height, width, channels]. Only "NHWC" is currently supported. Optional
    dilations ([number, number]|number) The dilation rates: [dilationHeight, dilationWidth] in which we sample input values across the height and width dimensions in atrous convolution. Defaults to [1, 1]. If rate is a single number, then dilationHeight == dilationWidth. If it is greater than 1, then all values of strides must be 1. Optional
    dimRoundingMode ('floor'|'round'|'ceil') A string from: 'ceil', 'round', 'floor'. If none is provided, it will default to truncate. Optional

Returns: tf.Tensor3D|tf.Tensor4D
tf.dilation2d (x, filter, strides, pad, dilations?, dataFormat?) function Source

Computes the grayscale dilation over the input x.
Parameters:

    x (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The input tensor, rank 3 or rank 4 of shape [batch, height, width, depth]. If rank 3, batch of 1 is assumed.
    filter (tf.Tensor3D|TypedArray|Array) The filter tensor, rank 3, of shape [filterHeight, filterWidth, depth].
    strides ([number, number]|number) The strides of the sliding window for each dimension of the input tensor: [strideHeight, strideWidth]. If strides is a single number, then strideHeight == strideWidth.
    pad ('valid'|'same') The type of padding algorithm.

        same and stride 1: output will be of same size as input, regardless of filter size.
        valid: output will be smaller than input if filter is larger than 1*1x1.
        For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
    dilations ([number, number]|number) The dilation rates: [dilationHeight, dilationWidth] in which we sample input values across the height and width dimensions for atrous morphological dilation. Defaults to [1, 1]. If dilations is a single number, then dilationHeight == dilationWidth. If it is greater than 1, then all values of strides must be 1. Optional
    dataFormat ('NHWC') Specify the data format of the input and output data. Defaults to 'NHWC'. Only 'NHWC' is currently supported. With the default format "NHWC", the data is stored in the order of: [batch, height, width, channels]. Optional

Returns: tf.Tensor3D|tf.Tensor4D
tf.maxPool3d (x, filterSize, strides, pad, dimRoundingMode?, dataFormat?) function Source

Computes the 3D max pooling.

const x = tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]);
const result = tf.maxPool3d(x, 2, 1, 'valid');
result.print();

Parameters:

    x (tf.Tensor4D|tf.Tensor5D|TypedArray|Array) The input tensor, of rank 5 or rank 4 of shape [batch, depth, height, width, inChannels].
    filterSize ([number, number, number]|number) The filter size: [filterDepth, filterHeight, filterWidth]. If filterSize is a single number, then filterDepth == filterHeight == filterWidth.
    strides ([number, number, number]|number) The strides of the pooling: [strideDepth, strideHeight, strideWidth]. If strides is a single number, then strideDepth == strideHeight == strideWidth.
    pad ('valid'|'same'|number) The type of padding algorithm.

        same and stride 1: output will be of same size as input, regardless of filter size.
        valid: output will be smaller than input if filter is larger than 1*1x1.
        For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
    dimRoundingMode ('floor'|'round'|'ceil') A string from: 'ceil', 'round', 'floor'. If none is provided, it will default to truncate. Optional
    dataFormat ('NDHWC'|'NCDHW') An optional string from: "NDHWC", "NCDHW". Defaults to "NDHWC". Specify the data format of the input and output data. With the default format "NDHWC", the data is stored in the order of: [batch, depth, height, width, channels]. Only "NDHWC" is currently supported. Optional

Returns: tf.Tensor4D|tf.Tensor5D
tf.maxPoolWithArgmax (x, filterSize, strides, pad, includeBatchInIndex?) function Source

Computes the 2D max pooling of an image with Argmax index. The indices in argmax are flattened, so that a maximum value at position [b, y, x, c] becomes flattened index: (y * width + x) * channels + c if include_batch_in_index is False; ((b * height + y) * width + x) * channels +c if include_batch_in_index is True.

The indices returned are always in [0, height) x [0, width) before flattening.
Parameters:

    x (tf.Tensor4D|TypedArray|Array) The input tensor, of rank 4 or rank 3 of shape [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
    filterSize ([number, number]|number) The filter size: [filterHeight, filterWidth]. If filterSize is a single number, then filterHeight == filterWidth.
    strides ([number, number]|number) The strides of the pooling: [strideHeight, strideWidth]. If strides is a single number, then strideHeight == strideWidth.
    pad ('valid'|'same'|number) The type of padding algorithm.

        same and stride 1: output will be of same size as input, regardless of filter size.
        valid: output will be smaller than input if filter is larger than 1x1.
        For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
    includeBatchInIndex (boolean) Optional

Returns: {[name: string]: tf.Tensor}
tf.pool (input, windowShape, poolingType, pad, dilations?, strides?, dimRoundingMode?) function Source

Performs an N-D pooling operation
Parameters:

    input (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The input tensor, of rank 4 or rank 3 of shape [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
    windowShape ([number, number]|number) The filter size: [filterHeight, filterWidth]. If filterSize is a single number, then filterHeight == filterWidth.
    poolingType ('avg'|'max') The type of pooling, either 'max' or 'avg'.
    pad ('valid'|'same'|number|conv_util.ExplicitPadding) The type of padding algorithm:

        same and stride 1: output will be of same size as input, regardless of filter size.
        valid: output will be smaller than input if filter is larger than 1x1.
        For more info, see this guide: https://www.tensorflow.org/api_guides/python/nn#Convolution
    dilations ([number, number]|number) The dilation rates: [dilationHeight, dilationWidth] in which we sample input values across the height and width dimensions in dilated pooling. Defaults to [1, 1]. If dilationRate is a single number, then dilationHeight == dilationWidth. If it is greater than 1, then all values of strides must be 1. Optional
    strides ([number, number]|number) The strides of the pooling: [strideHeight, strideWidth]. If strides is a single number, then strideHeight == strideWidth. Optional
    dimRoundingMode ('floor'|'round'|'ceil') A string from: 'ceil', 'round', 'floor'. If none is provided, it will default to truncate. Optional

Returns: tf.Tensor3D|tf.Tensor4D
tf.separableConv2d (x, depthwiseFilter, pointwiseFilter, strides, pad, dilation?, dataFormat?) function Source

2-D convolution with separable filters.

Performs a depthwise convolution that acts separately on channels followed by a pointwise convolution that mixes channels. Note that this is separability between dimensions [1, 2] and 3, not spatial separability between dimensions 1 and 2.

See https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d for more details.
Parameters:

    x (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The input tensor, of rank 4 or rank 3, of shape [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
    depthwiseFilter (tf.Tensor4D|TypedArray|Array) The depthwise filter tensor, rank 4, of shape [filterHeight, filterWidth, inChannels, channelMultiplier]. This is the filter used in the first step.
    pointwiseFilter (tf.Tensor4D|TypedArray|Array) The pointwise filter tensor, rank 4, of shape [1, 1, inChannels * channelMultiplier, outChannels]. This is the filter used in the second step.
    strides ([number, number]|number) The strides of the convolution: [strideHeight, strideWidth]. If strides is a single number, then strideHeight == strideWidth.
    pad ('valid'|'same') The type of padding algorithm.

        same and stride 1: output will be of same size as input, regardless of filter size.
        valid: output will be smaller than input if filter is larger than 1x1.
        For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
    dilation ([number, number]|number) Optional
    dataFormat ('NHWC'|'NCHW') : An optional string from: "NHWC", "NCHW". Defaults to "NHWC". Specify the data format of the input and output data. With the default format "NHWC", the data is stored in the order of: [batch, height, width, channels]. Only "NHWC" is currently supported. Optional

Returns: tf.Tensor3D|tf.Tensor4D
Operations / Reduction
tf.all (x, axis?, keepDims?) function Source

Computes the logical and of elements across dimensions of a tf.Tensor.

Reduces the input along the dimensions given in axes. Unless keepDims is true, the rank of the tf.Tensor is reduced by 1 for each entry in axes. If keepDims is true, the reduced dimensions are retained with length 1. If axes has no entries, all dimensions are reduced, and a tf.Tensor with a single element is returned.

const x = tf.tensor1d([1, 1, 1], 'bool');

x.all().print();  // or tf.all(x)

const x = tf.tensor2d([1, 1, 0, 0], [2, 2], 'bool');

const axis = 1;
x.all(axis).print();  // or tf.all(x, axis)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor. Must be of dtype bool.
    axis (number|number[]) The dimension(s) to reduce. By default it reduces all dimensions. Optional
    keepDims (boolean) If true, retains reduced dimensions with size 1. Optional

Returns: tf.Tensor
tf.any (x, axis?, keepDims?) function Source

Computes the logical or of elements across dimensions of a tf.Tensor.

Reduces the input along the dimensions given in axes. Unless keepDims is true, the rank of the tf.Tensor is reduced by 1 for each entry in axes. If keepDims is true, the reduced dimensions are retained with length 1. If axes has no entries, all dimensions are reduced, and a tf.Tensor with a single element is returned.

const x = tf.tensor1d([1, 1, 1], 'bool');

x.any().print();  // or tf.any(x)

const x = tf.tensor2d([1, 1, 0, 0], [2, 2], 'bool');

const axis = 1;
x.any(axis).print();  // or tf.any(x, axis)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor. Must be of dtype bool.
    axis (number|number[]) The dimension(s) to reduce. By default it reduces all dimensions. Optional
    keepDims (boolean) If true, retains reduced dimensions with size 1. Optional

Returns: tf.Tensor
tf.argMax (x, axis?) function Source

Returns the indices of the maximum values along an axis.

The result has the same shape as input with the dimension along axis removed.

const x = tf.tensor1d([1, 2, 3]);

x.argMax().print();  // or tf.argMax(x)

const x = tf.tensor2d([1, 2, 4, 3], [2, 2]);

const axis = 1;
x.argMax(axis).print();  // or tf.argMax(x, axis)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.
    axis (number) The dimension to reduce. Defaults to 0 (outer-most dimension). Optional

Returns: tf.Tensor
tf.argMin (x, axis?) function Source

Returns the indices of the minimum values along an axis.

The result has the same shape as input with the dimension along axis removed.

const x = tf.tensor1d([1, 2, 3]);

x.argMin().print();  // or tf.argMin(x)

const x = tf.tensor2d([1, 2, 4, 3], [2, 2]);

const axis = 1;
x.argMin(axis).print();  // or tf.argMin(x, axis)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.
    axis (number) The dimension to reduce. Defaults to 0 (outer-most dimension). Optional

Returns: tf.Tensor
tf.bincount (x, weights, size) function Source

Outputs a vector with length size and the same dtype as weights.

If weights are empty, then index i stores the number of times the value i is counted in x. If weights are non-empty, then index i stores the sum of the value in weights at each index where the corresponding value in x is i.

Values in x outside of the range [0, size) are ignored.
Parameters:

    x (tf.Tensor1D|TypedArray|Array) The input int tensor, rank 1.
    weights (tf.Tensor1D|TypedArray|Array) The weights tensor, must have the same shape as x, or a length-0 Tensor, in which case it acts as all weights equal to 1.
    size (number) Non-negative integer.

Returns: tf.Tensor1D
tf.denseBincount (x, weights, size, binaryOutput?) function Source

Outputs a vector with length size and the same dtype as weights.

If weights are empty, then index i stores the number of times the value i is counted in x. If weights are non-empty, then index i stores the sum of the value in weights at each index where the corresponding value in x is i.

Values in x outside of the range [0, size) are ignored.
Parameters:

    x (tf.Tensor1D|tf.Tensor2D|TypedArray|Array) The input int tensor, rank 1 or rank 2.
    weights (tf.Tensor1D|tf.Tensor2D|TypedArray|Array) The weights tensor, must have the same shape as x, or a length-0 Tensor, in which case it acts as all weights equal to 1.
    size (number) Non-negative integer.
    binaryOutput (boolean) Optional. Whether the kernel should count the appearance or number of occurrences. Defaults to False. Optional

Returns: tf.Tensor1D|tf.Tensor2D
tf.logSumExp (x, axis?, keepDims?) function Source

Computes the log(sum(exp(elements across the reduction dimensions))).

Reduces the input along the dimensions given in axis. Unless keepDims is true, the rank of the array is reduced by 1 for each entry in axis. If keepDims is true, the reduced dimensions are retained with length 1. If axis has no entries, all dimensions are reduced, and an array with a single element is returned.

const x = tf.tensor1d([1, 2, 3]);

x.logSumExp().print();  // or tf.logSumExp(x)

const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);

const axis = 1;
x.logSumExp(axis).print();  // or tf.logSumExp(a, axis)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.
    axis (number|number[]) The dimension(s) to reduce. If null (the default), reduces all dimensions. Optional
    keepDims (boolean) If true, retains reduced dimensions with length of 1. Defaults to false. Optional

Returns: tf.Tensor
tf.max (x, axis?, keepDims?) function Source

Computes the maximum of elements across dimensions of a tf.Tensor.

Reduces the input along the dimensions given in axes. Unless keepDims is true, the rank of the tf.Tensor is reduced by 1 for each entry in axes. If keepDims is true, the reduced dimensions are retained with length 1. If axes has no entries, all dimensions are reduced, and a tf.Tensor with a single element is returned.

const x = tf.tensor1d([1, 2, 3]);

x.max().print();  // or tf.max(x)

const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);

const axis = 1;
x.max(axis).print();  // or tf.max(x, axis)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.
    axis (number|number[]) The dimension(s) to reduce. By default it reduces all dimensions. Optional
    keepDims (boolean) If true, retains reduced dimensions with size 1. Optional

Returns: tf.Tensor
tf.mean (x, axis?, keepDims?) function Source

Computes the mean of elements across dimensions of a tf.Tensor.

Reduces x along the dimensions given in axis. Unless keepDims is true, the rank of the tf.Tensor is reduced by 1 for each entry in axis. If keepDims is true, the reduced dimensions are retained with length 1. If axis has no entries, all dimensions are reduced, and a tf.Tensor with a single element is returned.

const x = tf.tensor1d([1, 2, 3]);

x.mean().print();  // or tf.mean(a)

const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);

const axis = 1;
x.mean(axis).print();  // or tf.mean(x, axis)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.
    axis (number|number[]) The dimension(s) to reduce. By default it reduces all dimensions. Optional
    keepDims (boolean) If true, retains reduced dimensions with size 1. Optional

Returns: tf.Tensor
tf.min (x, axis?, keepDims?) function Source

Computes the minimum value from the input.

Reduces the input along the dimensions given in axes. Unless keepDims is true, the rank of the array is reduced by 1 for each entry in axes. If keepDims is true, the reduced dimensions are retained with length 1. If axes has no entries, all dimensions are reduced, and an array with a single element is returned.

const x = tf.tensor1d([1, 2, 3]);

x.min().print();  // or tf.min(x)

const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);

const axis = 1;
x.min(axis).print();  // or tf.min(x, axis)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input Tensor.
    axis (number|number[]) The dimension(s) to reduce. By default it reduces all dimensions. Optional
    keepDims (boolean) If true, retains reduced dimensions with size 1. Optional

Returns: tf.Tensor
tf.prod (x, axis?, keepDims?) function Source

Computes the product of elements across dimensions of a tf.Tensor.

Reduces the input along the dimensions given in axes. Unless keepDims is true, the rank of the tf.Tensor is reduced by 1 for each entry in axes. If keepDims is true, the reduced dimensions are retained with length 1. If axes has no entries, all dimensions are reduced, and a tf.Tensor with a single element is returned.

const x = tf.tensor1d([1, 2, 3]);

x.prod().print();  // or tf.prod(x)

const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);

const axis = 1;
x.prod(axis).print();  // or tf.prod(x, axis)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor to compute the product over. If the dtype is bool it will be converted to int32 and the output dtype will be int32.
    axis (number|number[]) The dimension(s) to reduce. By default it reduces all dimensions. Optional
    keepDims (boolean) If true, retains reduced dimensions with size 1. Optional

Returns: tf.Tensor
tf.sum (x, axis?, keepDims?) function Source

Computes the sum of elements across dimensions of a tf.Tensor.

Reduces the input along the dimensions given in axes. Unless keepDims is true, the rank of the tf.Tensor is reduced by 1 for each entry in axes. If keepDims is true, the reduced dimensions are retained with length 1. If axes has no entries, all dimensions are reduced, and a tf.Tensor with a single element is returned.

const x = tf.tensor1d([1, 2, 3]);

x.sum().print();  // or tf.sum(x)

const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);

const axis = 1;
x.sum(axis).print();  // or tf.sum(x, axis)

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor to compute the sum over. If the dtype is bool it will be converted to int32 and the output dtype will be int32.
    axis (number|number[]) The dimension(s) to reduce. By default it reduces all dimensions. Optional
    keepDims (boolean) If true, retains reduced dimensions with size 1. Optional

Returns: tf.Tensor
Operations / Normalization
tf.batchNorm (x, mean, variance, offset?, scale?, varianceEpsilon?) function Source

Batch normalization.

As described in http://arxiv.org/abs/1502.03167.

Mean, variance, scale, and offset can be of two shapes:

    The same shape as the input.
    In the common case, the depth dimension is the last dimension of x, so the values would be a tf.Tensor1D of shape [depth].

Also available are stricter rank-specific methods with the same signature as this method that assert that parameters passed are of given rank

    tf.batchNorm2d
    tf.batchNorm3d
    tf.batchNorm4d

Parameters:

    x (tf.Tensor|TypedArray|Array) The input Tensor.
    mean (tf.Tensor|tf.Tensor1D|TypedArray|Array) A mean Tensor.
    variance (tf.Tensor|tf.Tensor1D|TypedArray|Array) A variance Tensor.
    offset (tf.Tensor|tf.Tensor1D|TypedArray|Array) An offset Tensor. Optional
    scale (tf.Tensor|tf.Tensor1D|TypedArray|Array) A scale Tensor. Optional
    varianceEpsilon (number) A small float number to avoid dividing by 0. Optional

Returns: tf.Tensor
tf.localResponseNormalization (x, depthRadius?, bias?, alpha?, beta?) function Source

Normalizes the activation of a local neighborhood across or within channels.
Parameters:

    x (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The input tensor. The 4-D input tensor is treated as a 3-D array of 1D vectors (along the last dimension), and each vector is normalized independently.
    depthRadius (number) The number of adjacent channels in the 1D normalization window. Optional
    bias (number) A constant bias term for the basis. Optional
    alpha (number) A scale factor, usually positive. Optional
    beta (number) An exponent. Optional

Returns: tf.Tensor3D|tf.Tensor4D
tf.logSoftmax (logits, axis?) function Source

Computes the log softmax.

const a = tf.tensor1d([1, 2, 3]);

a.logSoftmax().print();  // or tf.logSoftmax(a)

const a = tf.tensor2d([2, 4, 6, 1, 2, 3], [2, 3]);

a.logSoftmax().print();  // or tf.logSoftmax(a)

Parameters:

    logits (tf.Tensor|TypedArray|Array) The logits array.
    axis (number) The dimension softmax would be performed on. Defaults to -1 which indicates the last dimension. Optional

Returns: tf.Tensor
tf.moments (x, axis?, keepDims?) function Source

Calculates the mean and variance of x. The mean and variance are calculated by aggregating the contents of x across axes. If x is 1-D and axes = [0] this is just the mean and variance of a vector.
Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor.
    axis (number|number[]) The dimension(s) along with to compute mean and variance. By default it reduces all dimensions. Optional
    keepDims (boolean) If true, the moments have the same dimensionality as the input. Optional

Returns: {mean: tf.Tensor, variance: tf.Tensor}
tf.softmax (logits, dim?) function Source

Computes the softmax normalized vector given the logits.

const a = tf.tensor1d([1, 2, 3]);

a.softmax().print();  // or tf.softmax(a)

const a = tf.tensor2d([2, 4, 6, 1, 2, 3], [2, 3]);

a.softmax().print();  // or tf.softmax(a)

Parameters:

    logits (tf.Tensor|TypedArray|Array) The logits array.
    dim (number) The dimension softmax would be performed on. Defaults to -1 which indicates the last dimension. Optional

Returns: tf.Tensor
tf.sparseToDense (sparseIndices, sparseValues, outputShape, defaultValue?) function Source

Converts a sparse representation into a dense tensor.

Builds an array dense with shape outputShape such that:

// If sparseIndices is scalar dense[i] = (i == sparseIndices ? sparseValues : defaultValue)

// If sparseIndices is a vector, then for each i dense[sparseIndices[i]] = sparseValues[i]

// If sparseIndices is an n by d matrix, then for each i in [0, n) dense[sparseIndices[i][0], ..., sparseIndices[i][d-1]] = sparseValues[i] All other values in dense are set to defaultValue. If sparseValues is a scalar, all sparse indices are set to this single value.

If indices are repeated the final value is summed over all values for those indices.

const indices = tf.tensor1d([4, 5, 6, 1, 2, 3], 'int32');
const values = tf.tensor1d([10, 11, 12, 13, 14, 15], 'float32');
const shape = [8];
tf.sparseToDense(indices, values, shape).print();

Parameters:

    sparseIndices (tf.Tensor|TypedArray|Array) A 0-D, 1-D, or 2-D Tensor of type int32. sparseIndices[i] contains the complete index where sparseValues[i] will be placed.
    sparseValues (tf.Tensor|TypedArray|Array) A 0-D or 1-D Tensor. Values corresponding to each row of sparseIndices, or a scalar value to be used for all sparse indices.
    outputShape (number[]) Shape of the dense output tensor. The type is inferred.
    defaultValue (tf.Scalar|ScalarLike) Scalar. Value to set for indices not specified in sparseIndices. Defaults to zero. Optional

Returns: tf.Tensor
Operations / Images
tf.image.cropAndResize (image, boxes, boxInd, cropSize, method?, extrapolationValue?) function Source

Extracts crops from the input image tensor and resizes them using bilinear sampling or nearest neighbor sampling (possibly with aspect ratio change) to a common output size specified by cropSize.
Parameters:

    image (tf.Tensor4D|TypedArray|Array) 4d tensor of shape [batch,imageHeight,imageWidth, depth], where imageHeight and imageWidth must be positive, specifying the batch of images from which to take crops
    boxes (tf.Tensor2D|TypedArray|Array) 2d float32 tensor of shape [numBoxes, 4]. Each entry is [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the normalized coordinates of the box in the boxInd[i]th image in the batch
    boxInd (tf.Tensor1D|TypedArray|Array) 1d int32 tensor of shape [numBoxes] with values in range [0, batch) that specifies the image that the i-th box refers to.
    cropSize ([number, number]) 1d int32 tensor of 2 elements [cropHeigh, cropWidth] specifying the size to which all crops are resized to.
    method ('bilinear'|'nearest') Optional string from 'bilinear' | 'nearest', defaults to bilinear, which specifies the sampling method for resizing Optional
    extrapolationValue (number) A threshold for deciding when to remove boxes based on score. Defaults to 0. Optional

Returns: tf.Tensor4D
tf.image.flipLeftRight (image) function Source

Flips the image left to right. Currently available in the CPU, WebGL, and WASM backends.
Parameters:

    image (tf.Tensor4D|TypedArray|Array) 4d tensor of shape [batch, imageHeight, imageWidth, depth].

Returns: tf.Tensor4D
tf.image.grayscaleToRGB (image) function Source

Converts images from grayscale to RGB format.
Parameters:

    image (tf.Tensor2D|tf.Tensor3D|tf.Tensor4D|tf.Tensor5D| tf.Tensor6D|TypedArray|Array) A grayscale tensor to convert. The image's last dimension must be size 1 with at least a two-dimensional shape.

Returns: tf.Tensor2D|tf.Tensor3D|tf.Tensor4D|tf.Tensor5D| tf.Tensor6D
tf.image.nonMaxSuppression (boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?) function Source

Performs non maximum suppression of bounding boxes based on iou (intersection over union).
Parameters:

    boxes (tf.Tensor2D|TypedArray|Array) a 2d tensor of shape [numBoxes, 4]. Each entry is [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the corners of the bounding box.
    scores (tf.Tensor1D|TypedArray|Array) a 1d tensor providing the box scores of shape [numBoxes].
    maxOutputSize (number) The maximum number of boxes to be selected.
    iouThreshold (number) A float representing the threshold for deciding whether boxes overlap too much with respect to IOU. Must be between [0, 1]. Defaults to 0.5 (50% box overlap). Optional
    scoreThreshold (number) A threshold for deciding when to remove boxes based on score. Defaults to -inf, which means any score is accepted. Optional

Returns: tf.Tensor1D
tf.image.nonMaxSuppressionAsync (boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?) function Source

Performs non maximum suppression of bounding boxes based on iou (intersection over union).

This is the async version of nonMaxSuppression
Parameters:

    boxes (tf.Tensor2D|TypedArray|Array) a 2d tensor of shape [numBoxes, 4]. Each entry is [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the corners of the bounding box.
    scores (tf.Tensor1D|TypedArray|Array) a 1d tensor providing the box scores of shape [numBoxes].
    maxOutputSize (number) The maximum number of boxes to be selected.
    iouThreshold (number) A float representing the threshold for deciding whether boxes overlap too much with respect to IOU. Must be between [0, 1]. Defaults to 0.5 (50% box overlap). Optional
    scoreThreshold (number) A threshold for deciding when to remove boxes based on score. Defaults to -inf, which means any score is accepted. Optional

Returns: Promise<tf.Tensor1D>
tf.image.nonMaxSuppressionPadded (boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?, padToMaxOutputSize?) function Source

Asynchronously performs non maximum suppression of bounding boxes based on iou (intersection over union), with an option to pad results.
Parameters:

    boxes (tf.Tensor2D|TypedArray|Array) a 2d tensor of shape [numBoxes, 4]. Each entry is [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the corners of the bounding box.
    scores (tf.Tensor1D|TypedArray|Array) a 1d tensor providing the box scores of shape [numBoxes].
    maxOutputSize (number) The maximum number of boxes to be selected.
    iouThreshold (number) A float representing the threshold for deciding whether boxes overlap too much with respect to IOU. Must be between [0, 1]. Defaults to 0.5 (50% box overlap). Optional
    scoreThreshold (number) A threshold for deciding when to remove boxes based on score. Defaults to -inf, which means any score is accepted. Optional
    padToMaxOutputSize (boolean) Defaults to false. If true, size of output selectedIndices is padded to maxOutputSize. Optional

Returns: {[name: string]: tf.Tensor}
tf.image.nonMaxSuppressionPaddedAsync (boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?, padToMaxOutputSize?) function Source

Asynchronously performs non maximum suppression of bounding boxes based on iou (intersection over union), with an option to pad results.
Parameters:

    boxes (tf.Tensor2D|TypedArray|Array) a 2d tensor of shape [numBoxes, 4]. Each entry is [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the corners of the bounding box.
    scores (tf.Tensor1D|TypedArray|Array) a 1d tensor providing the box scores of shape [numBoxes].
    maxOutputSize (number) The maximum number of boxes to be selected.
    iouThreshold (number) A float representing the threshold for deciding whether boxes overlap too much with respect to IOU. Must be between [0, 1]. Defaults to 0.5 (50% box overlap). Optional
    scoreThreshold (number) A threshold for deciding when to remove boxes based on score. Defaults to -inf, which means any score is accepted. Optional
    padToMaxOutputSize (boolean) Defaults to false. If true, size of output selectedIndices is padded to maxOutputSize. Optional

Returns: Promise<{[name: string]: tf.Tensor}>
tf.image.nonMaxSuppressionWithScore (boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?, softNmsSigma?) function Source

Performs non maximum suppression of bounding boxes based on iou (intersection over union).

This op also supports a Soft-NMS mode (cf. Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score of other overlapping boxes, therefore favoring different regions of the image with high scores. To enable this Soft-NMS mode, set the softNmsSigma parameter to be larger than 0.
Parameters:

    boxes (tf.Tensor2D|TypedArray|Array) a 2d tensor of shape [numBoxes, 4]. Each entry is [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the corners of the bounding box.
    scores (tf.Tensor1D|TypedArray|Array) a 1d tensor providing the box scores of shape [numBoxes].
    maxOutputSize (number) The maximum number of boxes to be selected.
    iouThreshold (number) A float representing the threshold for deciding whether boxes overlap too much with respect to IOU. Must be between [0, 1]. Defaults to 0.5 (50% box overlap). Optional
    scoreThreshold (number) A threshold for deciding when to remove boxes based on score. Defaults to -inf, which means any score is accepted. Optional
    softNmsSigma (number) A float representing the sigma parameter for Soft NMS. When sigma is 0, it falls back to nonMaxSuppression. Optional

Returns: {[name: string]: tf.Tensor}
tf.image.nonMaxSuppressionWithScoreAsync (boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?, softNmsSigma?) function Source

Asynchronously performs non maximum suppression of bounding boxes based on iou (intersection over union).

This op also supports a Soft-NMS mode (cf. Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score of other overlapping boxes, therefore favoring different regions of the image with high scores. To enable this Soft-NMS mode, set the softNmsSigma parameter to be larger than 0.
Parameters:

    boxes (tf.Tensor2D|TypedArray|Array) a 2d tensor of shape [numBoxes, 4]. Each entry is [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the corners of the bounding box.
    scores (tf.Tensor1D|TypedArray|Array) a 1d tensor providing the box scores of shape [numBoxes].
    maxOutputSize (number) The maximum number of boxes to be selected.
    iouThreshold (number) A float representing the threshold for deciding whether boxes overlap too much with respect to IOU. Must be between [0, 1]. Defaults to 0.5 (50% box overlap). Optional
    scoreThreshold (number) A threshold for deciding when to remove boxes based on score. Defaults to -inf, which means any score is accepted. Optional
    softNmsSigma (number) A float representing the sigma parameter for Soft NMS. When sigma is 0, it falls back to nonMaxSuppression. Optional

Returns: Promise<{[name: string]: tf.Tensor}>
tf.image.resizeBilinear (images, size, alignCorners?, halfPixelCenters?) function Source

Bilinear resize a single 3D image or a batch of 3D images to a new shape.
Parameters:

    images (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The images, of rank 4 or rank 3, of shape [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
    size ([number, number]) The new shape [newHeight, newWidth] to resize the images to. Each channel is resized individually.
    alignCorners (boolean) Defaults to false. If true, rescale input by (new_height - 1) / (height - 1), which exactly aligns the 4 corners of images and resized images. If false, rescale by new_height / height. Treat similarly the width dimension. Optional
    halfPixelCenters (boolean) Defaults to false. Whether to assume pixel centers are at 0.5, which would make the floating point coordinates of the top left pixel 0.5, 0.5. Optional

Returns: tf.Tensor3D|tf.Tensor4D
tf.image.resizeNearestNeighbor (images, size, alignCorners?, halfPixelCenters?) function Source

NearestNeighbor resize a batch of 3D images to a new shape.
Parameters:

    images (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The images, of rank 4 or rank 3, of shape [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
    size ([number, number]) The new shape [newHeight, newWidth] to resize the images to. Each channel is resized individually.
    alignCorners (boolean) Defaults to False. If true, rescale input by (new_height - 1) / (height - 1), which exactly aligns the 4 corners of images and resized images. If false, rescale by new_height / height. Treat similarly the width dimension. Optional
    halfPixelCenters (boolean) Defaults to false. Whether to assume pixels are of half the actual dimensions, and yield more accurate resizes. This flag would also make the floating point coordinates of the top left pixel 0.5, 0.5. Optional

Returns: tf.Tensor3D|tf.Tensor4D
tf.image.rgbToGrayscale (image) function Source

Converts images from RGB format to grayscale.
Parameters:

    image (tf.Tensor2D|tf.Tensor3D|tf.Tensor4D|tf.Tensor5D| tf.Tensor6D|TypedArray|Array) A RGB tensor to convert. The image's last dimension must be size 3 with at least a two-dimensional shape.

Returns: tf.Tensor2D|tf.Tensor3D|tf.Tensor4D|tf.Tensor5D| tf.Tensor6D
tf.image.rotateWithOffset (image, radians, fillValue?, center?) function Source

Rotates the input image tensor counter-clockwise with an optional offset center of rotation. Currently available in the CPU, WebGL, and WASM backends.
Parameters:

    image (tf.Tensor4D|TypedArray|Array) 4d tensor of shape [batch, imageHeight, imageWidth, depth].
    radians (number) The amount of rotation.
    fillValue (number|[number, number, number]) The value to fill in the empty space leftover after rotation. Can be either a single grayscale value (0-255), or an array of three numbers [red, green, blue] specifying the red, green, and blue channels. Defaults to 0 (black). Optional
    center (number|[number, number]) The center of rotation. Can be either a single value (0-1), or an array of two numbers [centerX, centerY]. Defaults to 0.5 (rotates the image around its center). Optional

Returns: tf.Tensor4D
tf.image.transform (image, transforms, interpolation?, fillMode?, fillValue?, outputShape?) function Source

Applies the given transform(s) to the image(s).
Parameters:

    image (tf.Tensor4D|TypedArray|Array) 4d tensor of shape [batch, imageHeight, imageWidth, depth].
    transforms (tf.Tensor2D|TypedArray|Array) Projective transform matrix/matrices. A tensor1d of length 8 or tensor of size N x 8. If one row of transforms is [a0, a1, a2, b0, b1, b2, c0, c1], then it maps the output point (x, y) to a transformed input point (x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k), where k = c0 x + c1 y + 1. The transforms are inverted compared to the transform mapping input points to output points.
    interpolation ('nearest'|'bilinear') Interpolation mode. Supported values: 'nearest', 'bilinear'. Default to 'nearest'. Optional
    fillMode ('constant'|'reflect'|'wrap'|'nearest') Points outside the boundaries of the input are filled according to the given mode, one of 'constant', 'reflect', 'wrap', 'nearest'. Default to 'constant'. 'reflect': (d c b a | a b c d | d c b a ) The input is extended by reflecting about the edge of the last pixel. 'constant': (k k k k | a b c d | k k k k) The input is extended by filling all values beyond the edge with the same constant value k. 'wrap': (a b c d | a b c d | a b c d) The input is extended by wrapping around to the opposite edge. 'nearest': (a a a a | a b c d | d d d d) The input is extended by the nearest pixel. Optional
    fillValue (number) A float represents the value to be filled outside the boundaries when fillMode is 'constant'. Optional
    outputShape ([number, number]) Optional

Returns: tf.Tensor4D
Operations / RNN
tf.basicLSTMCell (forgetBias, lstmKernel, lstmBias, data, c, h) function Source

Computes the next state and output of a BasicLSTMCell.

Returns [newC, newH].

Derived from tf.contrib.rnn.BasicLSTMCell.
Parameters:

    forgetBias (tf.Scalar|TypedArray|Array) Forget bias for the cell.
    lstmKernel (tf.Tensor2D|TypedArray|Array) The weights for the cell.
    lstmBias (tf.Tensor1D|TypedArray|Array) The bias for the cell.
    data (tf.Tensor2D|TypedArray|Array) The input to the cell.
    c (tf.Tensor2D|TypedArray|Array) Previous cell state.
    h (tf.Tensor2D|TypedArray|Array) Previous cell output.

Returns: [tf.Tensor2D, tf.Tensor2D]
tf.multiRNNCell (lstmCells, data, c, h) function Source

Computes the next states and outputs of a stack of LSTMCells.

Each cell output is used as input to the next cell.

Returns [cellState, cellOutput].

Derived from tf.contrib.rn.MultiRNNCell.
Parameters:

    lstmCells ((data: tf.Tensor2D, c: tf.Tensor2D, h: tf.Tensor2D): [tf.Tensor2D, tf.Tensor2D][]) Array of LSTMCell functions.
    data (tf.Tensor2D|TypedArray|Array) The input to the cell.
    c (Array) Array of previous cell states.
    h (Array) Array of previous cell outputs.

Returns: [tf.Tensor2D[], tf.Tensor2D[]]
Operations / Logical
tf.bitwiseAnd (x, y) function Source

Bitwise AND operation for input tensors.

Given two input tensors, returns a new tensor with the AND calculated values.

The method supports int32 values

const x = tf.tensor1d([0, 5, 3, 14], 'int32');
const y = tf.tensor1d([5, 0, 7, 11], 'int32');
tf.bitwiseAnd(x, y).print();

Parameters:

    x (tf.Tensor) The input tensor to be calculated.
    y (tf.Tensor) The input tensor to be calculated.

Returns: tf.Tensor
tf.equal (a, b) function Source

Returns the truth value of (a == b) element-wise. Supports broadcasting.

const a = tf.tensor1d([1, 2, 3]);
const b = tf.tensor1d([2, 2, 2]);

a.equal(b).print();

Parameters:

    a (tf.Tensor|TypedArray|Array) The first input tensor.
    b (tf.Tensor|TypedArray|Array) The second input tensor. Must have the same dtype as a.

Returns: tf.Tensor
tf.greater (a, b) function Source

Returns the truth value of (a > b) element-wise. Supports broadcasting.

const a = tf.tensor1d([1, 2, 3]);
const b = tf.tensor1d([2, 2, 2]);

a.greater(b).print();

Parameters:

    a (tf.Tensor|TypedArray|Array) The first input tensor.
    b (tf.Tensor|TypedArray|Array) The second input tensor. Must have the same dtype as a.

Returns: tf.Tensor
tf.greaterEqual (a, b) function Source

Returns the truth value of (a >= b) element-wise. Supports broadcasting.

const a = tf.tensor1d([1, 2, 3]);
const b = tf.tensor1d([2, 2, 2]);

a.greaterEqual(b).print();

Parameters:

    a (tf.Tensor|TypedArray|Array) The first input tensor.
    b (tf.Tensor|TypedArray|Array) The second input tensor. Must have the same dtype as a.

Returns: tf.Tensor
tf.less (a, b) function Source

Returns the truth value of (a < b) element-wise. Supports broadcasting.

const a = tf.tensor1d([1, 2, 3]);
const b = tf.tensor1d([2, 2, 2]);

a.less(b).print();

Parameters:

    a (tf.Tensor|TypedArray|Array) The first input tensor.
    b (tf.Tensor|TypedArray|Array) The second input tensor. Must have the same dtype as a.

Returns: tf.Tensor
tf.lessEqual (a, b) function Source

Returns the truth value of (a <= b) element-wise. Supports broadcasting.

const a = tf.tensor1d([1, 2, 3]);
const b = tf.tensor1d([2, 2, 2]);

a.lessEqual(b).print();

Parameters:

    a (tf.Tensor|TypedArray|Array) The first input tensor.
    b (tf.Tensor|TypedArray|Array) The second input tensor. Must have the same dtype as a.

Returns: tf.Tensor
tf.logicalAnd (a, b) function Source

Returns the truth value of a AND b element-wise. Supports broadcasting.

const a = tf.tensor1d([false, false, true, true], 'bool');
const b = tf.tensor1d([false, true, false, true], 'bool');

a.logicalAnd(b).print();

Parameters:

    a (tf.Tensor|TypedArray|Array) The first input tensor. Must be of dtype bool.
    b (tf.Tensor|TypedArray|Array) The second input tensor. Must be of dtype bool.

Returns: tf.Tensor
tf.logicalNot (x) function Source

Returns the truth value of NOT x element-wise.

const a = tf.tensor1d([false, true], 'bool');

a.logicalNot().print();

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor. Must be of dtype 'bool'.

Returns: tf.Tensor
tf.logicalOr (a, b) function Source

Returns the truth value of a OR b element-wise. Supports broadcasting.

const a = tf.tensor1d([false, false, true, true], 'bool');
const b = tf.tensor1d([false, true, false, true], 'bool');

a.logicalOr(b).print();

Parameters:

    a (tf.Tensor|TypedArray|Array) The first input tensor. Must be of dtype bool.
    b (tf.Tensor|TypedArray|Array) The second input tensor. Must be of dtype bool.

Returns: tf.Tensor
tf.logicalXor (a, b) function Source

Returns the truth value of a XOR b element-wise. Supports broadcasting.

const a = tf.tensor1d([false, false, true, true], 'bool');
const b = tf.tensor1d([false, true, false, true], 'bool');

a.logicalXor(b).print();

Parameters:

    a (tf.Tensor|TypedArray|Array) The first input tensor. Must be of dtype bool.
    b (tf.Tensor|TypedArray|Array) The second input tensor. Must be of dtype bool.

Returns: tf.Tensor
tf.notEqual (a, b) function Source

Returns the truth value of (a != b) element-wise. Supports broadcasting.

const a = tf.tensor1d([1, 2, 3]);
const b = tf.tensor1d([0, 2, 3]);

a.notEqual(b).print();

Parameters:

    a (tf.Tensor|TypedArray|Array) The first input tensor.
    b (tf.Tensor|TypedArray|Array) The second input tensor. Must have the same dtype as a.

Returns: tf.Tensor
tf.where (condition, a, b) function Source

Returns the elements, either a or b depending on the condition.

If the condition is true, select from a, otherwise select from b.

const cond = tf.tensor1d([false, false, true], 'bool');
const a = tf.tensor1d([1 , 2, 3]);
const b = tf.tensor1d([-1, -2, -3]);

a.where(cond, b).print();

Parameters:

    condition (tf.Tensor|TypedArray|Array) The input condition. Must be of dtype bool.
    a (tf.Tensor|TypedArray|Array) If condition is rank 1, a may have a higher rank but its first dimension must match the size of condition.
    b (tf.Tensor|TypedArray|Array) A tensor with the same dtype as a and with shape that is compatible with a.

Returns: tf.Tensor
tf.whereAsync (condition) function Source

Returns the coordinates of true elements of condition.

The coordinates are returned in a 2-D tensor where the first dimension (rows) represents the number of true elements, and the second dimension (columns) represents the coordinates of the true elements. Keep in mind, the shape of the output tensor can vary depending on how many true values there are in input. Indices are output in row-major order. The resulting tensor has the shape [numTrueElems, condition.rank].

This is analogous to calling the python tf.where(cond) without an x or y.

const cond = tf.tensor1d([false, false, true], 'bool');
const result = await tf.whereAsync(cond);
result.print();

Parameters:

    condition (tf.Tensor|TypedArray|Array)

Returns: Promise<tf.Tensor2D>
Operations / Scan
tf.cumprod (x, axis?, exclusive?, reverse?) function Source

Computes the cumulative product of a tf.Tensor along axis.

const x = tf.tensor([1, 2, 3, 4]);
x.cumprod().print();

const x = tf.tensor([[1, 2], [3, 4]]);
x.cumprod().print();

Parameters:

    x (tf.Tensor | TypedArray|Array) The input tensor to cumulatively multiply.
    axis (number) The axis along which to multiply. Optional. Defaults to 0. Optional
    exclusive (boolean) Whether to perform exclusive cumulative product. Optional. Defaults to false. If set to true then the product of each tensor entry does not include its own value, but only the values previous to it along the specified axis. Optional
    reverse (boolean) Whether to multiply in the opposite direction. Optional. Defaults to false. Optional

Returns: tf.Tensor
tf.cumsum (x, axis?, exclusive?, reverse?) function Source

Computes the cumulative sum of a tf.Tensor along axis.

const x = tf.tensor([1, 2, 3, 4]);
x.cumsum().print();

const x = tf.tensor([[1, 2], [3, 4]]);
x.cumsum().print();

Parameters:

    x (tf.Tensor|TypedArray|Array) The input tensor to be summed.
    axis (number) The axis along which to sum. Optional. Defaults to 0. Optional
    exclusive (boolean) Whether to perform exclusive cumulative sum. Optional. Defaults to false. If set to true then the sum of each tensor entry does not include its own value, but only the values previous to it along the specified axis. Optional
    reverse (boolean) Whether to sum in the opposite direction. Optional. Defaults to false. Optional

Returns: tf.Tensor
Operations / Evaluation
tf.confusionMatrix (labels, predictions, numClasses) function Source

Computes the confusion matrix from true labels and predicted labels.

const labels = tf.tensor1d([0, 1, 2, 1, 0], 'int32');
const predictions = tf.tensor1d([0, 2, 2, 1, 0], 'int32');
const numClasses = 3;
const out = tf.math.confusionMatrix(labels, predictions, numClasses);
out.print();
// Expected output matrix:
// [[2, 0, 0],
//  [0, 1, 1],
//  [0, 0, 1]]

Parameters:

    labels (tf.Tensor1D|TypedArray|Array) The target labels, assumed to be 0-based integers for the classes. The shape is [numExamples], where numExamples is the number of examples included.
    predictions (tf.Tensor1D|TypedArray|Array) The predicted classes, assumed to be 0-based integers for the classes. Must have the same shape as labels.
    numClasses (number) Number of all classes, as an integer. Its value must be larger than the largest element in labels and predictions.

Returns: tf.Tensor2D
tf.inTopKAsync (predictions, targets, k?) function Source

Returns whether the targets are in the top K predictions.

const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);
const targets = tf.tensor1d([2, 0]);
const precision = await tf.inTopKAsync(predictions, targets);
precision.print();

Parameters:

    predictions (tf.Tensor|TypedArray|Array) 2-D or higher tf.Tensor with last dimension being at least k.
    targets (tf.Tensor|TypedArray|Array) 1-D or higher tf.Tensor.
    k (number) Optional Number of top elements to look at for computing precision, default to 1. Optional

Returns: Promise<tf.Tensor>
tf.lowerBound (sortedSequence, values) function Source

Searches for where a value would go in a sorted sequence.

This is not a method for checking containment (like javascript in).

The typical use case for this operation is "binning", "bucketing", or "discretizing". The values are assigned to bucket-indices based on the edges listed in 'sortedSequence'. This operation returns the bucket-index for each value.

The index returned corresponds to the first edge greater than or equal to the value.

The axis is not settable for this operation. It always operates on the innermost dimension (axis=-1). The operation will accept any number of outer dimensions.

Note: This operation assumes that 'lowerBound' is sorted along the innermost axis, maybe using 'sort(..., axis=-1)'. If the sequence is not sorted no error is raised and the content of the returned tensor is not well defined.

const edges = tf.tensor1d([-1, 3.3, 9.1, 10.0]);
let values = tf.tensor1d([0.0, 4.1, 12.0]);
const result1 = tf.lowerBound(edges, values);
result1.print(); // [1, 2, 4]

const seq = tf.tensor1d([0, 3, 9, 10, 10]);
values = tf.tensor1d([0, 4, 10]);
const result2 = tf.lowerBound(seq, values);
result2.print(); // [0, 2, 3]

const sortedSequence = tf.tensor2d([[0., 3., 8., 9., 10.],
                                     [1., 2., 3., 4., 5.]]);
values = tf.tensor2d([[9.8, 2.1, 4.3],
                       [0.1, 6.6, 4.5, ]]);
const result3 = tf.lowerBound(sortedSequence, values);
result3.print(); // [[4, 1, 2], [0, 5, 4]]

Parameters:

    sortedSequence (tf.Tensor|TypedArray|Array) : N-D. Sorted sequence.
    values (tf.Tensor|TypedArray|Array) : N-D. Search values.

Returns: tf.Tensor
tf.searchSorted (sortedSequence, values, side?) function Source

Searches for where a value would go in a sorted sequence.

This is not a method for checking containment (like javascript in).

The typical use case for this operation is "binning", "bucketing", or "discretizing". The values are assigned to bucket-indices based on the edges listed in 'sortedSequence'. This operation returns the bucket-index for each value.

The side argument controls which index is returned if a value lands exactly on an edge.

The axis is not settable for this operation. It always operates on the innermost dimension (axis=-1). The operation will accept any number of outer dimensions.

Note: This operation assumes that 'sortedSequence' is sorted along the innermost axis, maybe using 'sort(..., axis=-1)'. If the sequence is not sorted no error is raised and the content of the returned tensor is not well defined.

const edges = tf.tensor1d([-1, 3.3, 9.1, 10.0]);
let values = tf.tensor1d([0.0, 4.1, 12.0]);
const result1 = tf.searchSorted(edges, values, 'left');
result1.print(); // [1, 2, 4]

const seq = tf.tensor1d([0, 3, 9, 10, 10]);
values = tf.tensor1d([0, 4, 10]);
const result2 = tf.searchSorted(seq, values, 'left');
result2.print(); // [0, 2, 3]
const result3 = tf.searchSorted(seq, values, 'right');
result3.print(); // [1, 2, 5]

const sortedSequence = tf.tensor2d([[0., 3., 8., 9., 10.],
                                     [1., 2., 3., 4., 5.]]);
values = tf.tensor2d([[9.8, 2.1, 4.3],
                       [0.1, 6.6, 4.5, ]]);
const result4 = tf.searchSorted(sortedSequence, values, 'left');
result4.print(); // [[4, 1, 2], [0, 5, 4]]

Parameters:

    sortedSequence (tf.Tensor|TypedArray|Array) : N-D. Sorted sequence.
    values (tf.Tensor|TypedArray|Array) : N-D. Search values.
    side ('left'|'right') : 'left'|'right'. Defaults to 'left'. 'left' corresponds to lower bound and 'right' to upper bound. Optional

Returns: tf.Tensor
tf.topk (x, k?, sorted?) function Source

Finds the values and indices of the k largest entries along the last dimension.

If the input is a vector (rank=1), finds the k largest entries in the vector and outputs their values and indices as vectors. Thus values[j] is the j-th largest entry in input, and its index is indices[j]. For higher rank inputs, computes the top k entries along the last dimension.

If two elements are equal, the lower-index element appears first.

const a = tf.tensor2d([[1, 5], [4, 3]]);
const {values, indices} = tf.topk(a);
values.print();
indices.print();

Parameters:

    x (tf.Tensor|TypedArray|Array) 1-D or higher tf.Tensor with last dimension being at least k.
    k (number) Number of top elements to look for along the last dimension. Optional
    sorted (boolean) If true, the resulting k elements will be sorted by the values in descending order. Optional

Returns: {values: tf.Tensor, indices: tf.Tensor}
tf.unique (x, axis?) function Source

Finds unique elements along an axis of a tensor.

It returns a tensor values containing all of the unique elements along the axis of the given tensor x in the same order that they occur along the axis in x; x does not need to be sorted. It also returns a tensor indices the same size as the number of the elements in x along the axis dimension. It contains the index in the unique output values.

// A 1-D tensor
const a = tf.tensor1d([1, 1, 2, 4, 4, 4, 7, 8, 8]);
const {values, indices} = tf.unique(a);
values.print();   // [1, 2, 4, 7, 8,]
indices.print();  // [0, 0, 1, 2, 2, 2, 3, 4, 4]

// A 2-D tensor with axis=0
//
// 'a' is: [[1, 0, 0],
//          [1, 0, 0],
//          [2, 0, 0]]
const a = tf.tensor2d([[1, 0, 0], [1, 0, 0], [2, 0, 0]]);
const {values, indices} = tf.unique(a, 0)
values.print();   // [[1, 0, 0],
                   //  [2, 0, 0]]
indices.print();  // [0, 0, 1]

// A 2-D tensor with axis=1
//
// 'a' is: [[1, 0, 0],
//          [1, 0, 0],
//          [2, 0, 0]]
const a = tf.tensor2d([[1, 0, 0], [1, 0, 0], [2, 0, 0]]);
const {values, indices} = tf.unique(a, 1)
values.print();   // [[1, 0],
                   //  [1, 0],
                   //  [2, 0]]
indices.print();  // [0, 1, 1]

Parameters:

    x (tf.Tensor|TypedArray|Array) A tensor (int32, string, bool).
    axis (number) The axis of the tensor to find the unique elements. Optional

Returns: {values: tf.Tensor, indices: tf.Tensor1D}
tf.upperBound (sortedSequence, values) function Source

Searches for where a value would go in a sorted sequence.

This is not a method for checking containment (like javascript in).

The typical use case for this operation is "binning", "bucketing", or "discretizing". The values are assigned to bucket-indices based on the edges listed in 'sortedSequence'. This operation returns the bucket-index for each value.

The index returned corresponds to the first edge greater than the value.

The axis is not settable for this operation. It always operates on the innermost dimension (axis=-1). The operation will accept any number of outer dimensions.

Note: This operation assumes that 'upperBound' is sorted along the innermost axis, maybe using 'sort(..., axis=-1)'. If the sequence is not sorted no error is raised and the content of the returned tensor is not well defined.

const seq = tf.tensor1d([0, 3, 9, 10, 10]);
const values = tf.tensor1d([0, 4, 10]);
const result = tf.upperBound(seq, values);
result.print(); // [1, 2, 5]

Parameters:

    sortedSequence (tf.Tensor|TypedArray|Array) : N-D. Sorted sequence.
    values (tf.Tensor|TypedArray|Array) : N-D. Search values.

Returns: tf.Tensor
Operations / Slicing and Joining
tf.gatherND (x, indices) function Source

Gather slices from input tensor into a Tensor with shape specified by indices.

indices is a K-dimensional integer tensor, best thought of as a (K-1)-dimensional tensor of indices into input, where each element defines a slice of input: output[\(i_0, ..., i_{K-2}\)] = input[indices[\(i_0, ..., i_{K-2}\)]]

Whereas in tf.gather(), indices defines slices into the first dimension of input, in tf.gatherND(), indices defines slices into the first N dimensions of input, where N = indices.shape[-1].

The last dimension of indices can be at most the rank of input: indices.shape[-1] <= input.rank

The last dimension of indices corresponds to elements (if indices.shape[-1] == input.rank) or slices (if indices.shape[-1] < input.rank) along dimension indices.shape[-1] of input. The output tensor has shape indices.shape[:-1] + input.shape[indices.shape[-1]:]

Note that on CPU, if an out of bound index is found, an error is returned. On GPU, if an out of bound index is found, a 0 is stored in the corresponding output value.

const indices = tf.tensor2d([0, 1, 1, 0], [2,2], 'int32');
const input = tf.tensor2d([9, 10, 11, 12], [2, 2]);
tf.gatherND(input, indices).print() // [10, 11]

Parameters:

    x (tf.Tensor|TypedArray|Array) The tensor from which to gather values.
    indices (tf.Tensor|TypedArray|Array) Index tensor, must be of type int32.

Returns: tf.Tensor
tf.meshgrid (x?, y?, __2?) function Source

Broadcasts parameters for evaluation on an N-D grid.

Given N one-dimensional coordinate arrays *args, returns a list outputs of N-D coordinate arrays for evaluating expressions on an N-D grid.

Notes: meshgrid supports cartesian ('xy') and matrix ('ij') indexing conventions. When the indexing argument is set to 'xy' (the default), the broadcasting instructions for the first two dimensions are swapped. Examples: Calling const [X, Y] = meshgrid(x, y) with the tensors

const x = [1, 2, 3];
const y = [4, 5, 6];
const [X, Y] = tf.meshgrid(x, y);
// X = [[1, 2, 3],
//      [1, 2, 3],
//      [1, 2, 3]]
// Y = [[4, 4, 4],
//      [5, 5, 5],
//      [6, 6, 6]]

Parameters:

    x (tf.Tensor|TypedArray|Array) Tensor with rank geq 1. Optional
    y (tf.Tensor|TypedArray|Array) Tensor with rank geq 1. Optional
    __2 ({ indexing?: string; }) Optional

Returns: tf.Tensor[]
tf.scatterND (indices, updates, shape) function Source

Creates a new tensor by applying sparse updates to individual values or slices within a zero tensor of the given shape tensor according to indices. This operator is the inverse of the tf.gatherND() operator which extracts values or slices from a given tensor.

const indices = tf.tensor2d([4, 3, 1, 7], [4, 1], 'int32');
const updates = tf.tensor1d([9, 10, 11, 12]);
const shape = [8];
tf.scatterND(indices, updates, shape).print() //[0, 11, 0, 10, 9, 0, 0, 12]

Parameters:

    indices (tf.Tensor|TypedArray|Array) The tensor contains the indices into the output tensor.
    updates (tf.Tensor|TypedArray|Array) The tensor contains the value for the indices.
    shape (number[]) : The shape of the output tensor.

Returns: tf.Tensor
tf.stridedSlice (x, begin, end, strides?, beginMask?, endMask?, ellipsisMask?, newAxisMask?, shrinkAxisMask?) function Source

Extracts a strided slice of a tensor.

Roughly speaking, this op extracts a slice of size (end-begin)/stride from the given input tensor (x). Starting at the location specified by begin the slice continues by adding stride to the index until all dimensions are not less than end. Note that a stride can be negative, which causes a reverse slice.

const t = tf.tensor3d([1, 1, 1 ,2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6],
    [3, 2, 3]);
t.stridedSlice([1, 0, 0], [2, 1, 3], [1, 1, 1]).print()  // [[[3, 3, 3]]]
t.stridedSlice([1, 0, 0], [2, 2, 3], [1, 1, 1]).print()  // [[[3, 3, 3],
                                                     // [4, 4, 4]]]
t.stridedSlice([1, -1, 0], [2, -3, 3], [1, -1, 1]).print() // [[[4, 4, 4],
                                                     // [3, 3, 3]]]

Parameters:

    x (tf.Tensor|TypedArray|Array) The tensor to stride slice.
    begin (number[]) The coordinates to start the slice from.
    end (number[]) : The coordinates to end the slice at.
    strides (number[]) : The size of the slice. Optional
    beginMask (number) : If the ith bit of beginMask is set, begin[i] is ignored and the fullest possible range in that dimension is used instead. Optional
    endMask (number) : If the ith bit of endMask is set, end[i] is ignored and the fullest possible range in that dimension is used instead. Optional
    ellipsisMask (number) Optional
    newAxisMask (number) Optional
    shrinkAxisMask (number) : a bitmask where bit i implies that the ith specification should shrink the dimensionality. begin and end must imply a slice of size 1 in the dimension. Optional

Returns: tf.Tensor
tf.tensorScatterUpdate (tensor, indices, updates) function Source

Creates a new tensor by applying sparse updates to individual values or slices to the passed in tensor according to indices. This operator is the similar to scatterNd op, except that the udpates are scattered on an existing tensor (as opposed to a zero-tensor).

If indices contains duplicates, then we pick the last update for the index.

If an out of bound index is found on CPU, an error is returned.

Warning: There are some GPU specific semantics for this operation.

    If an out of bound index is found, the index is ignored.
    The order in which updates are applied is nondeterministic, so the output will be nondeterministic if indices contains duplicates.

const shape = [8];
const tensor = tf.ones(shape);
const indices = tf.tensor2d([4, 3, 1, 7], [4, 1], 'int32');
const updates = tf.tensor1d([9, 10, 11, 12]);

tf.tensorScatterUpdate(tensor, indices, updates).print();
    //[1, 11, 1, 10, 9, 1, 1, 12]

Parameters:

    tensor (tf.Tensor|TypedArray|Array) A Tensor. Tensor to copy/update.
    indices (tf.Tensor|TypedArray|Array) The tensor contains the indices into the output tensor, must have at least 2 axes: (num_updates, index_depth).
    updates (tf.Tensor|TypedArray|Array) The tensor contains the value for the indices.

Returns: tf.Tensor
Operations / Ragged
tf.raggedTensorToTensor (shape, values, defaultValue, rowPartitionTensors, rowPartitionTypes) function Source

Create a dense tensor from a ragged tensor, possibly altering its shape.

The raggedTensorToTensor op creates a dense tensor from am array of row partition tensors, a value vector, and default values. If the shape is unspecified, the minimal shape required to contain all the elements in the ragged tensor (the natural shape) will be used. If some dimensions are left unspecified, then the size of the natural shape is used in that dimension.

The defaultValue will be broadcast to the output shape. After that, the values from the ragged tensor overwrite the default values. Note that the defaultValue must have less dimensions than the value.

The row partition tensors are in the order of the dimensions. At present, the types can be: "ROW_SPLITS": the row_splits tensor from the ragged tensor. "VALUE_ROWIDS": the value_rowids tensor from the ragged tensor. "FIRST_DIM_SIZE": if value_rowids is used for the first dimension, then it is preceded by "FIRST_DIM_SIZE".

Parameters:

    shape (tf.Tensor|TypedArray|Array) : A Tensor. Must be one of the following types: 'int32'. The desired shape of the output tensor. If left unspecified (empty), the minimal shape required to contain all the elements in the ragged tensor (the natural shape) will be used. If some dimensions are left unspecified, then the size of the natural shape is used in that dimension.

    Note that dense dimensions cannot be modified by the shape argument. Trying to change the size of a dense dimension will cause the op to fail. Examples: natural shape: [4, 5, 6] shape: -1 output shape: [4, 5, 6]

    natural shape: [4, 5, 6] shape: [3, -1, 2] output shape: [3, 5, 2]

    natural shape: [4, 5, 6] shape: [3, 7, 2] output shape: [3, 7, 2]
    values (tf.Tensor|TypedArray|Array) : A Tensor. A 1D tensor representing the values of the ragged tensor.
    defaultValue (tf.Tensor|TypedArray|Array) : A Tensor. Must have the same type as values. The defaultValue when the shape is larger than the ragged tensor. The defaultValue is broadcast until it is the shape of the output tensor, and then overwritten by values in the ragged tensor. The default value must be compatible with this broadcast operation, and must have fewer dimensions than the value tensor.
    rowPartitionTensors (tf.Tensor[]) : A list of at least 1 Tensor objects with the same type in: 'int32'.
    rowPartitionTypes (string[]) : A list of strings. The types of the row partition tensors. At present, these can be: "ROW_SPLITS": the row_splits tensor from the ragged tensor. "VALUE_ROWIDS": the value_rowids tensor from the ragged tensor. "FIRST_DIM_SIZE": if value_rowids is used for the first dimension, then it is preceded by "FIRST_DIM_SIZE". The tensors are in the order of the dimensions.

Returns: tf.Tensor
Operations / Spectral
tf.spectral.fft (input) function Source

Fast Fourier transform.

Computes the 1-dimensional discrete Fourier transform over the inner-most dimension of input.

const real = tf.tensor1d([1, 2, 3]);
const imag = tf.tensor1d([1, 2, 3]);
const x = tf.complex(real, imag);

x.fft().print();  // tf.spectral.fft(x).print();

Parameters:

    input (tf.Tensor) The complex input to compute an fft over.

Returns: tf.Tensor
tf.spectral.ifft (input) function Source

Inverse fast Fourier transform.

Computes the inverse 1-dimensional discrete Fourier transform over the inner-most dimension of input.

const real = tf.tensor1d([1, 2, 3]);
const imag = tf.tensor1d([1, 2, 3]);
const x = tf.complex(real, imag);

x.ifft().print();  // tf.spectral.ifft(x).print();

Parameters:

    input (tf.Tensor) The complex input to compute an ifft over.

Returns: tf.Tensor
tf.spectral.irfft (input) function Source

Inversed real value input fast Fourier transform.

Computes the 1-dimensional inversed discrete Fourier transform over the inner-most dimension of the real input.

const real = tf.tensor1d([1, 2, 3]);
const imag = tf.tensor1d([0, 0, 0]);
const x = tf.complex(real, imag);

x.irfft().print();

Parameters:

    input (tf.Tensor) The real value input to compute an irfft over.

Returns: tf.Tensor
tf.spectral.rfft (input, fftLength?) function Source

Real value input fast Fourier transform.

Computes the 1-dimensional discrete Fourier transform over the inner-most dimension of the real input.

const real = tf.tensor1d([1, 2, 3]);

real.rfft().print();

Parameters:

    input (tf.Tensor) The real value input to compute an rfft over.
    fftLength (number) Optional

Returns: tf.Tensor
Operations / Segment
tf.unsortedSegmentSum (x, segmentIds, numSegments) function Source

Computes the sum along segments of a tf.Tensor.

const x = tf.tensor1d([1, 2, 3, 4]);
const segmentIds = tf.tensor1d([1, 2, 0, 1], 'int32');
const numSegments = 3;

x.unsortedSegmentSum(segmentIds, numSegments).print()
//or tf.unsortedSegmentSum(x, segmentIds, numSegments)

Parameters:

    x (tf.Tensor|TypedArray|Array) The tf.Tensor that will be summed along its segments.
    segmentIds (tf.Tensor1D|TypedArray|Array) A tf.Tensor1D whose rank is equal to the rank of x's dimension along the axis. Maps each element of x to a segment.
    numSegments (number) The number of distinct segmentIds.

Returns: tf.Tensor
Operations / Moving Average
tf.movingAverage (v, x, decay, step?, zeroDebias?) function Source

Compute the moving average of a variable.

Without zeroDebias, the moving average operation is defined by: v += delta where delta = (1 - decay) * (x - v)

With zeroDebias (default), the delta term is scaled to debias the effect of the (assumed) zero-initialization of v. delta /= (1 - decay ^ step)

For more details on the zero-debiasing algorithm, see: https://arxiv.org/abs/1412.6980

Note that this function is completely stateless and does not keep track of step count. The step count needs to be maintained by the caller and passed in as step.
Parameters:

    v (tf.Tensor|TypedArray|Array) The current moving average value.
    x (tf.Tensor|TypedArray|Array) New input value, must have the same shape and dtype as v.
    decay (number|tf.Scalar) The decay factor. Typical values are 0.95 and 0.99.
    step (number|tf.Scalar) Step count. Optional
    zeroDebias (boolean) : Whether zeroDebias is to be performed (default: true). Optional

Returns: tf.Tensor
Operations / Dropout
tf.dropout (x, rate, noiseShape?, seed?) function Source

Computes dropout.

const x = tf.tensor1d([1, 2, 2, 1]);
const rate = 0.75;
const output = tf.dropout(x, rate);
output.print();

Parameters:

    x (tf.Tensor|TypedArray|Array) A floating point Tensor or TensorLike.
    rate (number) A float in the range [0, 1). The probability that each element of x is discarded.
    noiseShape (number[]) An array of numbers of type int32, representing the shape for randomly generated keep/drop flags. If the noiseShape has null value, it will be automatically replaced with the x's relative dimension size. Optional. Optional
    seed (number|string) Used to create random seeds. Optional. Optional

Returns: tf.Tensor
Operations / Signal
tf.signal.frame (signal, frameLength, frameStep, padEnd?, padValue?) function Source

Expands input into frames of frameLength. Slides a window size with frameStep.

tf.signal.frame([1, 2, 3], 2, 1).print();

Parameters:

    signal (tf.Tensor1D) The input tensor to be expanded
    frameLength (number) Length of each frame
    frameStep (number) The frame hop size in samples.
    padEnd (boolean) Whether to pad the end of signal with padValue. Optional
    padValue (number) A number to use where the input signal does not exist when padEnd is True. Optional

Returns: tf.Tensor
tf.signal.hammingWindow (windowLength) function Source

Generate a hamming window.

See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows

tf.signal.hammingWindow(10).print();

Parameters:

    windowLength (number)

Returns: tf.Tensor1D
tf.signal.hannWindow (windowLength) function Source

Generate a Hann window.

See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows

tf.signal.hannWindow(10).print();

Parameters:

    windowLength (number)

Returns: tf.Tensor1D
tf.signal.stft (signal, frameLength, frameStep, fftLength?, windowFn?) function Source

Computes the Short-time Fourier Transform of signals See: https://en.wikipedia.org/wiki/Short-time_Fourier_transform

const input = tf.tensor1d([1, 1, 1, 1, 1])
tf.signal.stft(input, 3, 1).print();

Parameters:

    signal (tf.Tensor1D) 1-dimensional real value tensor.
    frameLength (number) The window length of samples.
    frameStep (number) The number of samples to step.
    fftLength (number) The size of the FFT to apply. Optional
    windowFn ((length: number) => tf.Tensor1D) A callable that takes a window length and returns 1-d tensor. Optional

Returns: tf.Tensor
Operations / Linear Algebra
tf.linalg.bandPart (a, numLower, numUpper) function Source

Copy a tensor setting everything outside a central band in each innermost matrix to zero.

The band part is computed as follows: Assume input has k dimensions [I, J, K, ..., M, N], then the output is a tensor with the same shape where band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]. The indicator function in_band(m, n) = (num_lower < 0 || (m-n) <= num_lower) && (num_upper < 0 || (n-m) <= num_upper)

const x = tf.tensor2d([[ 0,  1,  2, 3],
                        [-1,  0,  1, 2],
                        [-2, -1,  0, 1],
                        [-3, -2, -1, 0]]);
let y = tf.linalg.bandPart(x, 1, -1);
y.print(); // [[ 0,  1,  2, 3],
            //  [-1,  0,  1, 2],
            //  [ 0, -1,  0, 1],
            //  [ 0, 0 , -1, 0]]
let z = tf.linalg.bandPart(x, 2, 1);
z.print(); // [[ 0,  1,  0, 0],
            //  [-1,  0,  1, 0],
            //  [-2, -1,  0, 1],
            //  [ 0, -2, -1, 0]]

Parameters:

    a (tf.Tensor|TypedArray|Array)
    numLower (number|tf.Scalar) Number of subdiagonals to keep. If negative, keep entire lower triangle.
    numUpper (number|tf.Scalar) Number of subdiagonals to keep. If negative, keep entire upper triangle.

Returns: tf.Tensor
tf.linalg.gramSchmidt (xs) function Source

Gram-Schmidt orthogonalization.

const x = tf.tensor2d([[1, 2], [3, 4]]);
let y = tf.linalg.gramSchmidt(x);
y.print();
console.log('Orthogonalized:');
y.dot(y.transpose()).print();  // should be nearly the identity matrix.
console.log('First row direction maintained:');
const data = await y.array();
console.log(data[0][1] / data[0][0]);  // should be nearly 2.

Parameters:

    xs (tf.Tensor1D[]|tf.Tensor2D) The vectors to be orthogonalized, in one of the two following formats:

        An Array of tf.Tensor1D.
        A tf.Tensor2D, i.e., a matrix, in which case the vectors are the rows of xs. In each case, all the vectors must have the same length and the length must be greater than or equal to the number of vectors.

Returns: tf.Tensor1D[]|tf.Tensor2D
tf.linalg.qr (x, fullMatrices?) function Source

Compute QR decomposition of m-by-n matrix using Householder transformation.

Implementation based on [http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf] (http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf)

const a = tf.tensor2d([[1, 2], [3, 4]]);
let [q, r] = tf.linalg.qr(a);
console.log('Q');
q.print();
console.log('R');
r.print();
console.log('Orthogonalized');
q.dot(q.transpose()).print()  // should be nearly the identity matrix.
console.log('Reconstructed');
q.dot(r).print(); // should be nearly [[1, 2], [3, 4]];

Parameters:

    x (tf.Tensor) The tf.Tensor to be QR-decomposed. Must have rank >= 2. Suppose it has the shape [..., M, N].
    fullMatrices (boolean) An optional boolean parameter. Defaults to false. If true, compute full-sized Q. If false (the default), compute only the leading N columns of Q and R. Optional

Returns: [tf.Tensor, tf.Tensor]
Operations / Sparse
tf.sparseFillEmptyRows (indices, values, denseShape, defaultValue) function Source

The input SparseTensor is represented via the map of inputs {indices, values, denseShape}. The output SparseTensor has the same denseShape but with indices outputIndices and values outputValues. This op inserts a single entry for every row that doesn't have any values. The index is created as [row, 0, ..., 0] and the inserted value is defaultValue.

For example, suppose spInput has shape [5, 6] and non-empty values: [0, 1]: a [0, 3]: b [2, 0]: c [3, 1]: d

Rows 1 and 4 are empty, so the output will be of shape [5, 6] with values: [0, 1]: a [0, 3]: b [1, 0]: defaultValue [2, 0]: c [3, 1]: d [4, 0]: defaultValue

The output SparseTensor will be in row-major order and will have the same shape as the input.

This op also returns an indicator vector shaped [dense_shape[0]] such that emptyRowIndicator[i] = True iff row i was an empty row.

And a reverse index map vector shaped [indices.shape[0]] that is used during backpropagation, reverseIndexMap[i] = outi s.t. indices[i, j] == outputIndices[outi, j] for all j

const result = tf.sparse.sparseFillEmptyRows(
   [[0, 0], [1, 0], [1, 3], [1, 4], [3, 2], [3, 3]],
   [0, 10, 13, 14, 32, 33], [5, 6], -1);
console.log(result);
result['outputIndices'].print(); // [[0, 0], [1, 0], [1, 3], [1, 4],
                                  //  [2, 0], [3, 2], [3, 3], [4, 0]]
result['outputValues'].print(); // [0, 10, 13, 14,-1, 32, 33, -1]
result['emptyRowIndicator'].print(); // [false, false, true, false, true]
result['reverseIndexMap'].print(); // [0, 1, 2, 3, 5, 6]

Parameters:

    indices (tf.Tensor2D|TypedArray|Array) : 2-D. The indices of the sparse tensor.
    values (tf.Tensor1D|TypedArray|Array) : 1-D. The values of the sparse tensor.
    denseShape (tf.Tensor1D|TypedArray|Array) : 1-D. The shape of the sparse tensor.
    defaultValue (tf.Scalar|ScalarLike) : 0-D. Default value to insert into location [row, 0, ..., 0] for rows missing from the input sparse tensor.

Returns: {[name: string]: tf.Tensor}
tf.sparseReshape (inputIndices, inputShape, newShape) function Source

This operation has the same semantics as reshape on the represented dense tensor. The inputIndices are recomputed based on the requested newShape. If one component of newShape is the special value -1, the size of that dimension is computed so that the total dense size remains constant. At most one component of newShape can be -1. The number of dense elements implied by newShape must be the same as the number of dense elements originally implied by inputShape. Reshaping does not affect the order of values in the SparseTensor. If the input tensor has rank R_in and N non-empty values, and newShape has length R_out, then inputIndices has shape [N, R_in], inputShape has length R_in, outputIndices has shape [N, R_out], and outputShape has length R_out.

const result = tf.sparse.sparseReshape(
   [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]],
   [2, 3, 6], [9, -1]);
console.log(result);
result['outputIndices'].print(); //[[0, 0], [0, 1], [1, 2], [4, 2], [8, 1]]
result['outputShape'].print(); // [9, 4]

Parameters:

    inputIndices (tf.Tensor2D|TypedArray|Array) : 2-D. N x R_in matrix with the indices of non-empty values in a SparseTensor.
    inputShape (tf.Tensor1D|TypedArray|Array) : 1-D. R_in Tensor1D with the input SparseTensor's dense shape.
    newShape (tf.Tensor1D|TypedArray|Array) : 1-D. R_out Tensor1D with the requested new dense shape.

Returns: {[name: string]: tf.Tensor}
tf.sparseSegmentMean (data, indices, segmentIds) function Source

Computes the mean along sparse segments of a tensor.

const c = tf.tensor2d([[1,2,3,4], [-1,-2,-3,-4], [6,7,8,9]]);
// Select two rows, one segment.
const result1 = tf.sparse.sparseSegmentMean(c,
                                           tf.tensor1d([0, 1], 'int32'),
                                           tf.tensor1d([0, 0], 'int32'));
result1.print(); // [[0, 0, 0, 0]]

// Select two rows, two segments.
const result2 = tf.sparse.sparseSegmentMean(c,
                                             tf.tensor1d([0, 1], 'int32'),
                                             tf.tensor1d([0, 1], 'int32'));
result2.print(); // [[1, 2, 3, 4], [-1, -2, -3, -4]]

// Select all rows, two segments.
const result3 = tf.sparse.sparseSegmentMean(c,
                                             tf.tensor1d([0, 1, 2], 'int32'),
                                             tf.tensor1d([0, 1, 1], 'int32'));
result3.print(); // [[1.0, 2.0, 3.0, 4.0], [2.5, 2.5, 2.5, 2.5]]

Parameters:

    data (tf.Tensor|TypedArray|Array) : A Tensor of at least one dimension with data that will be assembled in the output.
    indices (tf.Tensor1D|TypedArray|Array) : A 1-D Tensor with indices into data. Has same rank as segmentIds.
    segmentIds (tf.Tensor1D|TypedArray|Array) : A 1-D Tensor with indices into the output Tensor. Values should be sorted and can be repeated.

Returns: tf.Tensor
tf.sparseSegmentSum (data, indices, segmentIds) function Source

Computes the sum along sparse segments of a tensor.

const c = tf.tensor2d([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]]);
// Select two rows, one segment.
const result1 = tf.sparse.sparseSegmentSum(c,
                                           tf.tensor1d([0, 1], 'int32'),
                                           tf.tensor1d([0, 0], 'int32'));
result1.print(); // [[0, 0, 0, 0]]

// Select two rows, two segments.
const result2 = tf.sparse.sparseSegmentSum(c,
                                           tf.tensor1d([0, 1], 'int32'),
                                           tf.tensor1d([0, 1], 'int32'));
result2.print(); // [[1, 2, 3, 4], [-1, -2, -3, -4]]

// Select all rows, two segments.
const result3 = tf.sparse.sparseSegmentSum(c,
                                           tf.tensor1d([0, 1, 2], 'int32'),
                                           tf.tensor1d([0, 0, 1], 'int32'));
result3.print(); // [[0, 0, 0, 0], [5, 6, 7, 8]]

Parameters:

    data (tf.Tensor|TypedArray|Array) : A Tensor of at least one dimension with data that will be assembled in the output.
    indices (tf.Tensor1D|TypedArray|Array) : A 1-D Tensor with indices into data. Has same rank as segmentIds.
    segmentIds (tf.Tensor1D|TypedArray|Array) : A 1-D Tensor with indices into the output Tensor. Values should be sorted and can be repeated.

Returns: tf.Tensor
Operations / String
tf.staticRegexReplace (input, pattern, rewrite, replaceGlobal?) function Source

Replace the match of a pattern in input with rewrite.

const result = tf.string.staticRegexReplace(
     ['format       this   spacing      better'], ' +', ' ');
result.print(); // ['format this spacing better']

Parameters:

    input (tf.Tensor | TypedArray|Array) : A Tensor of type string. The text to be processed.
    pattern (string) : A string. The regular expression to match the input.
    rewrite (string) : A string. The rewrite to be applied to the matched expression.
    replaceGlobal (boolean) : An optional bool. Defaults to True. If True, the replacement is global, otherwise the replacement is done only on the first match. Optional

Returns: tf.Tensor
tf.stringNGrams (data, dataSplits, separator, nGramWidths, leftPad, rightPad, padWidth, preserveShortSequences) function Source

Creates ngrams from ragged string data.

This op accepts a ragged tensor with 1 ragged dimension containing only strings and outputs a ragged tensor with 1 ragged dimension containing ngrams of that string, joined along the innermost axis.

const result = tf.string.stringNGrams(
   ['a', 'b', 'c', 'd'], tf.tensor1d([0, 2, 4], 'int32'),
   '|', [1, 2], 'LP', 'RP', -1, false);
result['nGrams'].print(); // ['a', 'b', 'LP|a', 'a|b', 'b|RP',
                           //  'c', 'd', 'LP|c', 'c|d', 'd|RP']
result['nGramsSplits'].print(); // [0, 5, 10]

Parameters:

    data (tf.Tensor1D|TypedArray|Array) : The values tensor of the ragged string tensor to make ngrams out of. Must be a 1D string tensor.
    dataSplits (tf.Tensor|TypedArray|Array) : The splits tensor of the ragged string tensor to make ngrams out of.
    separator (string) : The string to append between elements of the token. Use "" for no separator.
    nGramWidths (number[]) : The sizes of the ngrams to create.
    leftPad (string) : The string to use to pad the left side of the ngram sequence. Only used if pad_width !== 0.
    rightPad (string) : The string to use to pad the right side of the ngram sequence. Only used if pad_width !== 0.
    padWidth (number) : The number of padding elements to add to each side of each sequence. Note that padding will never be greater than nGramWidths-1 regardless of this value. If padWidth=-1, then add max(nGramWidths)-1 elements.
    preserveShortSequences (boolean) : If true, then ensure that at least one ngram is generated for each input sequence. In particular, if an input sequence is shorter than min(ngramWidth) + 2*padWidth, then generate a single ngram containing the entire sequence. If false, then no ngrams are generated for these short input sequences.

Returns: {[name: string]: tf.Tensor}
tf.stringSplit (input, delimiter, skipEmpty?) function Source

Split elements of input based on delimiter into a SparseTensor .

Let N be the size of source (typically N will be the batch size). Split each element of input based on delimiter and return a SparseTensor containing the splitted tokens. Empty tokens are ignored if skipEmpty is set to True.

delimiter can be empty, or a string of split characters. If delimiter is an empty string, each element of input is split into individual character strings. Otherwise every character of delimiter is a potential split point.

const result = tf.string.stringSplit(['hello world',  'a b c'], ' ');
result['indices'].print(); // [[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]]
result['values'].print(); // ['hello', 'world', 'a', 'b', 'c']
result['shape'].print(); // [2, 3]

Parameters:

    input (tf.Tensor1D|TypedArray|Array) : 1-D. Strings to split.
    delimiter (tf.Scalar|ScalarLike) : 0-D. Delimiter characters, or empty string.
    skipEmpty (boolean) : Optional. If true, skip the empty strings from the result. Defaults to true. Optional

Returns: {[name: string]: tf.Tensor}
tf.stringToHashBucketFast (input, numBuckets) function Source

Converts each string in the input Tensor to its hash mod by a number of buckets.

The hash function is deterministic on the content of the string within the process and will never change. However, it is not suitable for cryptography. This function may be used when CPU time is scarce and inputs are trusted or unimportant. There is a risk of adversaries constructing inputs that all hash to the same bucket.

const result = tf.string.stringToHashBucketFast(
   ['Hello', 'TensorFlow', '2.x'], 3);
result.print(); // [0, 2, 2]

Parameters:

    input (tf.Tensor|TypedArray|Array) : The strings to assign a hash bucket.
    numBuckets (number) : The number of buckets.

Returns: tf.Tensor
Training

We also provide an API to do perform training, and compute gradients. We compute gradients eagerly, users provide a function that is a combination of operations and we automatically differentiate that function's output with respect to its inputs.

For those familiar with TensorFlow, the API we expose exactly mirrors the TensorFlow Eager API.
Training / Gradients
tf.grad (f) function Source

Provided f(x), returns another function g(x, dy?), which gives the gradient of f(x) with respect to x.

If dy is provided, the gradient of f(x).mul(dy).sum() with respect to x is computed instead. f(x) must take a single tensor x and return a single tensor y. If f() takes multiple inputs, use tf.grads() instead.

// f(x) = x ^ 2
const f = x => x.square();
// f'(x) = 2x
const g = tf.grad(f);

const x = tf.tensor1d([2, 3]);
g(x).print();

// f(x) = x ^ 3
const f = x => x.pow(tf.scalar(3, 'int32'));
// f'(x) = 3x ^ 2
const g = tf.grad(f);
// f''(x) = 6x
const gg = tf.grad(g);

const x = tf.tensor1d([2, 3]);
gg(x).print();

Parameters:

    f ((x: tf.Tensor) => tf.Tensor) The function f(x), to compute gradient for.

Returns: ( x: TypedArray|Array|tf.Tensor, dy?: TypedArray|Array|tf.Tensor) => tf.Tensor
tf.grads (f) function Source

Provided f(x1, x2,...), returns another function g([x1, x2,...], dy?), which gives an array of gradients of f() with respect to each input [x1,x2,...].

If dy is passed when calling g(), the gradient of f(x1,...).mul(dy).sum() with respect to each input is computed instead. The provided f must take one or more tensors and return a single tensor y. If f() takes a single input, we recommend using tf.grad() instead.

// f(a, b) = a * b
const f = (a, b) => a.mul(b);
// df / da = b, df / db = a
const g = tf.grads(f);

const a = tf.tensor1d([2, 3]);
const b = tf.tensor1d([-2, -3]);
const [da, db] = g([a, b]);
console.log('da');
da.print();
console.log('db');
db.print();

Parameters:

    f ((...args: tf.Tensor[]) => tf.Tensor) The function f(x1, x2,...) to compute gradients for.

Returns: ( args: Array, dy?: tf.Tensor|TypedArray|Array) => tf.Tensor[]
tf.customGrad (f) function Source

Overrides the gradient computation of a function f.

Takes a function f(...inputs, save) => {value: Tensor, gradFunc: (dy, saved) => Tensor[]} and returns another function g(...inputs) which takes the same inputs as f. When called, g returns f().value. In backward mode, custom gradients with respect to each input of f are computed using f().gradFunc.

The save function passed to f should be used for saving tensors needed in the gradient. And the saved passed to the gradFunc is a NamedTensorMap, which contains those saved tensors.

const customOp = tf.customGrad((x, save) => {
   // Save x to make sure it's available later for the gradient.
   save([x]);
   // Override gradient of our custom x ^ 2 op to be dy * abs(x);
   return {
     value: x.square(),
     // Note `saved.x` which points to the `x` we saved earlier.
     gradFunc: (dy, saved) => [dy.mul(saved[0].abs())]
   };
});

const x = tf.tensor1d([-1, -2, 3]);
const dx = tf.grad(x => customOp(x));

console.log(`f(x):`);
customOp(x).print();
console.log(`f'(x):`);
dx(x).print();

Parameters:

    f ((a: tf.Tensor, b: tf.Tensor,..., [tf.GraphModel.tf.LayersModel.save()()](#tf.GraphModel.tf.LayersModel.save())?: Function) => { value: tf.Tensor, gradFunc: (dy: tf.Tensor, saved?: NamedTensorMap) => tf.Tensor | tf.Tensor[] }) The function to evaluate in forward mode, which should return {value: Tensor, gradFunc: (dy, saved) => Tensor[]}, where gradFunc returns the custom gradients of f with respect to its inputs.

Returns: (...args: tf.Tensor[]) => tf.Tensor
tf.valueAndGrad (f) function Source

Like tf.grad(), but also returns the value of f(). Useful when f() returns a metric you want to show.

The result is a rich object with the following properties:

    grad: The gradient of f(x) w.r.t. x (result of tf.grad()).
    value: The value returned by f(x).

// f(x) = x ^ 2
const f = x => x.square();
// f'(x) = 2x
const g = tf.valueAndGrad(f);

const x = tf.tensor1d([2, 3]);
const {value, grad} = g(x);

console.log('value');
value.print();
console.log('grad');
grad.print();

Parameters:

    f ((x: tf.Tensor) => tf.Tensor)

Returns: ( x: tf.Tensor, dy?: tf.Tensor) => { value: tf.Tensor; grad: tf.Tensor; }
tf.valueAndGrads (f) function Source

Like tf.grads(), but returns also the value of f(). Useful when f() returns a metric you want to show.

The result is a rich object with the following properties:

    grads: The gradients of f() w.r.t. each input (result of tf.grads()).
    value: The value returned by f(x).

// f(a, b) = a * b
const f = (a, b) => a.mul(b);
// df/da = b, df/db = a
const g = tf.valueAndGrads(f);

const a = tf.tensor1d([2, 3]);
const b = tf.tensor1d([-2, -3]);
const {value, grads} = g([a, b]);

const [da, db] = grads;

console.log('value');
value.print();

console.log('da');
da.print();
console.log('db');
db.print();

Parameters:

    f ((...args: tf.Tensor[]) => tf.Tensor)

Returns: ( args: tf.Tensor[], dy?: tf.Tensor) => { grads: tf.Tensor[]; value: tf.Tensor; }
tf.variableGrads (f, varList?) function Source

Computes and returns the gradient of f(x) with respect to the list of trainable variables provided by varList. If no list is provided, it defaults to all trainable variables.

const a = tf.variable(tf.tensor1d([3, 4]));
const b = tf.variable(tf.tensor1d([5, 6]));
const x = tf.tensor1d([1, 2]);

// f(a, b) = a * x ^ 2 + b * x
const f = () => a.mul(x.square()).add(b.mul(x)).sum();
// df/da = x ^ 2, df/db = x
const {value, grads} = tf.variableGrads(f);

Object.keys(grads).forEach(varName => grads[varName].print());

Parameters:

    f (() => tf.Scalar) The function to execute. f() should return a scalar.
    varList (tf.Variable[]) The list of variables to compute the gradients with respect to. Defaults to all trainable variables. Optional

Returns: {value: tf.Scalar, grads: {[name: string]: tf.Tensor}}
Training / Optimizers
tf.train.sgd (learningRate) function Source

Constructs a tf.SGDOptimizer that uses stochastic gradient descent.

// Fit a quadratic function by learning the coefficients a, b, c.
const xs = tf.tensor1d([0, 1, 2, 3]);
const ys = tf.tensor1d([1.1, 5.9, 16.8, 33.9]);

const a = tf.scalar(Math.random()).variable();
const b = tf.scalar(Math.random()).variable();
const c = tf.scalar(Math.random()).variable();

// y = a * x^2 + b * x + c.
const f = x => a.mul(x.square()).add(b.mul(x)).add(c);
const loss = (pred, label) => pred.sub(label).square().mean();

const learningRate = 0.01;
const optimizer = tf.train.sgd(learningRate);

// Train the model.
for (let i = 0; i < 10; i++) {
   optimizer.minimize(() => loss(f(xs), ys));
}

// Make predictions.
console.log(
     `a: ${a.dataSync()}, b: ${b.dataSync()}, c: ${c.dataSync()}`);
const preds = f(xs).dataSync();
preds.forEach((pred, i) => {
   console.log(`x: ${i}, pred: ${pred}`);
});

Parameters:

    learningRate (number) The learning rate to use for the SGD algorithm.

Returns: tf.SGDOptimizer
tf.train.momentum (learningRate, momentum, useNesterov?) function Source

Constructs a tf.MomentumOptimizer that uses momentum gradient descent.

See http://proceedings.mlr.press/v28/sutskever13.pdf
Parameters:

    learningRate (number) The learning rate to use for the Momentum gradient descent algorithm.
    momentum (number) The momentum to use for the momentum gradient descent algorithm.
    useNesterov (boolean) Optional

Returns: tf.MomentumOptimizer
tf.train.adagrad (learningRate, initialAccumulatorValue?) function Source

Constructs a tf.AdagradOptimizer that uses the Adagrad algorithm. See http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf or http://ruder.io/optimizing-gradient-descent/index.html#adagrad
Parameters:

    learningRate (number) The learning rate to use for the Adagrad gradient descent algorithm.
    initialAccumulatorValue (number) Starting value for the accumulators, must be positive. Optional

Returns: tf.AdagradOptimizer
tf.train.adadelta (learningRate?, rho?, epsilon?) function Source

Constructs a tf.AdadeltaOptimizer that uses the Adadelta algorithm. See https://arxiv.org/abs/1212.5701
Parameters:

    learningRate (number) The learning rate to use for the Adadelta gradient descent algorithm. Optional
    rho (number) The learning rate decay over each update. Optional
    epsilon (number) A constant epsilon used to better condition the grad update. Optional

Returns: tf.AdadeltaOptimizer
tf.train.adam (learningRate?, beta1?, beta2?, epsilon?) function Source

Constructs a tf.AdamOptimizer that uses the Adam algorithm. See https://arxiv.org/abs/1412.6980
Parameters:

    learningRate (number) The learning rate to use for the Adam gradient descent algorithm. Optional
    beta1 (number) The exponential decay rate for the 1st moment estimates. Optional
    beta2 (number) The exponential decay rate for the 2nd moment estimates. Optional
    epsilon (number) A small constant for numerical stability. Optional

Returns: AdamOptimizer
tf.train.adamax (learningRate?, beta1?, beta2?, epsilon?, decay?) function Source

Constructs a tf.AdamaxOptimizer that uses the Adamax algorithm. See https://arxiv.org/abs/1412.6980
Parameters:

    learningRate (number) The learning rate to use for the Adamax gradient descent algorithm. Optional
    beta1 (number) The exponential decay rate for the 1st moment estimates. Optional
    beta2 (number) The exponential decay rate for the 2nd moment estimates. Optional
    epsilon (number) A small constant for numerical stability. Optional
    decay (number) The learning rate decay over each update. Optional

Returns: AdamaxOptimizer
tf.train.rmsprop (learningRate, decay?, momentum?, epsilon?, centered?) function Source

Constructs a tf.RMSPropOptimizer that uses RMSProp gradient descent. This implementation uses plain momentum and is not centered version of RMSProp.

See http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf
Parameters:

    learningRate (number) The learning rate to use for the RMSProp gradient descent algorithm.
    decay (number) The discounting factor for the history/coming gradient. Optional
    momentum (number) The momentum to use for the RMSProp gradient descent algorithm. Optional
    epsilon (number) Small value to avoid zero denominator. Optional
    centered (boolean) If true, gradients are normalized by the estimated variance of the gradient. Optional

Returns: tf.RMSPropOptimizer
Training / Losses
tf.losses.absoluteDifference (labels, predictions, weights?, reduction?) function Source

Computes the absolute difference loss between two tensors.
Parameters:

    labels (tf.Tensor|TypedArray|Array) The ground truth output tensor, same dimensions as 'predictions'.
    predictions (tf.Tensor|TypedArray|Array) The predicted outputs.
    weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or the same rank as labels, and must be broadcastable to labels (i.e., all dimensions must be either 1, or the same as the corresponding losses dimension). Optional
    reduction (Reduction) Type of reduction to apply to loss. Should be of type Reduction Optional

Returns: tf.Tensor
tf.losses.computeWeightedLoss (losses, weights?, reduction?) function Source

Computes the weighted loss between two tensors.
Parameters:

    losses (tf.Tensor|TypedArray|Array) Tensor of shape [batch_size, d1, ..., dN].
    weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or the same rank as losses, and must be broadcastable to losses (i.e., all dimensions must be either 1, or the same as the corresponding losses dimension). Optional
    reduction (Reduction) Optional

Returns: tf.Tensor
tf.losses.cosineDistance (labels, predictions, axis, weights?, reduction?) function Source

Computes the cosine distance loss between two tensors.
Parameters:

    labels (tf.Tensor|TypedArray|Array) The ground truth output tensor, same dimensions as 'predictions'.
    predictions (tf.Tensor|TypedArray|Array) The predicted outputs.
    axis (number) The dimension along which the cosine distance is computed.
    weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or the same rank as labels, and must be broadcastable to labels (i.e., all dimensions must be either 1, or the same as the corresponding losses dimension). Optional
    reduction (Reduction) Type of reduction to apply to loss. Should be of type Reduction Optional

Returns: tf.Tensor
tf.losses.hingeLoss (labels, predictions, weights?, reduction?) function Source

Computes the Hinge loss between two tensors.
Parameters:

    labels (tf.Tensor|TypedArray|Array) The ground truth output tensor, same dimensions as 'predictions'.
    predictions (tf.Tensor|TypedArray|Array) The predicted outputs.
    weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or the same rank as labels, and must be broadcastable to labels (i.e., all dimensions must be either 1, or the same as the corresponding losses dimension). Optional
    reduction (Reduction) Type of reduction to apply to loss. Should be of type Reduction Optional

Returns: tf.Tensor
tf.losses.huberLoss (labels, predictions, weights?, delta?, reduction?) function Source

Computes the Huber loss between two tensors.
Parameters:

    labels (tf.Tensor|TypedArray|Array) The ground truth output tensor, same dimensions as 'predictions'.
    predictions (tf.Tensor|TypedArray|Array) The predicted outputs.
    weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or the same rank as labels, and must be broadcastable to labels (i.e., all dimensions must be either 1, or the same as the corresponding losses dimension). Optional
    delta (number) Point where Huber loss changes from quadratic to linear. Optional
    reduction (Reduction) Type of reduction to apply to loss. Should be of type Reduction. Optional

Returns: tf.Tensor
tf.losses.logLoss (labels, predictions, weights?, epsilon?, reduction?) function Source

Computes the log loss between two tensors.
Parameters:

    labels (tf.Tensor|TypedArray|Array) The ground truth output tensor, same dimensions as 'predictions'.
    predictions (tf.Tensor|TypedArray|Array) The predicted outputs.
    weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or the same rank as labels, and must be broadcastable to labels (i.e., all dimensions must be either 1, or the same as the corresponding losses dimension). Optional
    epsilon (number) A small increment to avoid taking log of zero Optional
    reduction (Reduction) Type of reduction to apply to loss. Should be of type Reduction Optional

Returns: tf.Tensor
tf.losses.meanSquaredError (labels, predictions, weights?, reduction?) function Source

Computes the mean squared error between two tensors.
Parameters:

    labels (tf.Tensor|TypedArray|Array) The ground truth output tensor, same dimensions as 'predictions'.
    predictions (tf.Tensor|TypedArray|Array) The predicted outputs.
    weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or the same rank as labels, and must be broadcastable to labels (i.e., all dimensions must be either 1, or the same as the corresponding losses dimension). Optional
    reduction (Reduction) Type of reduction to apply to loss. Should be of type Reduction Optional

Returns: tf.Tensor
tf.losses.sigmoidCrossEntropy (multiClassLabels, logits, weights?, labelSmoothing?, reduction?) function Source

Computes the sigmoid cross entropy loss between two tensors.

If labelSmoothing is nonzero, smooth the labels towards 1/2:

newMulticlassLabels = multiclassLabels * (1 - labelSmoothing) + 0.5 * labelSmoothing
Parameters:

    multiClassLabels (tf.Tensor|TypedArray|Array) The ground truth output tensor of shape [batch_size, num_classes], same dimensions as 'predictions'.
    logits (tf.Tensor|TypedArray|Array) The predicted outputs.
    weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or the same rank as labels, and must be broadcastable to labels (i.e., all dimensions must be either 1, or the same as the corresponding losses dimension). Optional
    labelSmoothing (number) If greater than 0, then smooth the labels. Optional
    reduction (Reduction) Type of reduction to apply to loss. Should be of type Reduction Optional

Returns: tf.Tensor
tf.losses.softmaxCrossEntropy (onehotLabels, logits, weights?, labelSmoothing?, reduction?) function Source

Computes the softmax cross entropy loss between two tensors.

If labelSmoothing is nonzero, smooth the labels towards 1/2:

newOnehotLabels = onehotLabels * (1 - labelSmoothing) + labelSmoothing / numClasses
Parameters:

    onehotLabels (tf.Tensor|TypedArray|Array) One hot encoded labels [batch_size, num_classes], same dimensions as 'predictions'.
    logits (tf.Tensor|TypedArray|Array) The predicted outputs.
    weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or 1, and must be broadcastable to loss of shape [batch_size] Optional
    labelSmoothing (number) If greater than 0, then smooth the labels. Optional
    reduction (Reduction) Type of reduction to apply to loss. Should be of type Reduction Optional

Returns: tf.Tensor
Training / Classes
tf.train.Optimizer extends Serializable class Source
minimize (f, returnCost?, varList?) method Source

Executes f() and minimizes the scalar output of f() by computing gradients of y with respect to the list of trainable variables provided by varList. If no list is provided, it defaults to all trainable variables.
Parameters:

    f (() => tf.Scalar) The function to execute and whose output to minimize.
    returnCost (boolean) Whether to return the scalar cost value produced by executing f(). Optional
    varList (tf.Variable[]) An optional list of variables to update. If specified, only the trainable variables in varList will be updated by minimize. Defaults to all trainable variables. Optional

Returns: tf.Scalar |null
computeGradients (f, varList?) method Source

Executes f() and computes the gradient of the scalar output of f() with respect to the list of trainable variables provided by varList. If no list is provided, it defaults to all trainable variables.
Parameters:

    f (() => tf.Scalar) The function to execute and whose output to use for computing gradients with respect to variables.
    varList (tf.Variable[]) An optional list of variables to compute gradients with respect to. If specified, only the trainable variables in varList will have gradients computed with respect to. Defaults to all trainable variables. Optional

Returns: {value: tf.Scalar, grads: {[name: string]: tf.Tensor}}
applyGradients (variableGradients) method Source

Updates variables by using the computed gradients.
Parameters:

    variableGradients ({[name: string]: tf.Tensor}| NamedTensor[]) A mapping of variable name to its gradient value.

Returns: void
Performance
Performance / Memory
tf.tidy (nameOrFn, fn?) function Source

Executes the provided function fn and after it is executed, cleans up all intermediate tensors allocated by fn except those returned by fn. fn must not return a Promise (async functions not allowed). The returned result can be a complex object.

Using this method helps avoid memory leaks. In general, wrap calls to operations in tf.tidy() for automatic memory cleanup.

NOTE: Variables do not get cleaned up when inside a tidy(). If you want to dispose variables, please use tf.disposeVariables() or call dispose() directly on variables.

// y = 2 ^ 2 + 1
const y = tf.tidy(() => {
   // a, b, and one will be cleaned up when the tidy ends.
   const one = tf.scalar(1);
   const a = tf.scalar(2);
   const b = a.square();

   console.log('numTensors (in tidy): ' + tf.memory().numTensors);

   // The value returned inside the tidy function will return
   // through the tidy, in this case to the variable y.
   return b.add(one);
});

console.log('numTensors (outside tidy): ' + tf.memory().numTensors);
y.print();

Parameters:

    nameOrFn (string|Function) The name of the closure, or the function to execute. If a name is provided, the 2nd argument should be the function. If debug mode is on, the timing and the memory usage of the function will be tracked and displayed on the console using the provided name.
    fn (Function) The function to execute. Optional

Returns: void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string}
tf.dispose (container) function Source

Disposes any tf.Tensors found within the provided object.
Parameters:

    container (void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string}) an object that may be a tf.Tensor or may directly contain tf.Tensors, such as a Tensor[] or {key: Tensor, ...}. If the object is not a tf.Tensor or does not contain Tensors, nothing happens. In general it is safe to pass any object here, except that Promises are not supported.

Returns: void
tf.keep (result) function Source

Keeps a tf.Tensor generated inside a tf.tidy() from being disposed automatically.

let b;
const y = tf.tidy(() => {
   const one = tf.scalar(1);
   const a = tf.scalar(2);

   // b will not be cleaned up by the tidy. a and one will be cleaned up
   // when the tidy ends.
   b = tf.keep(a.square());

   console.log('numTensors (in tidy): ' + tf.memory().numTensors);

   // The value returned inside the tidy function will return
   // through the tidy, in this case to the variable y.
   return b.add(one);
});

console.log('numTensors (outside tidy): ' + tf.memory().numTensors);
console.log('y:');
y.print();
console.log('b:');
b.print();

Parameters:

    result (tf.Tensor) The tensor to keep from being disposed.

Returns: tf.Tensor
tf.memory () function Source

Returns memory info at the current time in the program. The result is an object with the following properties:

    numBytes: Number of bytes allocated (undisposed) at this time.
    numTensors: Number of unique tensors allocated.
    numDataBuffers: Number of unique data buffers allocated (undisposed) at this time, which is ≤ the number of tensors (e.g. a.reshape(newShape) makes a new Tensor that shares the same data buffer with a).
    unreliable: True if the memory usage is unreliable. See reasons when unreliable is true.
    reasons: string[], reasons why the memory is unreliable, present if unreliable is true.

WebGL Properties:

    numBytesInGPU: Number of bytes allocated (undisposed) in the GPU only at this time.

Returns: MemoryInfo
Performance / Timing
tf.time (f) function Source

Executes f() and returns a promise that resolves with timing information.

The result is an object with the following properties:

    wallMs: Wall execution time.
    kernelMs: Kernel execution time, ignoring data transfer. If using the WebGL backend and the query timer extension is not available, this will return an error object.
    On WebGL The following additional properties exist:
        uploadWaitMs: CPU blocking time on texture uploads.
        downloadWaitMs: CPU blocking time on texture downloads (readPixels).

const x = tf.randomNormal([20, 20]);
const time = await tf.time(() => x.matMul(x));

console.log(`kernelMs: ${time.kernelMs}, wallTimeMs: ${time.wallMs}`);

Parameters:

    f (() => void) The function to execute and time.

Returns: Promise<TimingInfo>
tf.nextFrame () function Source

Returns a promise that resolves when a requestAnimationFrame has completed.

On Node.js this uses setImmediate instead of requestAnimationFrame.

This is simply a sugar method so that users can do the following: await tf.nextFrame();
Returns: Promise<void>
Performance / Profile
tf.profile (f) function Source

Executes the provided function f() and returns a promise that resolves with information about the function's memory use:

    newBytes: the number of new bytes allocated
    newTensors: the number of new tensors created
    peakBytes: the peak number of bytes allocated
    kernels: an array of objects for each kernel involved that reports their input and output shapes, number of bytes used, and number of new tensors created.
    kernelNames: an array of unique strings with just the names of the kernels in the kernels array.

const profile = await tf.profile(() => {
   const x = tf.tensor1d([1, 2, 3]);
   let x2 = x.square();
   x2.dispose();
   x2 = x.square();
   x2.dispose();
   return x;
});

console.log(`newBytes: ${profile.newBytes}`);
console.log(`newTensors: ${profile.newTensors}`);
console.log(`byte usage over all kernels: ${profile.kernels.map(k =>
k.totalBytesSnapshot)}`);

Parameters:

    f (() => (void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string} | Promise<void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string}>))

Returns: Promise<ProfileInfo>
Environment

TensorFlow.js can run mathematical operations on different backends. Currently, we support WebGL and JavaScript CPU. By default, we choose the 'best' backend available, but allow users to customize their backend.
Environment /
tf.Environment class Source

The environment contains evaluated flags as well as the registered platform. This is always used as a global singleton and can be retrieved with tf.env().
tf.disposeVariables () function Source

Dispose all variables kept in backend engine.
Returns: void
tf.enableDebugMode () function Source

Enables debug mode which will log information about all executed kernels: the elapsed time of the kernel execution, as well as the rank, shape, and size of the output tensor.

Debug mode will significantly slow down your application as it will download the result of every operation to the CPU. This should not be used in production. Debug mode does not affect the timing information of the kernel execution as we do not measure download time in the kernel execution time.

See also: tf.profile(), tf.memory().
Returns: void
tf.enableProdMode () function Source

Enables production mode which disables correctness checks in favor of performance.
Returns: void
tf.engine () function Source

It returns the global engine that keeps track of all tensors and backends.
Returns: Engine
tf.env () function Source

Returns the current environment (a global singleton).

The environment object contains the evaluated feature values as well as the active platform.
Returns: tf.Environment
Constraints

Constraints are added to attributes of a Layer (such as weights, kernels, or biases) at construction time to clamp, or otherwise enforce an allowed range, of values for different components of the Layer.
Constraints / Classes
tf.constraints.Constraint extends serialization.Serializable class Source

Base class for functions that impose constraints on weight values
Constraints /
tf.constraints.maxNorm (args) function Source

MaxNorm weight constraint.

Constrains the weights incident to each hidden unit to have a norm less than or equal to a desired value.

References - Dropout: A Simple Way to Prevent Neural Networks from Overfitting Srivastava, Hinton, et al. 2014
Parameters:

    args (Object)
    maxValue (number) Maximum norm for incoming weights
    axis (number) Axis along which to calculate norms.

    For instance, in a Dense layer the weight matrix has shape [inputDim, outputDim], set axis to 0 to constrain each weight vector of length [inputDim,]. In a Conv2D layer with dataFormat="channels_last", the weight tensor has shape [rows, cols, inputDepth, outputDepth], set axis to [0, 1, 2] to constrain the weights of each filter tensor of size [rows, cols, inputDepth].

Returns: tf.constraints.Constraint
tf.constraints.minMaxNorm (config) function Source
Parameters:

    config (Object)
    minValue (number) Minimum norm for incoming weights
    maxValue (number) Maximum norm for incoming weights
    axis (number) Axis along which to calculate norms. For instance, in a Dense layer the weight matrix has shape [inputDim, outputDim], set axis to 0 to constrain each weight vector of length [inputDim,]. In a Conv2D layer with dataFormat="channels_last", the weight tensor has shape [rows, cols, inputDepth, outputDepth], set axis to [0, 1, 2] to constrain the weights of each filter tensor of size [rows, cols, inputDepth].
    rate (number) Rate for enforcing the constraint: weights will be rescaled to yield: (1 - rate) * norm + rate * norm.clip(minValue, maxValue). Effectively, this means that rate=1.0 stands for strict enforcement of the constraint, while rate<1.0 means that weights will be rescaled at each step to slowly move towards a value inside the desired interval.

Returns: tf.constraints.Constraint
tf.constraints.nonNeg () function Source

Constrains the weight to be non-negative.
Returns: tf.constraints.Constraint
tf.constraints.unitNorm (args) function Source

Constrains the weights incident to each hidden unit to have unit norm.
Parameters:

    args (Object)
    axis (number) Axis along which to calculate norms.

    For instance, in a Dense layer the weight matrix has shape [inputDim, outputDim], set axis to 0 to constrain each weight vector of length [inputDim,]. In a Conv2D layer with dataFormat="channels_last", the weight tensor has shape [rows, cols, inputDepth, outputDepth], set axis to [0, 1, 2] to constrain the weights of each filter tensor of size [rows, cols, inputDepth].

Returns: tf.constraints.Constraint
Initializers

Initializers are used in Layers to establish the starting the values of weights, biases, kernels, etc.
Initializers / Classes
tf.initializers.Initializer extends serialization.Serializable class Source

Initializer base class.
Initializers /
tf.initializers.constant (args) function Source

Initializer that generates values initialized to some constant.
Parameters:

    args (Object)
    value (number) The value for each element in the variable.

Returns: tf.initializers.Initializer
tf.initializers.glorotNormal (args) function Source

Glorot normal initializer, also called Xavier normal initializer. It draws samples from a truncated normal distribution centered on 0 with stddev = sqrt(2 / (fan_in + fan_out)) where fan_in is the number of input units in the weight tensor and fan_out is the number of output units in the weight tensor.

Reference: Glorot & Bengio, AISTATS 2010 http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf
Parameters:

    args (Object)
    seed (number) Random number generator seed.

Returns: tf.initializers.Initializer
tf.initializers.glorotUniform (args) function Source

Glorot uniform initializer, also called Xavier uniform initializer. It draws samples from a uniform distribution within [-limit, limit] where limit is sqrt(6 / (fan_in + fan_out)) where fan_in is the number of input units in the weight tensor and fan_out is the number of output units in the weight tensor

Reference: Glorot & Bengio, AISTATS 2010 http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf.
Parameters:

    args (Object)
    seed (number) Random number generator seed.

Returns: tf.initializers.Initializer
tf.initializers.heNormal (args) function Source

He normal initializer.

It draws samples from a truncated normal distribution centered on 0 with stddev = sqrt(2 / fanIn) where fanIn is the number of input units in the weight tensor.

Reference: He et al., http://arxiv.org/abs/1502.01852
Parameters:

    args (Object)
    seed (number) Random number generator seed.

Returns: tf.initializers.Initializer
tf.initializers.heUniform (args) function Source

He uniform initializer.

It draws samples from a uniform distribution within [-limit, limit] where limit is sqrt(6 / fan_in) where fanIn is the number of input units in the weight tensor.

Reference: He et al., http://arxiv.org/abs/1502.01852
Parameters:

    args (Object)
    seed (number) Random number generator seed.

Returns: tf.initializers.Initializer
tf.initializers.identity (args) function Source

Initializer that generates the identity matrix. Only use for square 2D matrices.
Parameters:

    args (Object)
    gain (number) Multiplicative factor to apply to the identity matrix.

Returns: tf.initializers.Initializer
tf.initializers.leCunNormal (args) function Source

LeCun normal initializer.

It draws samples from a truncated normal distribution centered on 0 with stddev = sqrt(1 / fanIn) where fanIn is the number of input units in the weight tensor.

References: Self-Normalizing Neural Networks Efficient Backprop
Parameters:

    args (Object)
    seed (number) Random number generator seed.

Returns: tf.initializers.Initializer
tf.initializers.leCunUniform (args) function Source

LeCun uniform initializer.

It draws samples from a uniform distribution in the interval [-limit, limit] with limit = sqrt(3 / fanIn), where fanIn is the number of input units in the weight tensor.
Parameters:

    args (Object)
    seed (number) Random number generator seed.

Returns: tf.initializers.Initializer
tf.initializers.ones () function Source

Initializer that generates tensors initialized to 1.
Returns: tf.initializers.Initializer
tf.initializers.orthogonal (args) function Source

Initializer that generates a random orthogonal matrix.

Reference: Saxe et al., http://arxiv.org/abs/1312.6120
Parameters:

    args (Object)
    gain (number) Multiplicative factor to apply to the orthogonal matrix. Defaults to 1.
    seed (number) Random number generator seed.

Returns: tf.initializers.Initializer
tf.initializers.randomNormal (args) function Source

Initializer that generates random values initialized to a normal distribution.
Parameters:

    args (Object)
    mean (number) Mean of the random values to generate.
    stddev (number) Standard deviation of the random values to generate.
    seed (number) Used to seed the random generator.

Returns: tf.initializers.Initializer
tf.initializers.randomUniform (args) function Source

Initializer that generates random values initialized to a uniform distribution.

Values will be distributed uniformly between the configured minval and maxval.
Parameters:

    args (Object)
    minval (number) Lower bound of the range of random values to generate.
    maxval (number) Upper bound of the range of random values to generate.
    seed (number) Used to seed the random generator.

Returns: tf.initializers.Initializer
tf.initializers.truncatedNormal (args) function Source

Initializer that generates random values initialized to a truncated normal distribution.

These values are similar to values from a RandomNormal except that values more than two standard deviations from the mean are discarded and re-drawn. This is the recommended initializer for neural network weights and filters.
Parameters:

    args (Object)
    mean (number) Mean of the random values to generate.
    stddev (number) Standard deviation of the random values to generate.
    seed (number) Used to seed the random generator.

Returns: tf.initializers.Initializer
tf.initializers.varianceScaling (config) function Source

Initializer capable of adapting its scale to the shape of weights. With distribution=NORMAL, samples are drawn from a truncated normal distribution centered on zero, with stddev = sqrt(scale / n) where n is:

    number of input units in the weight tensor, if mode = FAN_IN.
    number of output units, if mode = FAN_OUT.
    average of the numbers of input and output units, if mode = FAN_AVG. With distribution=UNIFORM, samples are drawn from a uniform distribution within [-limit, limit], with limit = sqrt(3 * scale / n).

Parameters:

    config (Object)
    scale (number) Scaling factor (positive float).
    mode ('fanIn'|'fanOut'|'fanAvg') Fanning mode for inputs and outputs.
    distribution ('normal'|'uniform'|'truncatedNormal') Probabilistic distribution of the values.
    seed (number) Random number generator seed.

Returns: tf.initializers.Initializer
tf.initializers.zeros () function Source

Initializer that generates tensors initialized to 0.
Returns: Zeros
Regularizers

Regularizers can be attached to various components of a Layer to add a 'scoring' function to help drive weights, or other trainable values, away from excessively large values. They're typically used to promote a notion that a 'simpler' model is better than a complicated model, assuming equal performance.
Regularizers /
tf.regularizers.l1 (config?) function Source

Regularizer for L1 regularization.

Adds a term to the loss to penalize large weights: loss += sum(l1 * abs(x))
Parameters:

    config (Object) Optional
    l1 (number) L1 regularization rate. Defaults to 0.01.

Returns: Regularizer
tf.regularizers.l1l2 (config?) function Source

Regularizer for L1 and L2 regularization.

Adds a term to the loss to penalize large weights: loss += sum(l1 * abs(x)) + sum(l2 * x^2)
Parameters:

    config (Object) Optional
    l1 (number) L1 regularization rate. Defaults to 0.01.
    l2 (number) L2 regularization rate. Defaults to 0.01.

Returns: Regularizer
tf.regularizers.l2 (config?) function Source

Regularizer for L2 regularization.

Adds a term to the loss to penalize large weights: loss += sum(l2 * x^2)
Parameters:

    config (Object) Optional
    l2 (number) L2 regularization rate. Defaults to 0.01.

Returns: Regularizer
Data

TensorFlow.js Data provides simple APIs to load and parse data from disk or over the web in a variety of formats, and to prepare that data for use in machine learning models (e.g. via operations like filter, map, shuffle, and batch).
Data / Creation
tf.data.array (items) function Source

Create a Dataset from an array of elements.

Create a Dataset from an array of objects:

const a = tf.data.array([{'item': 1}, {'item': 2}, {'item': 3}]);
await a.forEachAsync(e => console.log(e));

Create a Dataset from an array of numbers:

const a = tf.data.array([4, 5, 6]);
await a.forEachAsync(e => console.log(e));

Parameters:

    items (tf.void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string}[]) An array of elements that will be parsed as items in a dataset.

Returns: tf.data.Dataset
tf.data.csv (source, csvConfig?) function Source

Create a CSVDataset by reading and decoding CSV file(s) from provided URL or local path if it's in Node environment.

Note: If isLabel in columnConfigs is true for at least one column, the element in returned CSVDataset will be an object of {xs:features, ys:labels}: xs is a dict of features key/value pairs, ys is a dict of labels key/value pairs. If no column is marked as label, returns a dict of features only.

const csvUrl =
'https://storage.googleapis.com/tfjs-examples/multivariate-linear-regression/data/boston-housing-train.csv';

async function run() {
   // We want to predict the column "medv", which represents a median value of
   // a home (in $1000s), so we mark it as a label.
   const csvDataset = tf.data.csv(
     csvUrl, {
       columnConfigs: {
         medv: {
           isLabel: true
         }
       }
     });

   // Number of features is the number of column names minus one for the label
   // column.
   const numOfFeatures = (await csvDataset.columnNames()).length - 1;

   // Prepare the Dataset for training.
   const flattenedDataset =
     csvDataset
     .map(({xs, ys}) =>
       {
         // Convert xs(features) and ys(labels) from object form (keyed by
         // column name) to array form.
         return {xs:Object.values(xs), ys:Object.values(ys)};
       })
     .batch(10);

   // Define the model.
   const model = tf.sequential();
   model.add(tf.layers.dense({
     inputShape: [numOfFeatures],
     units: 1
   }));
   model.compile({
     optimizer: tf.train.sgd(0.000001),
     loss: 'meanSquaredError'
   });

   // Fit the model using the prepared Dataset
   return model.fitDataset(flattenedDataset, {
     epochs: 10,
     callbacks: {
       onEpochEnd: async (epoch, logs) => {
         console.log(epoch + ':' + logs.loss);
       }
     }
   });
}

await run();

Parameters:

    source (RequestInfo) URL or local path to get CSV file. If it's a local path, it must have prefix file:// and it only works in node environment.
    csvConfig (Object) (Optional) A CSVConfig object that contains configurations of reading and decoding from CSV file(s). Optional
    hasHeader (boolean) A boolean value that indicates whether the first row of provided CSV file is a header line with column names, and should not be included in the data.
    columnNames (string[]) A list of strings that corresponds to the CSV column names, in order. If provided, it ignores the column names inferred from the header row. If not provided, infers the column names from the first row of the records. If hasHeader is false and columnNames is not provided, this method will throw an error.
    columnConfigs ({[key: string]: ColumnConfig}) A dictionary whose key is column names, value is an object stating if this column is required, column's data type, default value, and if this column is label. If provided, keys must correspond to names provided in columnNames or inferred from the file header lines. If any column is marked as label, the .csv() API will return an array of two items: the first item is a dict of features key/value pairs, the second item is a dict of labels key/value pairs. If no column is marked as label returns a dict of features only.

    Has the following fields:

        required If value in this column is required. If set to true, throw an error when it finds an empty value.

        dtype Data type of this column. Could be int32, float32, bool, or string.

        default Default value of this column.

        isLabel Whether this column is label instead of features. If isLabel is true for at least one column, the element in returned CSVDataset will be an object of {xs: features, ys: labels}: xs is a dict of features key/value pairs, ys is a dict of labels key/value pairs. If no column is marked as label, returns a dict of features only.
    configuredColumnsOnly (boolean) If true, only columns provided in columnConfigs will be parsed and provided during iteration.
    delimiter (string) The string used to parse each line of the input file.
    delimWhitespace (boolean) If true, delimiter field should be null. Parsing delimiter is whitespace and treat continuous multiple whitespace as one delimiter.

Returns: tf.data.CSVDataset
tf.data.generator (generator) function Source

Create a Dataset that produces each element from provided JavaScript generator, which is a function that returns a (potentially async) iterator.

For more information on iterators and generators, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators . For the iterator protocol, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols .

Example of creating a dataset from an iterator factory:

function makeIterator() {
   const numElements = 10;
   let index = 0;

   const iterator = {
     next: () => {
       let result;
       if (index < numElements) {
         result = {value: index, done: false};
         index++;
         return result;
       }
       return {value: index, done: true};
     }
   };
   return iterator;
}
const ds = tf.data.generator(makeIterator);
await ds.forEachAsync(e => console.log(e));

Example of creating a dataset from a generator:

function* dataGenerator() {
   const numElements = 10;
   let index = 0;
   while (index < numElements) {
     const x = index;
     index++;
     yield x;
   }
}

const ds = tf.data.generator(dataGenerator);
await ds.forEachAsync(e => console.log(e));

Parameters:

    generator (() => Iterator | Promise<Iterator<void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string}>> | AsyncIterator<void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string}>) A JavaScript function that returns a (potentially async) JavaScript iterator.

Returns: tf.data.Dataset
tf.data.microphone (microphoneConfig?) function Source

Create an iterator that generates frequency-domain spectrogram Tensors from microphone audio stream with browser's native FFT. This API only works in browser environment when the device has microphone.

Note: this code snippet only works when the device has a microphone. It will request permission to open the microphone when running.

const mic = await tf.data.microphone({
   fftSize: 1024,
   columnTruncateLength: 232,
   numFramesPerSpectrogram: 43,
   sampleRateHz:44100,
   includeSpectrogram: true,
   includeWaveform: true
});
const audioData = await mic.capture();
const spectrogramTensor = audioData.spectrogram;
spectrogramTensor.print();
const waveformTensor = audioData.waveform;
waveformTensor.print();
mic.stop();

Parameters:

    microphoneConfig (Object) A MicrophoneConfig object that contains configurations of reading audio data from microphone. Optional
    sampleRateHz (44100|48000)
    fftSize (number)
    columnTruncateLength (number)
    numFramesPerSpectrogram (number)
    audioTrackConstraints (MediaTrackConstraints)
    smoothingTimeConstant (number)
    includeSpectrogram (boolean)
    includeWaveform (boolean)

Returns: Promise<MicrophoneIterator>
tf.data.webcam (webcamVideoElement?, webcamConfig?) function Source

Create an iterator that generates Tensors from webcam video stream. This API only works in Browser environment when the device has webcam.

Note: this code snippet only works when the device has a webcam. It will request permission to open the webcam when running.

const videoElement = document.createElement('video');
videoElement.width = 100;
videoElement.height = 100;
const cam = await tf.data.webcam(videoElement);
const img = await cam.capture();
img.print();
cam.stop();

Parameters:

    webcamVideoElement (HTMLVideoElement) A HTMLVideoElement used to play video from webcam. If this element is not provided, a hidden HTMLVideoElement will be created. In that case, resizeWidth and resizeHeight must be provided to set the generated tensor shape. Optional
    webcamConfig (Object) A WebcamConfig object that contains configurations of reading and manipulating data from webcam video stream. Optional
    facingMode ('user'|'environment') A string specifying which camera to use on device. If the value is 'user', it will use front camera. If the value is 'environment', it will use rear camera.
    deviceId (string) A string used to request a specific camera. The deviceId can be obtained by calling mediaDevices.enumerateDevices().
    resizeWidth (number) Specifies the width of the output tensor. The actual width of the HTMLVideoElement (if provided) can be different and the final image will be resized to match resizeWidth.
    resizeHeight (number) Specifies the height of the output tensor. The actual height of the HTMLVideoElement (if provided) can be different and the final image will be resized to match resizeHeight.
    centerCrop (boolean) A boolean value that indicates whether to crop the video frame from center. If true, resizeWidth and resizeHeight must be specified; then an image of size [resizeWidth, resizeHeight] is taken from the center of the frame without scaling. If false, the entire image is returned (perhaps scaled to fit in [resizeWidth, resizeHeight], if those are provided).

Returns: Promise<WebcamIterator>
Data / Operations
tf.data.zip (datasets) function Source

Create a Dataset by zipping together an array, dict, or nested structure of Datasets (and perhaps additional constants). The underlying datasets must provide elements in a consistent order such that they correspond.

The number of elements in the resulting dataset is the same as the size of the smallest dataset in datasets.

The nested structure of the datasets argument determines the structure of elements in the resulting iterator.

Note this means that, given an array of two datasets that produce dict elements, the result is a dataset that produces elements that are arrays of two dicts:

Zip an array of datasets:

console.log('Zip two datasets of objects:');
const ds1 = tf.data.array([{a: 1}, {a: 2}, {a: 3}]);
const ds2 = tf.data.array([{b: 4}, {b: 5}, {b: 6}]);
const ds3 = tf.data.zip([ds1, ds2]);
await ds3.forEachAsync(e => console.log(JSON.stringify(e)));

// If the goal is to merge the dicts in order to produce elements like
// {a: ..., b: ...}, this requires a second step such as:
console.log('Merge the objects:');
const ds4 = ds3.map(x => {return {a: x[0].a, b: x[1].b}});
await ds4.forEachAsync(e => console.log(e));

Zip a dict of datasets:

const a = tf.data.array([{a: 1}, {a: 2}, {a: 3}]);
const b = tf.data.array([{b: 4}, {b: 5}, {b: 6}]);
const c = tf.data.zip({c: a, d: b});
await c.forEachAsync(e => console.log(JSON.stringify(e)));

Parameters:

    datasets (DatasetContainer)

Returns: tf.data.Dataset
Data / Classes
tf.data.CSVDataset extends tf.data.Dataset class Source

Represents a potentially large collection of delimited text records.

The produced TensorContainers each contain one key-value pair for every column of the table. When a field is empty in the incoming data, the resulting value is undefined, or throw error if it is required. Values that can be parsed as numbers are emitted as type number, other values are parsed as string.

The results are not batched.
columnNames () method Source

Returns column names of the csv dataset. If configuredColumnsOnly is true, return column names in columnConfigs. If configuredColumnsOnly is false and columnNames is provided, columnNames. If configuredColumnsOnly is false and columnNames is not provided, return all column names parsed from the csv file. For example usage please go to tf.data.csv().
Returns: Promise<string[]>
tf.data.Dataset class Source

Represents a potentially large list of independent data elements (typically 'samples' or 'examples').

A 'data example' may be a primitive, an array, a map from string keys to values, or any nested structure of these.

A Dataset represents an ordered collection of elements, together with a chain of transformations to be performed on those elements. Each transformation is a method of Dataset that returns another Dataset, so these may be chained, e.g. const processedDataset = rawDataset.filter(...).map(...).batch(...).

Data loading and transformation is done in a lazy, streaming fashion. The dataset may be iterated over multiple times; each iteration starts the data loading anew and recapitulates the transformations.

A Dataset is typically processed as a stream of unbatched examples -- i.e., its transformations are applied one example at a time. Batching produces a new Dataset where each element is a batch. Batching should usually come last in a pipeline, because data transformations are easier to express on a per-example basis than on a per-batch basis.

The following code examples are calling await dataset.forEachAsync(...) to iterate once over the entire dataset in order to print out the data.
batch (batchSize, smallLastBatch?) method Source

Groups elements into batches.

It is assumed that each of the incoming dataset elements has the same structure -- i.e. the same set of keys at each location in an object hierarchy. For each key, the resulting Dataset provides a batched element collecting all of the incoming values for that key.

Incoming primitives are grouped into a 1-D Tensor. Incoming Tensors are grouped into a new Tensor where the 0th axis is the batch dimension. Incoming arrays are converted to Tensor and then batched. A nested array is interpreted as an n-D Tensor, so the batched result has n+1 dimensions. An array that cannot be converted to Tensor produces an error.

If an array should not be batched as a unit, it should first be converted to an object with integer keys.

Here are a few examples:

Batch a dataset of numbers:

const a = tf.data.array([1, 2, 3, 4, 5, 6, 7, 8]).batch(4);
await a.forEachAsync(e => e.print());

Batch a dataset of arrays:

const b = tf.data.array([[1], [2], [3], [4], [5], [6], [7], [8]]).batch(4);
await b.forEachAsync(e => e.print());

Batch a dataset of objects:

const c = tf.data.array([{a: 1, b: 11}, {a: 2, b: 12}, {a: 3, b: 13},
   {a: 4, b: 14}, {a: 5, b: 15}, {a: 6, b: 16}, {a: 7, b: 17},
   {a: 8, b: 18}]).batch(4);
await c.forEachAsync(e => {
   console.log('{');
   for(var key in e) {
     console.log(key+':');
     e[key].print();
   }
   console.log('}');
})

Parameters:

    batchSize (number) The number of elements desired per batch.
    smallLastBatch (boolean) Whether to emit the final batch when it has fewer than batchSize elements. Default true. Optional

Returns: tf.data.Dataset
concatenate (dataset) method Source

Concatenates this Dataset with another.

const a = tf.data.array([1, 2, 3]);
const b = tf.data.array([4, 5, 6]);
const c = a.concatenate(b);
await c.forEachAsync(e => console.log(e));

Parameters:

    dataset (tf.data.Dataset) A Dataset to be concatenated onto this one.

Returns: tf.data.Dataset
filter (predicate) method Source

Filters this dataset according to predicate.

const a = tf.data.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
   .filter(x => x%2 === 0);
await a.forEachAsync(e => console.log(e));

Parameters:

    predicate ((value: T) => boolean) A function mapping a dataset element to a boolean or a Promise for one.

Returns: tf.data.Dataset
forEachAsync (f) method Source

Apply a function to every element of the dataset.

After the function is applied to a dataset element, any Tensors contained within that element are disposed.

const a = tf.data.array([1, 2, 3]);
await a.forEachAsync(e => console.log(e));

Parameters:

    f ((input: T) => void) A function to apply to each dataset element.

Returns: Promise<void>
map (transform) method Source

Maps this dataset through a 1-to-1 transform.

const a = tf.data.array([1, 2, 3]).map(x => x*x);
await a.forEachAsync(e => console.log(e));

Parameters:

    transform ((value: T) => tf.void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string}) A function mapping a dataset element to a transformed dataset element.

Returns: tf.data.Dataset
mapAsync (transform) method Source

Maps this dataset through an async 1-to-1 transform.

const a =
  tf.data.array([1, 2, 3]).mapAsync(x => new Promise(function(resolve){
    setTimeout(() => {
      resolve(x * x);
    }, Math.random()*1000 + 500);
  }));
console.log(await a.toArray());

Parameters:

    transform ((value: T) => Promise<tf.void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string}>) A function mapping a dataset element to a Promise for a transformed dataset element. This transform is responsible for disposing any intermediate Tensors, i.e. by wrapping its computation in tf.tidy(); that cannot be automated here (as it is in the synchronous map() case).

Returns: tf.data.Dataset
prefetch (bufferSize) method Source

Creates a Dataset that prefetches elements from this dataset.
Parameters:

    bufferSize (number) : An integer specifying the number of elements to be prefetched.

Returns: tf.data.Dataset
repeat (count?) method Source

Repeats this dataset count times.

NOTE: If this dataset is a function of global state (e.g. a random number generator), then different repetitions may produce different elements.

const a = tf.data.array([1, 2, 3]).repeat(3);
await a.forEachAsync(e => console.log(e));

Parameters:

    count (number) : (Optional) An integer, representing the number of times the dataset should be repeated. The default behavior (if count is undefined or negative) is for the dataset be repeated indefinitely. Optional

Returns: tf.data.Dataset
skip (count) method Source

Creates a Dataset that skips count initial elements from this dataset.

const a = tf.data.array([1, 2, 3, 4, 5, 6]).skip(3);
await a.forEachAsync(e => console.log(e));

Parameters:

    count (number) : The number of elements of this dataset that should be skipped to form the new dataset. If count is greater than the size of this dataset, the new dataset will contain no elements. If count is undefined or negative, skips the entire dataset.

Returns: tf.data.Dataset
shuffle (bufferSize, seed?, reshuffleEachIteration?) method Source

Pseudorandomly shuffles the elements of this dataset. This is done in a streaming manner, by sampling from a given number of prefetched elements.

const a = tf.data.array([1, 2, 3, 4, 5, 6]).shuffle(3);
await a.forEachAsync(e => console.log(e));

Parameters:

    bufferSize (number) : An integer specifying the number of elements from this dataset from which the new dataset will sample.
    seed (string) : (Optional) An integer specifying the random seed that will be used to create the distribution. Optional
    reshuffleEachIteration (boolean) : (Optional) A boolean, which if true indicates that the dataset should be pseudorandomly reshuffled each time it is iterated over. If false, elements will be returned in the same shuffled order on each iteration. (Defaults to true.) Optional

Returns: tf.data.Dataset
take (count) method Source

Creates a Dataset with at most count initial elements from this dataset.

const a = tf.data.array([1, 2, 3, 4, 5, 6]).take(3);
await a.forEachAsync(e => console.log(e));

Parameters:

    count (number) : The number of elements of this dataset that should be taken to form the new dataset. If count is undefined or negative, or if count is greater than the size of this dataset, the new dataset will contain all elements of this dataset.

Returns: tf.data.Dataset
toArray () method Source

Collect all elements of this dataset into an array.

Obviously this will succeed only for small datasets that fit in memory. Useful for testing and generally should be avoided if possible.

const a = tf.data.array([1, 2, 3, 4, 5, 6]);
console.log(await a.toArray());

Returns: Promise<T[]>
Visualization

tfjs-vis is a companion library for TensorFlow.js that provides in-browser visualization capabilities for training and understanding models. API docs for tfjs-vis are available here
Util
Util /
tf.util.assert (expr, msg) function Source

Asserts that the expression is true. Otherwise throws an error with the provided message.

const x = 2;
tf.util.assert(x === 2, 'x is not 2');

Parameters:

    expr (boolean) The expression to assert (as a boolean).
    msg (() => string) A function that returns the message to report when throwing an error. We use a function for performance reasons.

Returns: void
tf.util.createShuffledIndices (n) function Source

Creates a new array with randomized indices to a given quantity.

const randomTen = tf.util.createShuffledIndices(10);
console.log(randomTen);

Parameters:

    n (number)

Returns: Uint32Array
tf.decodeString (bytes, encoding?) function Source

Decodes the provided bytes into a string using the provided encoding scheme.
Parameters:

    bytes (Uint8Array) The bytes to decode.
    encoding (string) The encoding scheme. Defaults to utf-8. Optional

Returns: string
tf.encodeString (s, encoding?) function Source

Encodes the provided string into bytes using the provided encoding scheme.
Parameters:

    s (string) The string to encode.
    encoding (string) The encoding scheme. Defaults to utf-8. Optional

Returns: Uint8Array
tf.fetch (path, requestInits?) function Source

Returns a platform-specific implementation of fetch.

If fetch is defined on the global object (window, process, etc.), tf.util.fetch returns that function.

If not, tf.util.fetch returns a platform-specific solution.

const resource = await tf.util.fetch('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs');
// handle response

Parameters:

    path (string)
    requestInits (RequestInit) Optional

Returns: Promise<Response>
tf.util.flatten (arr, result?, skipTypedArray?) function Source

Flattens an arbitrarily nested array.

const a = [[1, 2], [3, 4], [5, [6, [7]]]];
const flat = tf.util.flatten(a);
console.log(flat);

Parameters:

    arr (number|boolean|string|Promise<number>|TypedArray|RecursiveArray|TypedArray>) The nested array to flatten.
    result (number|boolean|string|Promise<number>|TypedArray[]) The destination array which holds the elements. Optional
    skipTypedArray (boolean) If true, avoids flattening the typed arrays. Defaults to false. Optional

Returns: number|boolean|string|Promise<number>|TypedArray[]
tf.util.now () function Source

Returns the current high-resolution time in milliseconds relative to an arbitrary time in the past. It works across different platforms (node.js, browsers).

console.log(tf.util.now());

Returns: number
tf.util.shuffle (array) function Source

Shuffles the array in-place using Fisher-Yates algorithm.

const a = [1, 2, 3, 4, 5];
tf.util.shuffle(a);
console.log(a);

Parameters:

    array (tf.any()[]|Uint32Array|Int32Array| Float32Array) The array to shuffle in-place.

Returns: void
tf.util.shuffleCombo (array, array2) function Source

Shuffles two arrays in-place the same way using Fisher-Yates algorithm.

const a = [1,2,3,4,5];
const b = [11,22,33,44,55];
tf.util.shuffleCombo(a, b);
console.log(a, b);

Parameters:

    array (tf.any()[]|Uint32Array|Int32Array|Float32Array) The first array to shuffle in-place.
    array2 (tf.any()[]|Uint32Array|Int32Array|Float32Array) The second array to shuffle in-place with the same permutation as the first array.

Returns: void
tf.util.sizeFromShape (shape) function Source

Returns the size (number of elements) of the tensor given its shape.

const shape = [3, 4, 2];
const size = tf.util.sizeFromShape(shape);
console.log(size);

Parameters:

    shape (number[])

Returns: number
Backends
Backends /
tf.backend () function Source

Gets the current backend. If no backends have been initialized, this will attempt to initialize the best backend. Will throw an error if the highest priority backend has async initialization, in which case you should call 'await tf.ready()' before running other code.
Returns: KernelBackend
tf.getBackend () function Source

Returns the current backend name (cpu, webgl, etc). The backend is responsible for creating tensors and executing operations on those tensors.
Returns: string
tf.ready () function Source

Returns a promise that resolves when the currently selected backend (or the highest priority one) has initialized. Await this promise when you are using a backend that has async initialization.
Returns: Promise<void>
tf.registerBackend (name, factory, priority?) function Source

Registers a global backend. The registration should happen when importing a module file (e.g. when importing backend_webgl.ts), and is used for modular builds (e.g. custom tfjs bundle with only webgl support).
Parameters:

    name (string)
    factory (() => KernelBackend | Promise<KernelBackend>) The backend factory function. When called, it should return a backend instance, or a promise of an instance.
    priority (number) The priority of the backend (higher = more important). In case multiple backends are registered, the priority is used to find the best backend. Defaults to 1. Optional

Returns: boolean
tf.removeBackend (name) function Source

Removes a backend and the registered factory.
Parameters:

    name (string)

Returns: void
tf.setBackend (backendName) function Source

Sets the backend (cpu, webgl, wasm, etc) responsible for creating tensors and executing operations on those tensors. Returns a promise that resolves to a boolean if the backend initialization was successful.

Note this disposes the current backend, if any, as well as any tensors associated with it. A new backend is initialized, even if it is of the same type as the previous one.
Parameters:

    backendName (string) The name of the backend. Currently supports 'webgl'|'cpu' in the browser, 'tensorflow' under node.js (requires tfjs-node), and 'wasm' (requires tfjs-backend-wasm).

Returns: Promise<boolean>
Browser
Browser /
tf.browser.draw (image, canvas, options?) function Source

Draws a tf.Tensor to a canvas.

When the dtype of the input is 'float32', we assume values in the range [0-1]. Otherwise, when input is 'int32', we assume values in the range [0-255].
Parameters:

    image (tf.Tensor2D|tf.Tensor3D|TypedArray|Array) The tensor to draw on the canvas. Must match one of these shapes:

        Rank-2 with shape [height, width]: Drawn as grayscale.
        Rank-3 with shape [height, width, 1]: Drawn as grayscale.
        Rank-3 with shape [height, width, 3]: Drawn as RGB with alpha set in imageOptions (defaults to 1, which is opaque).
        Rank-3 with shape [height, width, 4]: Drawn as RGBA.
    canvas (HTMLCanvasElement) The canvas to draw to.
    options (Object) The configuration arguments for image to be drawn and the canvas to draw to. Optional
    imageOptions (ImageOptions) Optional. An object of options to customize the values of image tensor.
    contextOptions (ContextOptions) Optional. An object to configure the context of the canvas to draw to.

Returns: void
tf.browser.fromPixels (pixels, numChannels?) function Source

Creates a tf.Tensor from an image.

const image = new ImageData(1, 1);
image.data[0] = 100;
image.data[1] = 150;
image.data[2] = 200;
image.data[3] = 255;

tf.browser.fromPixels(image).print();

Parameters:

    pixels (PixelData|ImageData|HTMLImageElement|HTMLCanvasElement| HTMLVideoElement|ImageBitmap) The input image to construct the tensor from. The supported image types are all 4-channel. You can also pass in an image object with following attributes: {data: Uint8Array; width: number; height: number}
    numChannels (number) The number of channels of the output tensor. A numChannels value less than 4 allows you to ignore channels. Defaults to 3 (ignores alpha channel of input image). Optional

Returns: tf.Tensor3D
tf.browser.fromPixelsAsync (pixels, numChannels?) function Source

Creates a tf.Tensor from an image in async way.

const image = new ImageData(1, 1);
image.data[0] = 100;
image.data[1] = 150;
image.data[2] = 200;
image.data[3] = 255;

(await tf.browser.fromPixelsAsync(image)).print();

This API is the async version of fromPixels. The API will first check |WRAP_TO_IMAGEBITMAP| flag, and try to wrap the input to imageBitmap if the flag is set to true.
Parameters:

    pixels (PixelData|ImageData|HTMLImageElement|HTMLCanvasElement| HTMLVideoElement|ImageBitmap) The input image to construct the tensor from. The supported image types are all 4-channel. You can also pass in an image object with following attributes: {data: Uint8Array; width: number; height: number}
    numChannels (number) The number of channels of the output tensor. A numChannels value less than 4 allows you to ignore channels. Defaults to 3 (ignores alpha channel of input image). Optional

Returns: Promise<tf.Tensor>
tf.browser.toPixels (img, canvas?) function Source

Draws a tf.Tensor of pixel values to a byte array or optionally a canvas.

When the dtype of the input is 'float32', we assume values in the range [0-1]. Otherwise, when input is 'int32', we assume values in the range [0-255].

Returns a promise that resolves when the canvas has been drawn to.
Parameters:

    img (tf.Tensor2D|tf.Tensor3D|TypedArray|Array) A rank-2 tensor with shape [height, width], or a rank-3 tensor of shape [height, width, numChannels]. If rank-2, draws grayscale. If rank-3, must have depth of 1, 3 or 4. When depth of 1, draws grayscale. When depth of 3, we draw with the first three components of the depth dimension corresponding to r, g, b and alpha = 1. When depth of 4, all four components of the depth dimension correspond to r, g, b, a.
    canvas (HTMLCanvasElement) The canvas to draw to. Optional

Returns: Promise<Uint8ClampedArray>
Metrics
Metrics /
tf.metrics.binaryAccuracy (yTrue, yPred) function Source

Binary accuracy metric function.

yTrue and yPred can have 0-1 values. Example:

const x = tf.tensor2d([[1, 1, 1, 1], [0, 0, 0, 0]], [2, 4]);
const y = tf.tensor2d([[1, 0, 1, 0], [0, 0, 0, 1]], [2, 4]);
const accuracy = tf.metrics.binaryAccuracy(x, y);
accuracy.print();

yTrue and yPred can also have floating-number values between 0 and 1, in which case the values will be thresholded at 0.5 to yield 0-1 values (i.e., a value >= 0.5 and <= 1.0 is interpreted as 1).

Example:

const x = tf.tensor1d([1, 1, 1, 1, 0, 0, 0, 0]);
const y = tf.tensor1d([0.2, 0.4, 0.6, 0.8, 0.2, 0.3, 0.4, 0.7]);
const accuracy = tf.metrics.binaryAccuracy(x, y);
accuracy.print();

Parameters:

    yTrue (tf.Tensor) Binary Tensor of truth.
    yPred (tf.Tensor) Binary Tensor of prediction.

Returns: tf.Tensor
tf.metrics.binaryCrossentropy (yTrue, yPred) function Source

Binary crossentropy metric function.

Example:

const x = tf.tensor2d([[0], [1], [1], [1]]);
const y = tf.tensor2d([[0], [0], [0.5], [1]]);
const crossentropy = tf.metrics.binaryCrossentropy(x, y);
crossentropy.print();

Parameters:

    yTrue (tf.Tensor) Binary Tensor of truth.
    yPred (tf.Tensor) Binary Tensor of prediction, probabilities for the 1 case.

Returns: tf.Tensor
tf.metrics.categoricalAccuracy (yTrue, yPred) function Source

Categorical accuracy metric function.

Example:

const x = tf.tensor2d([[0, 0, 0, 1], [0, 0, 0, 1]]);
const y = tf.tensor2d([[0.1, 0.8, 0.05, 0.05], [0.1, 0.05, 0.05, 0.8]]);
const accuracy = tf.metrics.categoricalAccuracy(x, y);
accuracy.print();

Parameters:

    yTrue (tf.Tensor) Binary Tensor of truth: one-hot encoding of categories.
    yPred (tf.Tensor) Binary Tensor of prediction: probabilities or logits for the same categories as in yTrue.

Returns: tf.Tensor
tf.metrics.categoricalCrossentropy (yTrue, yPred) function Source

Categorical crossentropy between an output tensor and a target tensor.
Parameters:

    yTrue (tf.Tensor)
    yPred (tf.Tensor)

Returns: tf.Tensor
tf.metrics.cosineProximity (yTrue, yPred) function Source

Loss or metric function: Cosine proximity.

Mathematically, cosine proximity is defined as: -sum(l2Normalize(yTrue) * l2Normalize(yPred)), wherein l2Normalize() normalizes the L2 norm of the input to 1 and * represents element-wise multiplication.

const yTrue = tf.tensor2d([[1, 0], [1, 0]]);
const yPred = tf.tensor2d([[1 / Math.sqrt(2), 1 / Math.sqrt(2)], [0, 1]]);
const proximity = tf.metrics.cosineProximity(yTrue, yPred);
proximity.print();

Parameters:

    yTrue (tf.Tensor) Truth Tensor.
    yPred (tf.Tensor) Prediction Tensor.

Returns: tf.Tensor
tf.metrics.meanAbsoluteError (yTrue, yPred) function Source

Loss or metric function: Mean absolute error.

Mathematically, mean absolute error is defined as: mean(abs(yPred - yTrue)), wherein the mean is applied over feature dimensions.

const yTrue = tf.tensor2d([[0, 1], [0, 0], [2, 3]]);
const yPred = tf.tensor2d([[0, 1], [0, 1], [-2, -3]]);
const mse = tf.metrics.meanAbsoluteError(yTrue, yPred);
mse.print();

Parameters:

    yTrue (tf.Tensor) Truth Tensor.
    yPred (tf.Tensor) Prediction Tensor.

Returns: tf.Tensor
tf.metrics.meanAbsolutePercentageError (yTrue, yPred) function Source

Loss or metric function: Mean absolute percentage error.

const yTrue = tf.tensor2d([[0, 1], [10, 20]]);
const yPred = tf.tensor2d([[0, 1], [11, 24]]);
const mse = tf.metrics.meanAbsolutePercentageError(yTrue, yPred);
mse.print();

Aliases: tf.metrics.MAPE, tf.metrics.mape.
Parameters:

    yTrue (tf.Tensor) Truth Tensor.
    yPred (tf.Tensor) Prediction Tensor.

Returns: tf.Tensor
tf.metrics.meanSquaredError (yTrue, yPred) function Source

Loss or metric function: Mean squared error.

const yTrue = tf.tensor2d([[0, 1], [3, 4]]);
const yPred = tf.tensor2d([[0, 1], [-3, -4]]);
const mse = tf.metrics.meanSquaredError(yTrue, yPred);
mse.print();

Aliases: tf.metrics.MSE, tf.metrics.mse.
Parameters:

    yTrue (tf.Tensor) Truth Tensor.
    yPred (tf.Tensor) Prediction Tensor.

Returns: tf.Tensor
tf.metrics.precision (yTrue, yPred) function Source

Computes the precision of the predictions with respect to the labels.

Example:

const x = tf.tensor2d(
    [
      [0, 0, 0, 1],
      [0, 1, 0, 0],
      [0, 0, 0, 1],
      [1, 0, 0, 0],
      [0, 0, 1, 0]
    ]
);

const y = tf.tensor2d(
    [
      [0, 0, 1, 0],
      [0, 1, 0, 0],
      [0, 0, 0, 1],
      [0, 1, 0, 0],
      [0, 1, 0, 0]
    ]
);

const precision = tf.metrics.precision(x, y);
precision.print();

Parameters:

    yTrue (tf.Tensor) The ground truth values. Expected to contain only 0-1 values.
    yPred (tf.Tensor) The predicted values. Expected to contain only 0-1 values.

Returns: tf.Tensor
tf.metrics.r2Score (yTrue, yPred) function Source

Computes R2 score.

const yTrue = tf.tensor2d([[0, 1], [3, 4]]);
const yPred = tf.tensor2d([[0, 1], [-3, -4]]);
const r2Score = tf.metrics.r2Score(yTrue, yPred);
r2Score.print();

Parameters:

    yTrue (tf.Tensor) Truth Tensor.
    yPred (tf.Tensor) Prediction Tensor.

Returns: tf.Tensor
tf.metrics.recall (yTrue, yPred) function Source

Computes the recall of the predictions with respect to the labels.

Example:

const x = tf.tensor2d(
    [
      [0, 0, 0, 1],
      [0, 1, 0, 0],
      [0, 0, 0, 1],
      [1, 0, 0, 0],
      [0, 0, 1, 0]
    ]
);

const y = tf.tensor2d(
    [
      [0, 0, 1, 0],
      [0, 1, 0, 0],
      [0, 0, 0, 1],
      [0, 1, 0, 0],
      [0, 1, 0, 0]
    ]
);

const recall = tf.metrics.recall(x, y);
recall.print();

Parameters:

    yTrue (tf.Tensor) The ground truth values. Expected to contain only 0-1 values.
    yPred (tf.Tensor) The predicted values. Expected to contain only 0-1 values.

Returns: tf.Tensor
tf.metrics.sparseCategoricalAccuracy (yTrue, yPred) function Source

Sparse categorical accuracy metric function.

Example:


const yTrue = tf.tensor1d([1, 1, 2, 2, 0]);
const yPred = tf.tensor2d(
      [[0, 1, 0], [1, 0, 0], [0, 0.4, 0.6], [0, 0.6, 0.4], [0.7, 0.3, 0]]);
const crossentropy = tf.metrics.sparseCategoricalAccuracy(yTrue, yPred);
crossentropy.print();

Parameters:

    yTrue (tf.Tensor) True labels: indices.
    yPred (tf.Tensor) Predicted probabilities or logits.

Returns: tf.Tensor
Callbacks
Callbacks /
tf.callbacks.earlyStopping (args?) function Source

Factory function for a Callback that stops training when a monitored quantity has stopped improving.

Early stopping is a type of regularization, and protects model against overfitting.

The following example based on fake data illustrates how this callback can be used during tf.LayersModel.fit():

const model = tf.sequential();
model.add(tf.layers.dense({
   units: 3,
   activation: 'softmax',
   kernelInitializer: 'ones',
   inputShape: [2]
}));
const xs = tf.tensor2d([1, 2, 3, 4], [2, 2]);
const ys = tf.tensor2d([[1, 0, 0], [0, 1, 0]], [2, 3]);
const xsVal = tf.tensor2d([4, 3, 2, 1], [2, 2]);
const ysVal = tf.tensor2d([[0, 0, 1], [0, 1, 0]], [2, 3]);
model.compile(
     {loss: 'categoricalCrossentropy', optimizer: 'sgd', metrics: ['acc']});

// Without the EarlyStopping callback, the val_acc value would be:
//   0.5, 0.5, 0.5, 0.5, ...
// With val_acc being monitored, training should stop after the 2nd epoch.
const history = await model.fit(xs, ys, {
   epochs: 10,
   validationData: [xsVal, ysVal],
   callbacks: tf.callbacks.earlyStopping({monitor: 'val_acc'})
});

// Expect to see a length-2 array.
console.log(history.history.val_acc);

Parameters:

    args (Object) Optional
    monitor (string) Quantity to be monitored.

    Defaults to 'val_loss'.
    minDelta (number) Minimum change in the monitored quantity to qualify as improvement, i.e., an absolute change of less than minDelta will count as no improvement.

    Defaults to 0.
    patience (number) Number of epochs with no improvement after which training will be stopped.

    Defaults to 0.
    verbose (number) Verbosity mode.
    mode ('auto'|'min'|'max') Mode: one of 'min', 'max', and 'auto'.

        In 'min' mode, training will be stopped when the quantity monitored has stopped decreasing.
        In 'max' mode, training will be stopped when the quantity monitored has stopped increasing.
        In 'auto' mode, the direction is inferred automatically from the name of the monitored quantity.

    Defaults to 'auto'.
    baseline (number) Baseline value of the monitored quantity.

    If specified, training will be stopped if the model doesn't show improvement over the baseline.
    restoreBestWeights (boolean) Whether to restore model weights from the epoch with the best value of the monitored quantity. If False, the model weights obtained at the last step of training are used.

    True is not supported yet.

Returns: EarlyStopping 